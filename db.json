{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/aero-dual/source/css/style.dark.styl","path":"css/style.dark.styl","modified":0,"renderable":1},{"_id":"themes/aero-dual/source/css/style.light.styl","path":"css/style.light.styl","modified":0,"renderable":1},{"_id":"themes/aero-dual/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":0,"renderable":1},{"_id":"themes/aero-dual/source/js/highlight.pack.js","path":"js/highlight.pack.js","modified":0,"renderable":1},{"_id":"themes/aero-dual/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":0,"renderable":1},{"_id":"themes/aero-dual/source/img/aero-dual-color-change.jpg","path":"img/aero-dual-color-change.jpg","modified":0,"renderable":1},{"_id":"themes/aero-dual/source/img/aero-dual-thumbnail.jpg","path":"img/aero-dual-thumbnail.jpg","modified":0,"renderable":1},{"_id":"source/banner-1.jpeg","path":"banner-1.jpeg","modified":0,"renderable":0},{"_id":"themes/aero-dual/source/img/default-banner-dark.jpg","path":"img/default-banner-dark.jpg","modified":0,"renderable":1},{"_id":"themes/aero-dual/source/img/banner-1.jpeg","path":"img/banner-1.jpeg","modified":0,"renderable":1},{"_id":"themes/aero-dual/source/img/default-banner-light.jpg","path":"img/default-banner-light.jpg","modified":0,"renderable":1},{"_id":"source/banner.jpeg","path":"banner.jpeg","modified":0,"renderable":0},{"_id":"themes/aero-dual/source/img/banner.jpeg","path":"img/banner.jpeg","modified":0,"renderable":1},{"_id":"source/imgs/me.jpg","path":"imgs/me.jpg","modified":0,"renderable":0},{"_id":"source/imgs/screen.gif","path":"imgs/screen.gif","modified":0,"renderable":0},{"_id":"source/imgs/progress.jpg","path":"imgs/progress.jpg","modified":0,"renderable":0},{"_id":"source/imgs/Node-redis-1.png","path":"imgs/Node-redis-1.png","modified":0,"renderable":0},{"_id":"source/imgs/Node-redis-2.png","path":"imgs/Node-redis-2.png","modified":0,"renderable":0},{"_id":"source/imgs/Node-redis-3.png","path":"imgs/Node-redis-3.png","modified":0,"renderable":0},{"_id":"source/imgs/Node-redis-4.png","path":"imgs/Node-redis-4.png","modified":0,"renderable":0},{"_id":"source/imgs/canvas-eraser.png","path":"imgs/canvas-eraser.png","modified":0,"renderable":0},{"_id":"source/imgs/excel-to-json.png","path":"imgs/excel-to-json.png","modified":0,"renderable":0},{"_id":"source/imgs/excel-to-json2.png","path":"imgs/excel-to-json2.png","modified":0,"renderable":0},{"_id":"source/imgs/excel-to-json3.png","path":"imgs/excel-to-json3.png","modified":0,"renderable":0},{"_id":"source/imgs/run-times-compare.jpg","path":"imgs/run-times-compare.jpg","modified":0,"renderable":0},{"_id":"source/imgs/watch-data-change.png","path":"imgs/watch-data-change.png","modified":0,"renderable":0},{"_id":"source/imgs/class-mode-conpare.png","path":"imgs/class-mode-conpare.png","modified":0,"renderable":0},{"_id":"source/imgs/react-native-app-1-1.png","path":"imgs/react-native-app-1-1.png","modified":0,"renderable":0},{"_id":"source/imgs/react-native-app-1-2.png","path":"imgs/react-native-app-1-2.png","modified":0,"renderable":0},{"_id":"source/imgs/react-native-app-1-3.png","path":"imgs/react-native-app-1-3.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"d578ee787bca80328778d79a6e19a344f46c5183","modified":1478700264000},{"_id":"themes/aero-dual/.DS_Store","hash":"05ac089e31c5c932a9845580904387850f715a1b","modified":1478484538000},{"_id":"themes/aero-dual/LICENSE","hash":"d1f917294a5484d49c0ecf43a81ab6e2a5396f4a","modified":1475176672000},{"_id":"themes/aero-dual/README.md","hash":"c5107b4fe3da1b18e0e3d75574a566b7fde9e238","modified":1475176672000},{"_id":"themes/aero-dual/_config.yml","hash":"07c2d4457894518b145c74623ee7b28fef5504c6","modified":1478484623000},{"_id":"source/_posts/2015-02-24-apply-call.md","hash":"643db9fa432b1e1e92e4d3fbcc0fbdee4a3d7a90","modified":1478699925000},{"_id":"source/_posts/2015-03-07-arguments.md","hash":"d313225855b749f9d38ec087479a0bc7acf23e2f","modified":1478699961000},{"_id":"source/_posts/2015-02-24-short-circuit-gramar.md","hash":"a0409632a2203130c3c996b747762c7b9f2f9389","modified":1478699942000},{"_id":"source/_posts/2015-03-10-js-object-create-class-mode.md","hash":"55f40361c5c65ccc740e03eb4ee610d784bbf6c3","modified":1478699970000},{"_id":"source/_posts/2015-05-23-js-object-prototype.md","hash":"e0b588baab9eea1192d62f7073ef9cf2630a41e9","modified":1478699981000},{"_id":"source/_posts/2015-05-26-js-object-extend.md","hash":"a8bff7c28f03b5efcf346530a1b305f8a3320d12","modified":1478699988000},{"_id":"source/_posts/2015-05-27-js-design-mode-interface.md","hash":"1f4120e02d8ccf7e72763abb62d5e28ab3a2c667","modified":1478699996000},{"_id":"source/_posts/2015-06-03-js-design-mode-bridge.md","hash":"7123b077b39c55b6cf8e6864ed6ab665b530c583","modified":1478700024000},{"_id":"source/_posts/2015-06-13-js-design-mode-adoptor.md","hash":"3ab50ad7f0c51067d514f4edb13a3e97f47f46d3","modified":1478700039000},{"_id":"source/_posts/2015-06-09-js-design-mode-composite.md","hash":"29a3606c60ca06695d533a9a42db2533dff3d028","modified":1478700033000},{"_id":"source/_posts/2015-05-31-js-design-mode-factory.md","hash":"720de197b5382508bba068918f57b398d7b2d1f7","modified":1478700008000},{"_id":"source/_posts/2015-06-21-js-design-mode-facade.md","hash":"f58453af95e61acc1b41a575c055f5b53d797ecb","modified":1478700046000},{"_id":"source/_posts/2015-07-15-js-design-mode-decorator.md","hash":"8b3f623a9ed0918cc087625f562ff588cd2101a0","modified":1478700055000},{"_id":"source/_posts/2015-07-18-javascript-closure.md","hash":"a0123d36203bb6907133d666d21139181620be69","modified":1478700064000},{"_id":"source/_posts/2015-07-20-javascript-variable-promotion.md","hash":"f6cf87cdd4baaf5c600a8c7add5a20623339eb52","modified":1478700074000},{"_id":"source/_posts/2015-08-20-Node-redis-across-database-insert.md","hash":"dcbd5108a9ee3a5a7250b30c4ae90249d5b516bf","modified":1478700080000},{"_id":"source/_posts/2015-11-17-Node-deal-excel.md","hash":"a8821518e4b8e88ec3e4c7452164286a83038124","modified":1478485191000},{"_id":"source/_posts/2015-11-20-my-first-react-demo.md","hash":"3132306e713cf3f656c7a62850405a7bb373d794","modified":1478700088000},{"_id":"source/_posts/2015-12-01-react-component-life-time.md","hash":"573a7719d8c282b501171ecd0364d4b675686ede","modified":1474949494000},{"_id":"source/_posts/2015-12-02-react-data-flow.md","hash":"e4ca92672c733c94cc8254fbf6463611ca33c502","modified":1474949501000},{"_id":"source/_posts/2015-12-03-react-events.md","hash":"2c1996f0a5fcb4ad4a514f666c4933a4bbc520d3","modified":1474949509000},{"_id":"source/_posts/2015-12-04-react-component-mixin.md","hash":"b5f3fef8048e4ddef31df7ca74a05b5d1793decc","modified":1474949517000},{"_id":"source/_posts/2015-12-05-react-dom.md","hash":"a9c433f6cc9cc6f043cc5c4b0ef620b71d4936d8","modified":1474949524000},{"_id":"source/_posts/2016-01-12-expend-objectc.md","hash":"fd7272464544ee7f96e11f239b46972c3f9bc4e0","modified":1478485191000},{"_id":"source/_posts/2016-01-16-javascript-higher-order-functions.md","hash":"1eced3c4e38b820b64df34a89eff2c9cba0f2abc","modified":1478700105000},{"_id":"source/_posts/2016-03-10-js-object-extend2.md","hash":"79686d30374322956cd73cf3d79b3d08ec98d12b","modified":1478700113000},{"_id":"source/_posts/2016-03-24-javascript-self-loader.md","hash":"c8ce0b03bbd6003a4c032d38142da54514bb2306","modified":1478700118000},{"_id":"source/_posts/2016-05-04-es6-promise.md","hash":"3216a968289f09b6de6ab88de47fda3e5ebe2e1f","modified":1478700125000},{"_id":"source/_posts/2016-06-23-watch-data-change.md","hash":"ac5419bbef4727614ca392deb874137861e5ea7e","modified":1478485191000},{"_id":"source/_posts/2016-07-10-fetch-timeout.md","hash":"072f78e09a046a96964998acdd910511472d6447","modified":1478700141000},{"_id":"source/_posts/2016-07-20-javascript-function-throttle.md","hash":"5b75d15146d7ad0c8f2789f42ec2cd0b27380d02","modified":1478700147000},{"_id":"source/_posts/2016-08-30-something-about-javascript-Date.md","hash":"7ca488b0a45379a0b3da1e913cce96743c969d75","modified":1478700156000},{"_id":"source/_posts/2016-09-17-javascript-serialize.md","hash":"d4ce4cbfa196c3038203ad9bd3cb9c1f3576a617","modified":1478700164000},{"_id":"source/_posts/2016-11-02-ie-ajax-cache.md","hash":"acd366891ea800292924d444ce727f7ca67dd6b7","modified":1478700169000},{"_id":"themes/aero-dual/languages/zh-CN.yml","hash":"1db3c462e89c86e443c686057a05f71d7f438c50","modified":1475176672000},{"_id":"themes/aero-dual/layout/archive.ejs","hash":"273dec29ccd9b596e305618b82e6ee4e930b3327","modified":1475176672000},{"_id":"themes/aero-dual/layout/index.ejs","hash":"43f88bc5d83aa7e791a8ef05af09d71f72d6f917","modified":1475176672000},{"_id":"themes/aero-dual/languages/en.yml","hash":"2c5c7c44a36d207c425b8033bf99bdcfa7dcd8d0","modified":1475176672000},{"_id":"themes/aero-dual/layout/layout.ejs","hash":"18550a2bff0e3a3556f54ac11f6b490d2683737c","modified":1478483571000},{"_id":"themes/aero-dual/layout/page.ejs","hash":"a9fa586eb3366949207921edd02eab07e7a2f0c0","modified":1475176672000},{"_id":"themes/aero-dual/layout/post.ejs","hash":"a9fa586eb3366949207921edd02eab07e7a2f0c0","modified":1475176672000},{"_id":"themes/aero-dual/source/.DS_Store","hash":"dca8fd220f21b191393549782dc9f67b43a68be0","modified":1478484538000},{"_id":"themes/aero-dual/layout/_partial/google-analytics.ejs","hash":"d19d394eb45cde43504306c5dc377f044faf0a23","modified":1475176672000},{"_id":"themes/aero-dual/layout/_partial/after-footer.ejs","hash":"f98091c7aace55d71c1ba458979e789edeecc029","modified":1475176672000},{"_id":"themes/aero-dual/layout/_partial/archive-entry.ejs","hash":"2f509e24aed6d471a1224485e4372feefebcad02","modified":1478484287000},{"_id":"themes/aero-dual/layout/_partial/footer.ejs","hash":"17efb30433c49bdb17600c7e9cbca5af7b64cc30","modified":1478483961000},{"_id":"themes/aero-dual/layout/_partial/header.ejs","hash":"ae7561048f433b377b8cccf94413fe88813df35b","modified":1475176672000},{"_id":"themes/aero-dual/layout/_partial/html-head.ejs","hash":"36ac5dbd80a4eefea2b49f7a0de25f97d6b16d9c","modified":1475176672000},{"_id":"themes/aero-dual/layout/_partial/index-entry.ejs","hash":"670591e16e65403b8681b6f332cf38d9211017d4","modified":1478701629000},{"_id":"themes/aero-dual/layout/_partial/pagination.ejs","hash":"e70eda7f452724c083073342df3b897019656d13","modified":1475176672000},{"_id":"themes/aero-dual/source/css/_base.styl","hash":"176ae298d70df9c063e6414c7723a434854e8bee","modified":1475176672000},{"_id":"themes/aero-dual/source/css/style.dark.styl","hash":"079289e71db062072ade0a64f2a4fa671a53c9b3","modified":1475176672000},{"_id":"themes/aero-dual/source/css/style.light.styl","hash":"5ef3cff44a3f0dc612811ca0d3e452f96a787b38","modified":1475176672000},{"_id":"themes/aero-dual/source/js/bootstrap.min.js","hash":"430a443d74830fe9be26efca431f448c1b3740f9","modified":1475176672000},{"_id":"themes/aero-dual/source/js/highlight.pack.js","hash":"0708051de45d4cd35d0727f577e02f90ec0a60f4","modified":1475176672000},{"_id":"themes/aero-dual/source/css/bootstrap.min.css","hash":"6527d8bf3e1e9368bab8c7b60f56bc01fa3afd68","modified":1475176672000},{"_id":"themes/aero-dual/layout/_partial/post/article.ejs","hash":"83f6a18e9de25264a8c20b8a793c11c75e0bcf44","modified":1478484103000},{"_id":"themes/aero-dual/layout/_partial/post/categories.ejs","hash":"da398995647f6fe549cc60003cbe193b39c07f8e","modified":1475176672000},{"_id":"themes/aero-dual/layout/_partial/post/tags.ejs","hash":"2ecd44bfa51b6c3c2343cc39038225d10e9775ca","modified":1475176672000},{"_id":"themes/aero-dual/source/css/_helpers/mixins.styl","hash":"ebc6918703b60b1bc71ee879ef7970c881bba8b5","modified":1475176672000},{"_id":"themes/aero-dual/source/css/_partial/archive-entry.styl","hash":"ed5fa62d499ac2f4af375ffabb6246be2bef07ad","modified":1475176672000},{"_id":"themes/aero-dual/source/css/_partial/footer.styl","hash":"ff2b0419b7875860c391f454ec4f105192330fdf","modified":1475176672000},{"_id":"themes/aero-dual/source/css/_partial/article.styl","hash":"1fa4af57699829f4280c428e01558bea55c5afec","modified":1475176672000},{"_id":"themes/aero-dual/source/css/_partial/header.styl","hash":"122e8bddb4ba45752a6e8caa83d1d88c46af1220","modified":1475176672000},{"_id":"themes/aero-dual/source/css/_partial/index-entry.styl","hash":"b78c87bec299215682ec6f56d22cd5c8d5a935f6","modified":1475176672000},{"_id":"themes/aero-dual/source/css/_typography/code.styl","hash":"6b4a90c15ac2a71483c2f6ed9c971bd90c5aa2e9","modified":1475176672000},{"_id":"themes/aero-dual/source/css/_partial/pagination.styl","hash":"32efb7506e9c824f7e8132c8f4a216301334f8e1","modified":1475176672000},{"_id":"themes/aero-dual/source/css/_typography/highlight.dracula.styl","hash":"848d245175f97bf255add7a2a089193a3cfed229","modified":1475176672000},{"_id":"themes/aero-dual/source/css/_typography/highlight.monikai-sublime.styl","hash":"6fa62d4ced718f52b85ea2d92d883ac0b57df35b","modified":1475176672000},{"_id":"themes/aero-dual/source/css/_typography/typo.css","hash":"2901fed191955827af9bca56e4b50dc9c06a8533","modified":1475176672000},{"_id":"themes/aero-dual/source/css/_typography/highlight.gruvbox-light.styl","hash":"0a8bbc4ad4718661e9292b71423c7fa7ddb613d5","modified":1475176672000},{"_id":"themes/aero-dual/source/img/aero-dual-color-change.jpg","hash":"d9c779262e2e4d9f54e42e54d63c94b54294a4dc","modified":1475176672000},{"_id":"themes/aero-dual/source/img/aero-dual-thumbnail.jpg","hash":"939c91a321b1caf579262fab7d8837812e21b5a9","modified":1475176672000},{"_id":"source/banner-1.jpeg","hash":"f7067766bc400d800411c2c91a33bfe065884ef7","modified":1478484476000},{"_id":"themes/aero-dual/source/img/default-banner-dark.jpg","hash":"e15832861cc6e5d55d08fbbe9d1cd472fe1a876e","modified":1475176672000},{"_id":"themes/aero-dual/source/img/banner-1.jpeg","hash":"f7067766bc400d800411c2c91a33bfe065884ef7","modified":1478484476000},{"_id":"themes/aero-dual/source/img/default-banner-light.jpg","hash":"df4daccf84205e76708fc5e703dc2476f59a9d9d","modified":1475176672000},{"_id":"source/banner.jpeg","hash":"96f107507ceb744fa0ca2495a7d7c8b8cdfdd578","modified":1478484466000},{"_id":"themes/aero-dual/source/img/banner.jpeg","hash":"96f107507ceb744fa0ca2495a7d7c8b8cdfdd578","modified":1478484466000},{"_id":"source/imgs/Node-redis-2.png","hash":"6039343d595adffffac53b54c59927e7d3433911","modified":1447751306000},{"_id":"source/imgs/Node-redis-4.png","hash":"ee08208927c5da8d62ffafd0b636d70f5dd45f81","modified":1447751306000},{"_id":"source/imgs/class-mode-conpare.png","hash":"eb2d4958ebd5daa4c5b4b775465b2ee69f17274c","modified":1447751306000},{"_id":"source/imgs/excel-to-json.png","hash":"8f9e3cb36a4ef68290304b20d14f73179b014d6b","modified":1447752870000},{"_id":"source/imgs/excel-to-json2.png","hash":"50e80f279534c74b29f46bc22717a3a0927706e0","modified":1447753794000},{"_id":"source/imgs/react-native-app-1-2.png","hash":"5377d83e3c4c83b85a62fb96e0045b0cde05d8be","modified":1447992208000},{"_id":"source/imgs/run-times-compare.jpg","hash":"2bfc70b553a212bdeaadd34adfaadfcee7251e24","modified":1447751306000},{"_id":"source/imgs/screen.gif","hash":"5622705da24d9dbde063d28c83d88ff3e60809fc","modified":1472312121000},{"_id":"source/imgs/canvas-eraser.png","hash":"2a2b8dd4f19b540635b982c6203681f2b1814383","modified":1447751306000},{"_id":"source/imgs/me.jpg","hash":"449247f2f4a458ad1015f95958c472842159d11c","modified":1447751306000},{"_id":"source/imgs/progress.jpg","hash":"ef8d3c271900c5144b0eb261f676627a174e8221","modified":1452582099000},{"_id":"source/imgs/watch-data-change.png","hash":"03c65b1e023274ab896158c1e9cabedd00ca8442","modified":1466696220000},{"_id":"source/imgs/Node-redis-1.png","hash":"31d3a2c397ef9258ee2c78050b87fa77d15d5f95","modified":1447751306000},{"_id":"source/imgs/Node-redis-3.png","hash":"32e86a061f7d16fa75e3b2087d3b31f6f9b1d4af","modified":1447751306000},{"_id":"source/imgs/excel-to-json3.png","hash":"bc5e58fbcb23d176a5d488162f24a7253516020f","modified":1447769277000},{"_id":"source/imgs/react-native-app-1-3.png","hash":"c0649ef3d56b9cbf808eea49a2e34048bb0b1011","modified":1447992464000},{"_id":"source/imgs/react-native-app-1-1.png","hash":"5a3504965c11c0568f092b338a1f2f7141e0e5db","modified":1447992144000},{"_id":"source/_posts/2016-11-09-async:await-tourial.md","hash":"97f1fb515557af450e3b23d909bb77ca6a8acc2e","modified":1478700194000}],"Category":[{"name":"javascript","_id":"civ7fsedz0002t95fu2i945ao"},{"name":"NodeJs","_id":"civ7fsef4000vt95fiy6yixzc"},{"name":"React","_id":"civ7fsefc0017t95f6bngbmde"},{"name":"ES6","_id":"civ7fseg1001ut95fje04c3b6"},{"name":"ajax","parent":"civ7fsedz0002t95fu2i945ao","_id":"civ7fseg50022t95fqedybpdk"},{"name":"AngularJs","parent":"civ7fsedz0002t95fu2i945ao","_id":"civ7gks3p002at95fk4hy4mj6"},{"name":"ajax","parent":"civ7gks3p002at95fk4hy4mj6","_id":"civ7gks3q002bt95f3wnyuk41"},{"name":"ES7","parent":"civ7fsedz0002t95fu2i945ao","_id":"civb0mxha00015m5f12g95r7r"},{"name":"async/await","parent":"civb0mxha00015m5f12g95r7r","_id":"civb0mxit00025m5f9s7oiemt"},{"name":"call/apply","parent":"civ7fsedz0002t95fu2i945ao","_id":"civb0mxjv00065m5fzt1m9dyd"},{"name":"类","parent":"civ7fsedz0002t95fu2i945ao","_id":"civb0mxk200075m5f7augdekd"},{"name":"原型","parent":"civ7fsedz0002t95fu2i945ao","_id":"civb0mxk800095m5fb5cg6a2n"},{"name":"arguments","parent":"civ7fsedz0002t95fu2i945ao","_id":"civb0mxkb000b5m5fkonycz4h"},{"name":"短路语法","parent":"civ7fsedz0002t95fu2i945ao","_id":"civb0mxkf000d5m5f0eeei09p"},{"name":"设计模式","parent":"civ7fsedz0002t95fu2i945ao","_id":"civb0mxkj000f5m5fzsxmmg4b"},{"name":"接口","parent":"civ7fsedz0002t95fu2i945ao","_id":"civb0mxkn000h5m5flaeqwj6q"},{"name":"继承","parent":"civ7fsedz0002t95fu2i945ao","_id":"civb0mxl3000q5m5f6rlcqp5m"},{"name":"变量提升","parent":"civ7fsedz0002t95fu2i945ao","_id":"civb0mxlb000u5m5fqjae3ews"},{"name":"闭包","parent":"civ7fsedz0002t95fu2i945ao","_id":"civb0mxle000y5m5fzjgofre4"},{"name":"高阶函数","parent":"civ7fsedz0002t95fu2i945ao","_id":"civb0mxlf00105m5f7i7ic20c"},{"name":"fetch","parent":"civ7fseg1001ut95fje04c3b6","_id":"civb0mxlh00145m5f8spzkp0l"},{"name":"Promise","parent":"civ7fseg1001ut95fje04c3b6","_id":"civb0mxli00165m5fqp4tht0d"},{"name":"函数节流","parent":"civ7fsedz0002t95fu2i945ao","_id":"civb0mxlj00185m5f0ohwy16t"},{"name":"Date","parent":"civ7fsedz0002t95fu2i945ao","_id":"civb0mxlk001a5m5fwrokdy4x"},{"name":"序列化","parent":"civ7fsedz0002t95fu2i945ao","_id":"civb0mxln001c5m5fvp0hv9ie"}],"Data":[],"Page":[],"Post":[{"layout":"post","title":"我理解的apply和call","date":"2015-02-23T16:00:00.000Z","_content":"\n方法定义:\n\n语法：call([this[,arg1[, arg2[,   [,.argN]]]]])\n\n定义：调用一个对象的一个方法，以另一个对象替换当前对象。\n\n说明：call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 this 指定的新对象。如果没有提供 this 参数，那么 Global 对象被用作 this。\n\n语法：apply([this[,argArray]])\n\n定义：应用某一对象的一个方法，用另一个对象替换当前对象。\n\n说明：如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。如果没有提供 argArray 和 this 任何一个参数，那么 Global 对象将被用作 this， 并且无法被传递任何参数。\n\n两者区别微乎其微(除了调用对象传的参数一致，apply传入的参数是逐个传入，而apply是通过一个数组传的)\n\n示例:\n\n//  做绑定参数之用\n\n    function sum(x,y){\n        return x + y;\n    }\n\n    function call1(num1,num2){\n        return sum.call(this,num1,num2);\n    }\n    //  call调用sum\n\n    function apply1(num1,num2){\n        return sum.apply(this,[num1,num2]);\n    }\n    //  apply调用sum\n\n    console.log(call1(10,20));\n    console.log(apply1(16,20));\n\n//  扩充作用域，对象和方法不需要有任何关系\n\n    window.color = \"red\";\n\n    var obj = {\n        \"color\":\"blue\"\n    };\n\n    function showColor(){\n        console.log(this.color);\n    }\n\n    showColor.call(this);\n\n    showColor.call(obj);\n    //  通过指定调用者来区分作用域\n\n\n//  实现继承\n\n     function obj(name){\n         this.name = name;\n         this.showName = function(){\n             console.log(this.name);\n         }\n     }\n     // obj对象\n\n     function Cat(name){\n         obj.call(this, name);\n         // 继承obj对象\n     }\n\n     var cat = new Cat(\"A Cat\");\n     cat.showName();\n\n//  模拟实现call方法\n\n    function test1(a,b){\n        return a + b;\n    }\n    //  定义普通的方法\n\n    function Obj(x,y){\n        this.x = x;\n        this.y = y;\n        //  指定Obj的属性x和y就是传入的x和y\n        return x * y;\n    }\n    //  定义一个对象\n\n    var o = new Obj(10,20);\n    //  实例化一个Obj对象\n\n    console.log(test1.call(o,o.x, o.y));\n\n    o.method = test1;\n    //  实例化对象的临时变量，用于接受调用者\n    console.log(o.method(o.x, o.y));\n    delete  o.method;\n    //  调用完以后删除临时变量\n\n//  此外，也可以用来判断类型\n\n    console.log(Object.prototype.toString.apply(o));\n    console.log(Object.prototype.toString.call(o));","source":"_posts/2015-02-24-apply-call.md","raw":"---\nlayout: post\ntitle: 我理解的apply和call\ndate: 2015-02-24\ncategories: [javascript, call/apply]\n---\n\n方法定义:\n\n语法：call([this[,arg1[, arg2[,   [,.argN]]]]])\n\n定义：调用一个对象的一个方法，以另一个对象替换当前对象。\n\n说明：call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 this 指定的新对象。如果没有提供 this 参数，那么 Global 对象被用作 this。\n\n语法：apply([this[,argArray]])\n\n定义：应用某一对象的一个方法，用另一个对象替换当前对象。\n\n说明：如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。如果没有提供 argArray 和 this 任何一个参数，那么 Global 对象将被用作 this， 并且无法被传递任何参数。\n\n两者区别微乎其微(除了调用对象传的参数一致，apply传入的参数是逐个传入，而apply是通过一个数组传的)\n\n示例:\n\n//  做绑定参数之用\n\n    function sum(x,y){\n        return x + y;\n    }\n\n    function call1(num1,num2){\n        return sum.call(this,num1,num2);\n    }\n    //  call调用sum\n\n    function apply1(num1,num2){\n        return sum.apply(this,[num1,num2]);\n    }\n    //  apply调用sum\n\n    console.log(call1(10,20));\n    console.log(apply1(16,20));\n\n//  扩充作用域，对象和方法不需要有任何关系\n\n    window.color = \"red\";\n\n    var obj = {\n        \"color\":\"blue\"\n    };\n\n    function showColor(){\n        console.log(this.color);\n    }\n\n    showColor.call(this);\n\n    showColor.call(obj);\n    //  通过指定调用者来区分作用域\n\n\n//  实现继承\n\n     function obj(name){\n         this.name = name;\n         this.showName = function(){\n             console.log(this.name);\n         }\n     }\n     // obj对象\n\n     function Cat(name){\n         obj.call(this, name);\n         // 继承obj对象\n     }\n\n     var cat = new Cat(\"A Cat\");\n     cat.showName();\n\n//  模拟实现call方法\n\n    function test1(a,b){\n        return a + b;\n    }\n    //  定义普通的方法\n\n    function Obj(x,y){\n        this.x = x;\n        this.y = y;\n        //  指定Obj的属性x和y就是传入的x和y\n        return x * y;\n    }\n    //  定义一个对象\n\n    var o = new Obj(10,20);\n    //  实例化一个Obj对象\n\n    console.log(test1.call(o,o.x, o.y));\n\n    o.method = test1;\n    //  实例化对象的临时变量，用于接受调用者\n    console.log(o.method(o.x, o.y));\n    delete  o.method;\n    //  调用完以后删除临时变量\n\n//  此外，也可以用来判断类型\n\n    console.log(Object.prototype.toString.apply(o));\n    console.log(Object.prototype.toString.call(o));","slug":"2015-02-24-apply-call","published":1,"updated":"2016-11-09T13:58:45.000Z","_id":"civ7fseds0000t95fh0xw92a6","comments":1,"photos":[],"link":"","content":"<p>方法定义:</p>\n<p>语法：call([this[,arg1[, arg2[,   [,.argN]]]]])</p>\n<p>定义：调用一个对象的一个方法，以另一个对象替换当前对象。</p>\n<p>说明：call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 this 指定的新对象。如果没有提供 this 参数，那么 Global 对象被用作 this。</p>\n<p>语法：apply([this[,argArray]])</p>\n<p>定义：应用某一对象的一个方法，用另一个对象替换当前对象。</p>\n<p>说明：如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。如果没有提供 argArray 和 this 任何一个参数，那么 Global 对象将被用作 this， 并且无法被传递任何参数。</p>\n<p>两者区别微乎其微(除了调用对象传的参数一致，apply传入的参数是逐个传入，而apply是通过一个数组传的)</p>\n<p>示例:</p>\n<p>//  做绑定参数之用</p>\n<pre><code>function sum(x,y){\n    return x + y;\n}\n\nfunction call1(num1,num2){\n    return sum.call(this,num1,num2);\n}\n//  call调用sum\n\nfunction apply1(num1,num2){\n    return sum.apply(this,[num1,num2]);\n}\n//  apply调用sum\n\nconsole.log(call1(10,20));\nconsole.log(apply1(16,20));\n</code></pre><p>//  扩充作用域，对象和方法不需要有任何关系</p>\n<pre><code>window.color = &quot;red&quot;;\n\nvar obj = {\n    &quot;color&quot;:&quot;blue&quot;\n};\n\nfunction showColor(){\n    console.log(this.color);\n}\n\nshowColor.call(this);\n\nshowColor.call(obj);\n//  通过指定调用者来区分作用域\n</code></pre><p>//  实现继承</p>\n<pre><code>function obj(name){\n    this.name = name;\n    this.showName = function(){\n        console.log(this.name);\n    }\n}\n// obj对象\n\nfunction Cat(name){\n    obj.call(this, name);\n    // 继承obj对象\n}\n\nvar cat = new Cat(&quot;A Cat&quot;);\ncat.showName();\n</code></pre><p>//  模拟实现call方法</p>\n<pre><code>function test1(a,b){\n    return a + b;\n}\n//  定义普通的方法\n\nfunction Obj(x,y){\n    this.x = x;\n    this.y = y;\n    //  指定Obj的属性x和y就是传入的x和y\n    return x * y;\n}\n//  定义一个对象\n\nvar o = new Obj(10,20);\n//  实例化一个Obj对象\n\nconsole.log(test1.call(o,o.x, o.y));\n\no.method = test1;\n//  实例化对象的临时变量，用于接受调用者\nconsole.log(o.method(o.x, o.y));\ndelete  o.method;\n//  调用完以后删除临时变量\n</code></pre><p>//  此外，也可以用来判断类型</p>\n<pre><code>console.log(Object.prototype.toString.apply(o));\nconsole.log(Object.prototype.toString.call(o));\n</code></pre>","excerpt":"","more":"<p>方法定义:</p>\n<p>语法：call([this[,arg1[, arg2[,   [,.argN]]]]])</p>\n<p>定义：调用一个对象的一个方法，以另一个对象替换当前对象。</p>\n<p>说明：call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 this 指定的新对象。如果没有提供 this 参数，那么 Global 对象被用作 this。</p>\n<p>语法：apply([this[,argArray]])</p>\n<p>定义：应用某一对象的一个方法，用另一个对象替换当前对象。</p>\n<p>说明：如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。如果没有提供 argArray 和 this 任何一个参数，那么 Global 对象将被用作 this， 并且无法被传递任何参数。</p>\n<p>两者区别微乎其微(除了调用对象传的参数一致，apply传入的参数是逐个传入，而apply是通过一个数组传的)</p>\n<p>示例:</p>\n<p>//  做绑定参数之用</p>\n<pre><code>function sum(x,y){\n    return x + y;\n}\n\nfunction call1(num1,num2){\n    return sum.call(this,num1,num2);\n}\n//  call调用sum\n\nfunction apply1(num1,num2){\n    return sum.apply(this,[num1,num2]);\n}\n//  apply调用sum\n\nconsole.log(call1(10,20));\nconsole.log(apply1(16,20));\n</code></pre><p>//  扩充作用域，对象和方法不需要有任何关系</p>\n<pre><code>window.color = &quot;red&quot;;\n\nvar obj = {\n    &quot;color&quot;:&quot;blue&quot;\n};\n\nfunction showColor(){\n    console.log(this.color);\n}\n\nshowColor.call(this);\n\nshowColor.call(obj);\n//  通过指定调用者来区分作用域\n</code></pre><p>//  实现继承</p>\n<pre><code>function obj(name){\n    this.name = name;\n    this.showName = function(){\n        console.log(this.name);\n    }\n}\n// obj对象\n\nfunction Cat(name){\n    obj.call(this, name);\n    // 继承obj对象\n}\n\nvar cat = new Cat(&quot;A Cat&quot;);\ncat.showName();\n</code></pre><p>//  模拟实现call方法</p>\n<pre><code>function test1(a,b){\n    return a + b;\n}\n//  定义普通的方法\n\nfunction Obj(x,y){\n    this.x = x;\n    this.y = y;\n    //  指定Obj的属性x和y就是传入的x和y\n    return x * y;\n}\n//  定义一个对象\n\nvar o = new Obj(10,20);\n//  实例化一个Obj对象\n\nconsole.log(test1.call(o,o.x, o.y));\n\no.method = test1;\n//  实例化对象的临时变量，用于接受调用者\nconsole.log(o.method(o.x, o.y));\ndelete  o.method;\n//  调用完以后删除临时变量\n</code></pre><p>//  此外，也可以用来判断类型</p>\n<pre><code>console.log(Object.prototype.toString.apply(o));\nconsole.log(Object.prototype.toString.call(o));\n</code></pre>"},{"layout":"post","title":"javascript中arguments对象","date":"2015-03-06T16:00:00.000Z","_content":"\narguments对象    \n定义：   \narguments是传进实参的集合,可理解为数组类型,但是又不是数组类型   \n常用属性arguments.callee,该属性像一个指针,指向函数自己,但是该属性在严格模式下被禁用了,意味着在严格模式下无法在匿名函数内部调用自身。\n\n在js中,允许函数的实参和形参个数不同,即使这样,在函数运行时也不会报错,看下面的例子：\n\n\tfunction test(a,b,c,d){\n        return a + b + c + d;\n    }\n\n\tconsole.log(test(1,2,3,4,5));\n\t//\t打印出10,因为接收到的参数为(1,2,3,4)\n\tconsole.log(test(1,2,3));\n\t//\t打印出NaN,因为接收到的参数为(1,2,3,undefuned)\n\n所以,为了避免上面的情况,我们有必要在函数运行之前对函数的实参和形参个数是否相等进行判断,这里就可以用到我们的arguments对象。\n\n首先我们取得函数形参个数,有两种方法(函数名.length/arguments.callee.length),然后我们可以取得函数的实参个数,具体为arguments.length。下面用一个累加实现一下对函数实参和形参个数的验证,如果两种不相等,则抛出异常;如果验证通过,则执行正确的函数体。\n\n\tfunction test1(a,b,c,d){\n        if(arguments.callee.length !== arguments.length){\n        //\t前者也可写为test1.length,不过建议写为arguments.callee.length,具体原因下文解释\n            throw \"参数个数不正确!\";\n        }else{\n            return function(a){\n                var res = 0;\n                for(var i = 0;i < a.length;i ++){\n                    res += a[i];\n                }\n                return res;\n            }(arguments);\n\t\t//\t验证通过,执行函数体\n        }\n    }\n\n\tconsole.log(test1(1,2));\n\t//\t抛出\"参数个数不正确！\"的异常\n\tconsole.log(test1(1,2,3,4));\n\t//\t验证通过,打印出10\n\n\n在实际js中,arguments对象用的最多的可能就是递归操作了,下面用一个阶乘实现简单的递归操作。\n\n    function test3(num){\n        if(num <= 1){\n            return 1;\n        }else{\n            //  return num * test3(num -1);\n\t\t\t//\t如果我们把test3置空,在进行递归操作时,会报\"object is not a function\"的错误\n            return num * arguments.callee(num -1);\n\t\t\t//\t故推荐使用arguments.callee来调用自己\n\t\t\t//\t同理,在上文的判断参数个数是否相等时,也是如此道理\n        }\n    }\n\n    var T = test3;\n    test3 = null;\n\t//\t定义一个T变量存储test3方法,置空test3\n\n    console.log(T(5));\n\t//\t120\n\n需要注意的是,arguments对象不能脱离函数体使用。","source":"_posts/2015-03-07-arguments.md","raw":"---\nlayout: post\ntitle: javascript中arguments对象\ndate: 2015-03-07\ncategories: [javascript,arguments]\n---\n\narguments对象    \n定义：   \narguments是传进实参的集合,可理解为数组类型,但是又不是数组类型   \n常用属性arguments.callee,该属性像一个指针,指向函数自己,但是该属性在严格模式下被禁用了,意味着在严格模式下无法在匿名函数内部调用自身。\n\n在js中,允许函数的实参和形参个数不同,即使这样,在函数运行时也不会报错,看下面的例子：\n\n\tfunction test(a,b,c,d){\n        return a + b + c + d;\n    }\n\n\tconsole.log(test(1,2,3,4,5));\n\t//\t打印出10,因为接收到的参数为(1,2,3,4)\n\tconsole.log(test(1,2,3));\n\t//\t打印出NaN,因为接收到的参数为(1,2,3,undefuned)\n\n所以,为了避免上面的情况,我们有必要在函数运行之前对函数的实参和形参个数是否相等进行判断,这里就可以用到我们的arguments对象。\n\n首先我们取得函数形参个数,有两种方法(函数名.length/arguments.callee.length),然后我们可以取得函数的实参个数,具体为arguments.length。下面用一个累加实现一下对函数实参和形参个数的验证,如果两种不相等,则抛出异常;如果验证通过,则执行正确的函数体。\n\n\tfunction test1(a,b,c,d){\n        if(arguments.callee.length !== arguments.length){\n        //\t前者也可写为test1.length,不过建议写为arguments.callee.length,具体原因下文解释\n            throw \"参数个数不正确!\";\n        }else{\n            return function(a){\n                var res = 0;\n                for(var i = 0;i < a.length;i ++){\n                    res += a[i];\n                }\n                return res;\n            }(arguments);\n\t\t//\t验证通过,执行函数体\n        }\n    }\n\n\tconsole.log(test1(1,2));\n\t//\t抛出\"参数个数不正确！\"的异常\n\tconsole.log(test1(1,2,3,4));\n\t//\t验证通过,打印出10\n\n\n在实际js中,arguments对象用的最多的可能就是递归操作了,下面用一个阶乘实现简单的递归操作。\n\n    function test3(num){\n        if(num <= 1){\n            return 1;\n        }else{\n            //  return num * test3(num -1);\n\t\t\t//\t如果我们把test3置空,在进行递归操作时,会报\"object is not a function\"的错误\n            return num * arguments.callee(num -1);\n\t\t\t//\t故推荐使用arguments.callee来调用自己\n\t\t\t//\t同理,在上文的判断参数个数是否相等时,也是如此道理\n        }\n    }\n\n    var T = test3;\n    test3 = null;\n\t//\t定义一个T变量存储test3方法,置空test3\n\n    console.log(T(5));\n\t//\t120\n\n需要注意的是,arguments对象不能脱离函数体使用。","slug":"2015-03-07-arguments","published":1,"updated":"2016-11-09T13:59:21.000Z","_id":"civ7fsedx0001t95fb2a3monz","comments":1,"photos":[],"link":"","content":"<p>arguments对象<br>定义：<br>arguments是传进实参的集合,可理解为数组类型,但是又不是数组类型<br>常用属性arguments.callee,该属性像一个指针,指向函数自己,但是该属性在严格模式下被禁用了,意味着在严格模式下无法在匿名函数内部调用自身。</p>\n<p>在js中,允许函数的实参和形参个数不同,即使这样,在函数运行时也不会报错,看下面的例子：</p>\n<pre><code>function test(a,b,c,d){\n    return a + b + c + d;\n}\n\nconsole.log(test(1,2,3,4,5));\n//    打印出10,因为接收到的参数为(1,2,3,4)\nconsole.log(test(1,2,3));\n//    打印出NaN,因为接收到的参数为(1,2,3,undefuned)\n</code></pre><p>所以,为了避免上面的情况,我们有必要在函数运行之前对函数的实参和形参个数是否相等进行判断,这里就可以用到我们的arguments对象。</p>\n<p>首先我们取得函数形参个数,有两种方法(函数名.length/arguments.callee.length),然后我们可以取得函数的实参个数,具体为arguments.length。下面用一个累加实现一下对函数实参和形参个数的验证,如果两种不相等,则抛出异常;如果验证通过,则执行正确的函数体。</p>\n<pre><code>function test1(a,b,c,d){\n    if(arguments.callee.length !== arguments.length){\n    //    前者也可写为test1.length,不过建议写为arguments.callee.length,具体原因下文解释\n        throw &quot;参数个数不正确!&quot;;\n    }else{\n        return function(a){\n            var res = 0;\n            for(var i = 0;i &lt; a.length;i ++){\n                res += a[i];\n            }\n            return res;\n        }(arguments);\n    //    验证通过,执行函数体\n    }\n}\n\nconsole.log(test1(1,2));\n//    抛出&quot;参数个数不正确！&quot;的异常\nconsole.log(test1(1,2,3,4));\n//    验证通过,打印出10\n</code></pre><p>在实际js中,arguments对象用的最多的可能就是递归操作了,下面用一个阶乘实现简单的递归操作。</p>\n<pre><code>function test3(num){\n    if(num &lt;= 1){\n        return 1;\n    }else{\n        //  return num * test3(num -1);\n        //    如果我们把test3置空,在进行递归操作时,会报&quot;object is not a function&quot;的错误\n        return num * arguments.callee(num -1);\n        //    故推荐使用arguments.callee来调用自己\n        //    同理,在上文的判断参数个数是否相等时,也是如此道理\n    }\n}\n\nvar T = test3;\ntest3 = null;\n//    定义一个T变量存储test3方法,置空test3\n\nconsole.log(T(5));\n//    120\n</code></pre><p>需要注意的是,arguments对象不能脱离函数体使用。</p>\n","excerpt":"","more":"<p>arguments对象<br>定义：<br>arguments是传进实参的集合,可理解为数组类型,但是又不是数组类型<br>常用属性arguments.callee,该属性像一个指针,指向函数自己,但是该属性在严格模式下被禁用了,意味着在严格模式下无法在匿名函数内部调用自身。</p>\n<p>在js中,允许函数的实参和形参个数不同,即使这样,在函数运行时也不会报错,看下面的例子：</p>\n<pre><code>function test(a,b,c,d){\n    return a + b + c + d;\n}\n\nconsole.log(test(1,2,3,4,5));\n//    打印出10,因为接收到的参数为(1,2,3,4)\nconsole.log(test(1,2,3));\n//    打印出NaN,因为接收到的参数为(1,2,3,undefuned)\n</code></pre><p>所以,为了避免上面的情况,我们有必要在函数运行之前对函数的实参和形参个数是否相等进行判断,这里就可以用到我们的arguments对象。</p>\n<p>首先我们取得函数形参个数,有两种方法(函数名.length/arguments.callee.length),然后我们可以取得函数的实参个数,具体为arguments.length。下面用一个累加实现一下对函数实参和形参个数的验证,如果两种不相等,则抛出异常;如果验证通过,则执行正确的函数体。</p>\n<pre><code>function test1(a,b,c,d){\n    if(arguments.callee.length !== arguments.length){\n    //    前者也可写为test1.length,不过建议写为arguments.callee.length,具体原因下文解释\n        throw &quot;参数个数不正确!&quot;;\n    }else{\n        return function(a){\n            var res = 0;\n            for(var i = 0;i &lt; a.length;i ++){\n                res += a[i];\n            }\n            return res;\n        }(arguments);\n    //    验证通过,执行函数体\n    }\n}\n\nconsole.log(test1(1,2));\n//    抛出&quot;参数个数不正确！&quot;的异常\nconsole.log(test1(1,2,3,4));\n//    验证通过,打印出10\n</code></pre><p>在实际js中,arguments对象用的最多的可能就是递归操作了,下面用一个阶乘实现简单的递归操作。</p>\n<pre><code>function test3(num){\n    if(num &lt;= 1){\n        return 1;\n    }else{\n        //  return num * test3(num -1);\n        //    如果我们把test3置空,在进行递归操作时,会报&quot;object is not a function&quot;的错误\n        return num * arguments.callee(num -1);\n        //    故推荐使用arguments.callee来调用自己\n        //    同理,在上文的判断参数个数是否相等时,也是如此道理\n    }\n}\n\nvar T = test3;\ntest3 = null;\n//    定义一个T变量存储test3方法,置空test3\n\nconsole.log(T(5));\n//    120\n</code></pre><p>需要注意的是,arguments对象不能脱离函数体使用。</p>\n"},{"layout":"post","title":"javascript中的短路语法","date":"2015-02-25T16:00:00.000Z","_content":"\n在js代码中，以前写判断都是通过最简单的\"if...else...\"来判断,最近无意中改了个写法,发现也可以用,而且相对于的判断方法,省去了\"if...else...\",取而代之的是\"&&\"或者\"\\|\\|\",下面我们一起看下关于短路语法。\n\n与或非语法中，有一种经典的短路语法：\n    \n\tvar a = boolean || function(){\n\t\tdo some thing\n\t}();\n\t//\t这种情况下,只有当前面的boolean值为false时,才会执行后面的匿名方法\n\t//\t当前面的boolean值为true时,出于性能优化机制,后面的匿名方法就不会继续执行\n\n\tvar b = boolean && function(){\n\t\tdo some thing\n\t}();\n\t//\t这种情况则与上面相反,只有boolean值为true时,才会执行后的匿名方法\n\n再看一个例子：\n\n    if(typeof obj === \"undefined\") obj = {};\n\t可以改写成这样\n\tobj === undefined && (obj = {});\n\t//\t需要注意的是,当判断依据后面的为赋值语句的时候,该语句需加括号，否则会报\"无效左值\"的错\n\n\n下面看看传统判断和\t短路语法的性能对比：\n\n    var i = 1;\n    \n    console.time(\"普通的if else判断\");\n    for (var j = 0; j < 100000; j++) {\n        if (i === 1) {\n            i = 2;\n        } else {\n            i = 1;\n        }\n    }\n    console.timeEnd(\"普通的if else判断\");\n\n    i = 1;\n    console.time(\"短路语法\");\n    for (var j = 0; j < 100000; j++) {\n        i === 1 && (i = 2);\n        i !== 1 && (i = 1);\n    }\n    console.timeEnd(\"短路语法\");\n\n\t//\t我把两种方法各循环执行了100000次\n\n\n下面是运行时间对比\n\n![canvas刮刮卡](/imgs/run-times-compare.jpg)\n\n从图中可见,在一样的执行次数中,短路语法执行需要的时间更短,性能更好","source":"_posts/2015-02-24-short-circuit-gramar.md","raw":"---\nlayout: post\ntitle: javascript中的短路语法\ndate: 2015-02-26\ncategories: [javascript, 短路语法]\n---\n\n在js代码中，以前写判断都是通过最简单的\"if...else...\"来判断,最近无意中改了个写法,发现也可以用,而且相对于的判断方法,省去了\"if...else...\",取而代之的是\"&&\"或者\"\\|\\|\",下面我们一起看下关于短路语法。\n\n与或非语法中，有一种经典的短路语法：\n    \n\tvar a = boolean || function(){\n\t\tdo some thing\n\t}();\n\t//\t这种情况下,只有当前面的boolean值为false时,才会执行后面的匿名方法\n\t//\t当前面的boolean值为true时,出于性能优化机制,后面的匿名方法就不会继续执行\n\n\tvar b = boolean && function(){\n\t\tdo some thing\n\t}();\n\t//\t这种情况则与上面相反,只有boolean值为true时,才会执行后的匿名方法\n\n再看一个例子：\n\n    if(typeof obj === \"undefined\") obj = {};\n\t可以改写成这样\n\tobj === undefined && (obj = {});\n\t//\t需要注意的是,当判断依据后面的为赋值语句的时候,该语句需加括号，否则会报\"无效左值\"的错\n\n\n下面看看传统判断和\t短路语法的性能对比：\n\n    var i = 1;\n    \n    console.time(\"普通的if else判断\");\n    for (var j = 0; j < 100000; j++) {\n        if (i === 1) {\n            i = 2;\n        } else {\n            i = 1;\n        }\n    }\n    console.timeEnd(\"普通的if else判断\");\n\n    i = 1;\n    console.time(\"短路语法\");\n    for (var j = 0; j < 100000; j++) {\n        i === 1 && (i = 2);\n        i !== 1 && (i = 1);\n    }\n    console.timeEnd(\"短路语法\");\n\n\t//\t我把两种方法各循环执行了100000次\n\n\n下面是运行时间对比\n\n![canvas刮刮卡](/imgs/run-times-compare.jpg)\n\n从图中可见,在一样的执行次数中,短路语法执行需要的时间更短,性能更好","slug":"2015-02-24-short-circuit-gramar","published":1,"updated":"2016-11-09T13:59:02.000Z","_id":"civ7fsee20003t95fxkj5j186","comments":1,"photos":[],"link":"","content":"<p>在js代码中，以前写判断都是通过最简单的”if…else…”来判断,最近无意中改了个写法,发现也可以用,而且相对于的判断方法,省去了”if…else…”,取而代之的是”&amp;&amp;”或者”||“,下面我们一起看下关于短路语法。</p>\n<p>与或非语法中，有一种经典的短路语法：</p>\n<pre><code>var a = boolean || function(){\n    do some thing\n}();\n//    这种情况下,只有当前面的boolean值为false时,才会执行后面的匿名方法\n//    当前面的boolean值为true时,出于性能优化机制,后面的匿名方法就不会继续执行\n\nvar b = boolean &amp;&amp; function(){\n    do some thing\n}();\n//    这种情况则与上面相反,只有boolean值为true时,才会执行后的匿名方法\n</code></pre><p>再看一个例子：</p>\n<pre><code>if(typeof obj === &quot;undefined&quot;) obj = {};\n可以改写成这样\nobj === undefined &amp;&amp; (obj = {});\n//    需要注意的是,当判断依据后面的为赋值语句的时候,该语句需加括号，否则会报&quot;无效左值&quot;的错\n</code></pre><p>下面看看传统判断和    短路语法的性能对比：</p>\n<pre><code>var i = 1;\n\nconsole.time(&quot;普通的if else判断&quot;);\nfor (var j = 0; j &lt; 100000; j++) {\n    if (i === 1) {\n        i = 2;\n    } else {\n        i = 1;\n    }\n}\nconsole.timeEnd(&quot;普通的if else判断&quot;);\n\ni = 1;\nconsole.time(&quot;短路语法&quot;);\nfor (var j = 0; j &lt; 100000; j++) {\n    i === 1 &amp;&amp; (i = 2);\n    i !== 1 &amp;&amp; (i = 1);\n}\nconsole.timeEnd(&quot;短路语法&quot;);\n\n//    我把两种方法各循环执行了100000次\n</code></pre><p>下面是运行时间对比</p>\n<p><img src=\"/imgs/run-times-compare.jpg\" alt=\"canvas刮刮卡\"></p>\n<p>从图中可见,在一样的执行次数中,短路语法执行需要的时间更短,性能更好</p>\n","excerpt":"","more":"<p>在js代码中，以前写判断都是通过最简单的”if…else…”来判断,最近无意中改了个写法,发现也可以用,而且相对于的判断方法,省去了”if…else…”,取而代之的是”&amp;&amp;”或者”||“,下面我们一起看下关于短路语法。</p>\n<p>与或非语法中，有一种经典的短路语法：</p>\n<pre><code>var a = boolean || function(){\n    do some thing\n}();\n//    这种情况下,只有当前面的boolean值为false时,才会执行后面的匿名方法\n//    当前面的boolean值为true时,出于性能优化机制,后面的匿名方法就不会继续执行\n\nvar b = boolean &amp;&amp; function(){\n    do some thing\n}();\n//    这种情况则与上面相反,只有boolean值为true时,才会执行后的匿名方法\n</code></pre><p>再看一个例子：</p>\n<pre><code>if(typeof obj === &quot;undefined&quot;) obj = {};\n可以改写成这样\nobj === undefined &amp;&amp; (obj = {});\n//    需要注意的是,当判断依据后面的为赋值语句的时候,该语句需加括号，否则会报&quot;无效左值&quot;的错\n</code></pre><p>下面看看传统判断和    短路语法的性能对比：</p>\n<pre><code>var i = 1;\n\nconsole.time(&quot;普通的if else判断&quot;);\nfor (var j = 0; j &lt; 100000; j++) {\n    if (i === 1) {\n        i = 2;\n    } else {\n        i = 1;\n    }\n}\nconsole.timeEnd(&quot;普通的if else判断&quot;);\n\ni = 1;\nconsole.time(&quot;短路语法&quot;);\nfor (var j = 0; j &lt; 100000; j++) {\n    i === 1 &amp;&amp; (i = 2);\n    i !== 1 &amp;&amp; (i = 1);\n}\nconsole.timeEnd(&quot;短路语法&quot;);\n\n//    我把两种方法各循环执行了100000次\n</code></pre><p>下面是运行时间对比</p>\n<p><img src=\"/imgs/run-times-compare.jpg\" alt=\"canvas刮刮卡\"></p>\n<p>从图中可见,在一样的执行次数中,短路语法执行需要的时间更短,性能更好</p>\n"},{"layout":"post","title":"javascript创建类的常用模式","date":"2015-03-09T16:00:00.000Z","_content":"\njavaScript创建类的常用模式:\n严格意义上,在ECMAScript6出来之前,js中是没有类的概念的,但是聪明的人类想到了用方法和原型类模拟类的一些特性,比如一个对象经过new关键字实例化以后就具有了某些属性,方法。\n\n下面我们就看下常用的创建类的一些常用模式:\n   \n1.工厂模式\n\n    function Person(name,sex,age){\n        var obj = {\n            \"name\":name,\n            \"sex\":sex,\n            \"age\":age,\n            \"say\":function(){\n                console.log(\"hello world!\");\n            }\n        };\n        return obj;\n    }\n\t//\t工厂模式就是在构造方法里面定义一个对象,给这个对象赋予相应的属性、方法,最后返回这个对象\n\n2.构造方法模式\n\n    function CrearePerson(name,sex,age){\n        this.name = name;\n        this.age = sex;\n        this.age = age;\n        this.say = function(){\n            console.log(\"你好！我是:\" + this.name);\n        };\n    }\n\t//\t构造方法,就是给当前对象指定一些属性,方法\n\n3.构造方法 + 原型模式\n\n    function Person(name){\n\t\tthis.name = name;\n\t}\n    Person.prototype = {\n          \"constructor\":Person,\n        //  指定原型对象的构造器\n        \"name\":\"小宋\",\n        \"age\":20,\n        \"job\":\"程序员\",\n        \"say\":function(){\n            console.log(\"我是原型的函数\");\n        }\n    };\n\n在前面2种创建类的模式中，我们每次实例化一个对象都会重新声明出一些东西,对象个数少可能没什么关系,但是当对象个数达到一定数量时,就会对性能造成一定的影响。所以,就出来了第三种\"构造方法 + 原型模式\",构造方法的作用是为实例化出来的对象定义一些私有属性,原型的作用就是绑定一些公共属性方法,让所有实例化出来的对象都可以共,只有在第一次实例化的时候进行初始化,往后就不会再初始化了。这样,当在写大型Web程序时,性能会相对较好。\n\n    function Person1(name,sex,age){\n        var obj = {\n            \"name\":name,\n            \"sex\":sex,\n            \"age\":age,\n            \"say\":function(){\n                console.log(\"hello world!\");\n            }\n        };\n        return obj;\n    }\n    //  工厂模式\n\n    function Person2(name,sex,age){\n        this.name = name;\n        this.age = sex;\n        this.age = age;\n        this.say = function(){\n            console.log(\"你好！我是:\" + this.name);\n        };\n    }\n    //  构造方法模式\n\n    function Person3(name){\n        this.name = name;\n    }\n    Person3.prototype = {\n        \"constructor\":Person3,\n        //  指定原型对象的构造器\n        \"name\":\"小宋\",\n        \"age\":20,\n        \"job\":\"程序员\",\n        \"say\":function(){\n            console.log(\"我是原型的函数\");\n        }\n    };\n    //  构造方法 + 原型模式\n\n    console.time(\"工厂模式\");\n    for(var i = 0; i < 10000;i ++){\n        var o = new Person1(\"小宋\",\"男\",22);\n    }\n    console.timeEnd(\"工厂模式\");\n\n    console.time(\"构造方法模式\");\n    for(var i = 0; i < 10000;i ++){\n        var o = new Person2(\"小宋\",\"男\",22);\n    }\n    console.timeEnd(\"构造方法模式\");\n\n    console.time(\"构造方法 + 原型模式\");\n    for(var i = 0; i < 10000;i ++){\n        var o = new Person3(\"小宋\");\n    }\n    console.timeEnd(\"构造方法 + 原型模式\");\n\t//\t三者性能在一定的循环次数下性能对比\n\n我把上面的代码段跑了一遍,在一样的循环次数下,经过多次对比,发现\"构造方法 + 原型模式\"的性能是最优的,具体对比请看下图。\n\n![性能对比](/imgs/class-mode-conpare.png)","source":"_posts/2015-03-10-js-object-create-class-mode.md","raw":"---\nlayout: post\ntitle: javascript创建类的常用模式\ndate: 2015-03-10\ncategories: [javascript, 类]\n---\n\njavaScript创建类的常用模式:\n严格意义上,在ECMAScript6出来之前,js中是没有类的概念的,但是聪明的人类想到了用方法和原型类模拟类的一些特性,比如一个对象经过new关键字实例化以后就具有了某些属性,方法。\n\n下面我们就看下常用的创建类的一些常用模式:\n   \n1.工厂模式\n\n    function Person(name,sex,age){\n        var obj = {\n            \"name\":name,\n            \"sex\":sex,\n            \"age\":age,\n            \"say\":function(){\n                console.log(\"hello world!\");\n            }\n        };\n        return obj;\n    }\n\t//\t工厂模式就是在构造方法里面定义一个对象,给这个对象赋予相应的属性、方法,最后返回这个对象\n\n2.构造方法模式\n\n    function CrearePerson(name,sex,age){\n        this.name = name;\n        this.age = sex;\n        this.age = age;\n        this.say = function(){\n            console.log(\"你好！我是:\" + this.name);\n        };\n    }\n\t//\t构造方法,就是给当前对象指定一些属性,方法\n\n3.构造方法 + 原型模式\n\n    function Person(name){\n\t\tthis.name = name;\n\t}\n    Person.prototype = {\n          \"constructor\":Person,\n        //  指定原型对象的构造器\n        \"name\":\"小宋\",\n        \"age\":20,\n        \"job\":\"程序员\",\n        \"say\":function(){\n            console.log(\"我是原型的函数\");\n        }\n    };\n\n在前面2种创建类的模式中，我们每次实例化一个对象都会重新声明出一些东西,对象个数少可能没什么关系,但是当对象个数达到一定数量时,就会对性能造成一定的影响。所以,就出来了第三种\"构造方法 + 原型模式\",构造方法的作用是为实例化出来的对象定义一些私有属性,原型的作用就是绑定一些公共属性方法,让所有实例化出来的对象都可以共,只有在第一次实例化的时候进行初始化,往后就不会再初始化了。这样,当在写大型Web程序时,性能会相对较好。\n\n    function Person1(name,sex,age){\n        var obj = {\n            \"name\":name,\n            \"sex\":sex,\n            \"age\":age,\n            \"say\":function(){\n                console.log(\"hello world!\");\n            }\n        };\n        return obj;\n    }\n    //  工厂模式\n\n    function Person2(name,sex,age){\n        this.name = name;\n        this.age = sex;\n        this.age = age;\n        this.say = function(){\n            console.log(\"你好！我是:\" + this.name);\n        };\n    }\n    //  构造方法模式\n\n    function Person3(name){\n        this.name = name;\n    }\n    Person3.prototype = {\n        \"constructor\":Person3,\n        //  指定原型对象的构造器\n        \"name\":\"小宋\",\n        \"age\":20,\n        \"job\":\"程序员\",\n        \"say\":function(){\n            console.log(\"我是原型的函数\");\n        }\n    };\n    //  构造方法 + 原型模式\n\n    console.time(\"工厂模式\");\n    for(var i = 0; i < 10000;i ++){\n        var o = new Person1(\"小宋\",\"男\",22);\n    }\n    console.timeEnd(\"工厂模式\");\n\n    console.time(\"构造方法模式\");\n    for(var i = 0; i < 10000;i ++){\n        var o = new Person2(\"小宋\",\"男\",22);\n    }\n    console.timeEnd(\"构造方法模式\");\n\n    console.time(\"构造方法 + 原型模式\");\n    for(var i = 0; i < 10000;i ++){\n        var o = new Person3(\"小宋\");\n    }\n    console.timeEnd(\"构造方法 + 原型模式\");\n\t//\t三者性能在一定的循环次数下性能对比\n\n我把上面的代码段跑了一遍,在一样的循环次数下,经过多次对比,发现\"构造方法 + 原型模式\"的性能是最优的,具体对比请看下图。\n\n![性能对比](/imgs/class-mode-conpare.png)","slug":"2015-03-10-js-object-create-class-mode","published":1,"updated":"2016-11-09T13:59:30.000Z","_id":"civ7fsee40004t95fepka52b5","comments":1,"photos":[],"link":"","content":"<p>javaScript创建类的常用模式:<br>严格意义上,在ECMAScript6出来之前,js中是没有类的概念的,但是聪明的人类想到了用方法和原型类模拟类的一些特性,比如一个对象经过new关键字实例化以后就具有了某些属性,方法。</p>\n<p>下面我们就看下常用的创建类的一些常用模式:</p>\n<p>1.工厂模式</p>\n<pre><code>function Person(name,sex,age){\n    var obj = {\n        &quot;name&quot;:name,\n        &quot;sex&quot;:sex,\n        &quot;age&quot;:age,\n        &quot;say&quot;:function(){\n            console.log(&quot;hello world!&quot;);\n        }\n    };\n    return obj;\n}\n//    工厂模式就是在构造方法里面定义一个对象,给这个对象赋予相应的属性、方法,最后返回这个对象\n</code></pre><p>2.构造方法模式</p>\n<pre><code>function CrearePerson(name,sex,age){\n    this.name = name;\n    this.age = sex;\n    this.age = age;\n    this.say = function(){\n        console.log(&quot;你好！我是:&quot; + this.name);\n    };\n}\n//    构造方法,就是给当前对象指定一些属性,方法\n</code></pre><p>3.构造方法 + 原型模式</p>\n<pre><code>function Person(name){\n    this.name = name;\n}\nPerson.prototype = {\n      &quot;constructor&quot;:Person,\n    //  指定原型对象的构造器\n    &quot;name&quot;:&quot;小宋&quot;,\n    &quot;age&quot;:20,\n    &quot;job&quot;:&quot;程序员&quot;,\n    &quot;say&quot;:function(){\n        console.log(&quot;我是原型的函数&quot;);\n    }\n};\n</code></pre><p>在前面2种创建类的模式中，我们每次实例化一个对象都会重新声明出一些东西,对象个数少可能没什么关系,但是当对象个数达到一定数量时,就会对性能造成一定的影响。所以,就出来了第三种”构造方法 + 原型模式”,构造方法的作用是为实例化出来的对象定义一些私有属性,原型的作用就是绑定一些公共属性方法,让所有实例化出来的对象都可以共,只有在第一次实例化的时候进行初始化,往后就不会再初始化了。这样,当在写大型Web程序时,性能会相对较好。</p>\n<pre><code>function Person1(name,sex,age){\n    var obj = {\n        &quot;name&quot;:name,\n        &quot;sex&quot;:sex,\n        &quot;age&quot;:age,\n        &quot;say&quot;:function(){\n            console.log(&quot;hello world!&quot;);\n        }\n    };\n    return obj;\n}\n//  工厂模式\n\nfunction Person2(name,sex,age){\n    this.name = name;\n    this.age = sex;\n    this.age = age;\n    this.say = function(){\n        console.log(&quot;你好！我是:&quot; + this.name);\n    };\n}\n//  构造方法模式\n\nfunction Person3(name){\n    this.name = name;\n}\nPerson3.prototype = {\n    &quot;constructor&quot;:Person3,\n    //  指定原型对象的构造器\n    &quot;name&quot;:&quot;小宋&quot;,\n    &quot;age&quot;:20,\n    &quot;job&quot;:&quot;程序员&quot;,\n    &quot;say&quot;:function(){\n        console.log(&quot;我是原型的函数&quot;);\n    }\n};\n//  构造方法 + 原型模式\n\nconsole.time(&quot;工厂模式&quot;);\nfor(var i = 0; i &lt; 10000;i ++){\n    var o = new Person1(&quot;小宋&quot;,&quot;男&quot;,22);\n}\nconsole.timeEnd(&quot;工厂模式&quot;);\n\nconsole.time(&quot;构造方法模式&quot;);\nfor(var i = 0; i &lt; 10000;i ++){\n    var o = new Person2(&quot;小宋&quot;,&quot;男&quot;,22);\n}\nconsole.timeEnd(&quot;构造方法模式&quot;);\n\nconsole.time(&quot;构造方法 + 原型模式&quot;);\nfor(var i = 0; i &lt; 10000;i ++){\n    var o = new Person3(&quot;小宋&quot;);\n}\nconsole.timeEnd(&quot;构造方法 + 原型模式&quot;);\n//    三者性能在一定的循环次数下性能对比\n</code></pre><p>我把上面的代码段跑了一遍,在一样的循环次数下,经过多次对比,发现”构造方法 + 原型模式”的性能是最优的,具体对比请看下图。</p>\n<p><img src=\"/imgs/class-mode-conpare.png\" alt=\"性能对比\"></p>\n","excerpt":"","more":"<p>javaScript创建类的常用模式:<br>严格意义上,在ECMAScript6出来之前,js中是没有类的概念的,但是聪明的人类想到了用方法和原型类模拟类的一些特性,比如一个对象经过new关键字实例化以后就具有了某些属性,方法。</p>\n<p>下面我们就看下常用的创建类的一些常用模式:</p>\n<p>1.工厂模式</p>\n<pre><code>function Person(name,sex,age){\n    var obj = {\n        &quot;name&quot;:name,\n        &quot;sex&quot;:sex,\n        &quot;age&quot;:age,\n        &quot;say&quot;:function(){\n            console.log(&quot;hello world!&quot;);\n        }\n    };\n    return obj;\n}\n//    工厂模式就是在构造方法里面定义一个对象,给这个对象赋予相应的属性、方法,最后返回这个对象\n</code></pre><p>2.构造方法模式</p>\n<pre><code>function CrearePerson(name,sex,age){\n    this.name = name;\n    this.age = sex;\n    this.age = age;\n    this.say = function(){\n        console.log(&quot;你好！我是:&quot; + this.name);\n    };\n}\n//    构造方法,就是给当前对象指定一些属性,方法\n</code></pre><p>3.构造方法 + 原型模式</p>\n<pre><code>function Person(name){\n    this.name = name;\n}\nPerson.prototype = {\n      &quot;constructor&quot;:Person,\n    //  指定原型对象的构造器\n    &quot;name&quot;:&quot;小宋&quot;,\n    &quot;age&quot;:20,\n    &quot;job&quot;:&quot;程序员&quot;,\n    &quot;say&quot;:function(){\n        console.log(&quot;我是原型的函数&quot;);\n    }\n};\n</code></pre><p>在前面2种创建类的模式中，我们每次实例化一个对象都会重新声明出一些东西,对象个数少可能没什么关系,但是当对象个数达到一定数量时,就会对性能造成一定的影响。所以,就出来了第三种”构造方法 + 原型模式”,构造方法的作用是为实例化出来的对象定义一些私有属性,原型的作用就是绑定一些公共属性方法,让所有实例化出来的对象都可以共,只有在第一次实例化的时候进行初始化,往后就不会再初始化了。这样,当在写大型Web程序时,性能会相对较好。</p>\n<pre><code>function Person1(name,sex,age){\n    var obj = {\n        &quot;name&quot;:name,\n        &quot;sex&quot;:sex,\n        &quot;age&quot;:age,\n        &quot;say&quot;:function(){\n            console.log(&quot;hello world!&quot;);\n        }\n    };\n    return obj;\n}\n//  工厂模式\n\nfunction Person2(name,sex,age){\n    this.name = name;\n    this.age = sex;\n    this.age = age;\n    this.say = function(){\n        console.log(&quot;你好！我是:&quot; + this.name);\n    };\n}\n//  构造方法模式\n\nfunction Person3(name){\n    this.name = name;\n}\nPerson3.prototype = {\n    &quot;constructor&quot;:Person3,\n    //  指定原型对象的构造器\n    &quot;name&quot;:&quot;小宋&quot;,\n    &quot;age&quot;:20,\n    &quot;job&quot;:&quot;程序员&quot;,\n    &quot;say&quot;:function(){\n        console.log(&quot;我是原型的函数&quot;);\n    }\n};\n//  构造方法 + 原型模式\n\nconsole.time(&quot;工厂模式&quot;);\nfor(var i = 0; i &lt; 10000;i ++){\n    var o = new Person1(&quot;小宋&quot;,&quot;男&quot;,22);\n}\nconsole.timeEnd(&quot;工厂模式&quot;);\n\nconsole.time(&quot;构造方法模式&quot;);\nfor(var i = 0; i &lt; 10000;i ++){\n    var o = new Person2(&quot;小宋&quot;,&quot;男&quot;,22);\n}\nconsole.timeEnd(&quot;构造方法模式&quot;);\n\nconsole.time(&quot;构造方法 + 原型模式&quot;);\nfor(var i = 0; i &lt; 10000;i ++){\n    var o = new Person3(&quot;小宋&quot;);\n}\nconsole.timeEnd(&quot;构造方法 + 原型模式&quot;);\n//    三者性能在一定的循环次数下性能对比\n</code></pre><p>我把上面的代码段跑了一遍,在一样的循环次数下,经过多次对比,发现”构造方法 + 原型模式”的性能是最优的,具体对比请看下图。</p>\n<p><img src=\"/imgs/class-mode-conpare.png\" alt=\"性能对比\"></p>\n"},{"layout":"post","title":"javascript原型","date":"2015-05-22T16:00:00.000Z","_content":"\njavaScript原型:\n\n定义：每一个方法被创建时都有一个prototype属性,改属性是一个指针,总是指向一个对象。该对象可以将特定的属性和方法包含在内,起到一个被所有实例所共享的作用。\n\n\t    function Person(){\n\t\n\t    }\n\t\n\t    var obj  = Person.prototype;\n\t\t    obj.name = \"小宋\";\n\t\t    obj.age = 20;\n\t\t    obj.sayName = function(){\n\t\t        console.log(this.name);\n\t\t    };\n\t    //\t定义一个变量来引用原型,修改这个变量的属性达到修改原型的目的\n\n\n原型对象、构造方法、实例对象三者的关系\n\n1、构造方法.prototype = 原型对象\n\n2、原型对象的constructor = 构造方法\n\n3、实例对象.prototype = 原型对象\n\n原型中的常用方法\n\n1、isPrototypeOf\t  (判断一个对象是不是另一个对象的原型)\n示例:\n\t\n    function Person(){}\n    var obj  = Person.prototype;\n        obj.name = \"小宋\";\n        obj.age = 20;\n        obj.sayName = function(){\n            console.log(this.name);\n        };\n    var p = new Person();\n    console.log(obj.isPrototypeOf(p1));\t\t//\ttrue\n\n2、Object.getPrototypeOf\t\t(根据实例对象获取原型对象)\n示例:\n\t\n    function Person(){}\n    Person.prototype.name = \"张三\";\n    Person.prototype.age = 20;\n    Person.prototype.sayName = function(){\n        console.log(\"原型方法!\");\n    };\n    var p1 = new Person();\n    console.log(Object.getPrototypeOf(p1));\t//\tPerson的原型对象\n\n3、hasOwnProperty\t(判断一个对象的属性是属于原型属性或者实例属性)\n示例:\n\t\n    function Person(){}\n        Person.prototype.name = \"张三\";\n        Person.prototype.age = 20;\n        Person.prototype.sayName = function(){\n            console.log(\"原型方法!\");\n        };\n    var p1 = new Person();\n    p1.name = \"小宋\";\n    console.log(p1.hasOwnProperty(\"name\"));\t//\ttrue\n\n4、in操作符\t(判断属性是否存在实例对象或原型对象中,类似于hasOwnProperty)\n示例:\n\t\n    function Person(){}\n        Person.prototype.name = \"张三\";\n        Person.prototype.age = 20;\n        Person.prototype.sayName = function(){\n            console.log(\"原型方法!\");\n        };\n    var p1 = new Person();\n    p1.name = \"小宋\";\n    console.log(\"name\" in p1);\t//\ttrue\n\n5、Object.keys()\t(取得当前对象下中所有键值,返回一个数组)\n示例:\n\n    function Person(){}\n        Person.prototype.name = \"张三\";\n        Person.prototype.age = 20;\n        Person.prototype.sayName = function(){\n            console.log(\"原型方法!\");\n        };\n    var p7 = new Person();\n    console.log(Object.keys(p7));\t//\t[]\n    p7.name = \"z3\";\n    p7.age = 20;\n    console.log(Object.keys(p7));\t//\t[\"name\", \"age\"]\n    console.log(Object.keys(Person.prototype));\t//\t[\"name\", \"age\", \"sayName\"]\n\n6、Object.getOwnPropertyNames()\t(枚举出该对象下所有属性,不管该属性是否可以被枚举,返回数组)\n在ECMAScript中,对象原型下的constructor属性是不能被枚举的(for in),但是用Object.getOwnPropertyNames()方法可以把对象原型下所有属性都枚举出来,以数组的形式返回\n示例:\n\n    function Person(){}\n        Person.prototype.name = \"张三\";\n        Person.prototype.age = 20;\n        Person.prototype.sayName = function(){\n            console.log(\"原型方法!\");\n        };\n    console.log(Object.getOwnPropertyNames(Person.prototype)); \t//\t[\"constructor\", \"name\", \"age\", \"sayName\"]\n\n在平常的javaScript面向对象中,如果我们类的原型中没指定构造器,那么该构造器会默认为Object;\n在ECMAScript5中,提供了给原型对象重新设置构造器的方法:Object.defineProperty();\nECMAScript5兼容性: IE8+,FireFox4+\n下面我们就一起来看怎么调用该方法:\n\n    function Person(){}\n    Person.prototype = {\n        \"name\":\"小宋\",\n        \"age\":20,\n        \"job\":\"程序员\",\n        \"say\":function(){\n            console.log(\"我是原型的函数\");\n        }\n    };\n    Object.defineProperty(Person.prototype,\"constructor\",{\n        \"enumerable\":false,\n\t   //\t关闭枚举访问,默认为关闭状态(for in的时候不能读到该属性)\n        \"value\":Person\n\t  //\t指定原型构造器\n    });\n\n    var p1 = new Person();\n\n    var str = \"\";\n        for(var attr in p1){\n            str += attr + \"->\" + p1[attr] + \"\\n\";\n        }\n    console.log(str);\n    /**\n      *    name->小宋\n      *    age->20\n      *    job->程序员\n      *    say->function (){\n      *                console.log(\"我是原型的函数\");\n      *    }\n    **/\n\n或者我们可以直接通过设置类原型属性的方法来指定构造器\n\n    function Person(){}\n    Person.prototype = {\n        \"constructor\":Person,\n        //  指定原型构造器,这边指定的是可以被枚举的\n        \"name\":\"小宋\",\n        \"age\":20,\n        \"job\":\"程序员\",\n        \"say\":function(){\n            console.log(\"我是原型的函数\");\n        }\n    };\n\n    var p1 = new Person();\n\n    var str = \"\";\n    for(var attr in p1){\n        str += attr + \"->\" + p1[attr] + \"\\n\";\n    }\n    console.log(str);\n    /**\n      *    constructor->function Person(){\n      *\n      *    }\n      *    name->小宋\n      *    age->20\n      *    job->程序员\n      *    say->function (){\n      *                console.log(\"我是原型的函数\");\n      *    }\n    **/","source":"_posts/2015-05-23-js-object-prototype.md","raw":"---\nlayout: post\ntitle: javascript原型\ndate: 2015-05-23\ncategories: [javascript, 原型]\n---\n\njavaScript原型:\n\n定义：每一个方法被创建时都有一个prototype属性,改属性是一个指针,总是指向一个对象。该对象可以将特定的属性和方法包含在内,起到一个被所有实例所共享的作用。\n\n\t    function Person(){\n\t\n\t    }\n\t\n\t    var obj  = Person.prototype;\n\t\t    obj.name = \"小宋\";\n\t\t    obj.age = 20;\n\t\t    obj.sayName = function(){\n\t\t        console.log(this.name);\n\t\t    };\n\t    //\t定义一个变量来引用原型,修改这个变量的属性达到修改原型的目的\n\n\n原型对象、构造方法、实例对象三者的关系\n\n1、构造方法.prototype = 原型对象\n\n2、原型对象的constructor = 构造方法\n\n3、实例对象.prototype = 原型对象\n\n原型中的常用方法\n\n1、isPrototypeOf\t  (判断一个对象是不是另一个对象的原型)\n示例:\n\t\n    function Person(){}\n    var obj  = Person.prototype;\n        obj.name = \"小宋\";\n        obj.age = 20;\n        obj.sayName = function(){\n            console.log(this.name);\n        };\n    var p = new Person();\n    console.log(obj.isPrototypeOf(p1));\t\t//\ttrue\n\n2、Object.getPrototypeOf\t\t(根据实例对象获取原型对象)\n示例:\n\t\n    function Person(){}\n    Person.prototype.name = \"张三\";\n    Person.prototype.age = 20;\n    Person.prototype.sayName = function(){\n        console.log(\"原型方法!\");\n    };\n    var p1 = new Person();\n    console.log(Object.getPrototypeOf(p1));\t//\tPerson的原型对象\n\n3、hasOwnProperty\t(判断一个对象的属性是属于原型属性或者实例属性)\n示例:\n\t\n    function Person(){}\n        Person.prototype.name = \"张三\";\n        Person.prototype.age = 20;\n        Person.prototype.sayName = function(){\n            console.log(\"原型方法!\");\n        };\n    var p1 = new Person();\n    p1.name = \"小宋\";\n    console.log(p1.hasOwnProperty(\"name\"));\t//\ttrue\n\n4、in操作符\t(判断属性是否存在实例对象或原型对象中,类似于hasOwnProperty)\n示例:\n\t\n    function Person(){}\n        Person.prototype.name = \"张三\";\n        Person.prototype.age = 20;\n        Person.prototype.sayName = function(){\n            console.log(\"原型方法!\");\n        };\n    var p1 = new Person();\n    p1.name = \"小宋\";\n    console.log(\"name\" in p1);\t//\ttrue\n\n5、Object.keys()\t(取得当前对象下中所有键值,返回一个数组)\n示例:\n\n    function Person(){}\n        Person.prototype.name = \"张三\";\n        Person.prototype.age = 20;\n        Person.prototype.sayName = function(){\n            console.log(\"原型方法!\");\n        };\n    var p7 = new Person();\n    console.log(Object.keys(p7));\t//\t[]\n    p7.name = \"z3\";\n    p7.age = 20;\n    console.log(Object.keys(p7));\t//\t[\"name\", \"age\"]\n    console.log(Object.keys(Person.prototype));\t//\t[\"name\", \"age\", \"sayName\"]\n\n6、Object.getOwnPropertyNames()\t(枚举出该对象下所有属性,不管该属性是否可以被枚举,返回数组)\n在ECMAScript中,对象原型下的constructor属性是不能被枚举的(for in),但是用Object.getOwnPropertyNames()方法可以把对象原型下所有属性都枚举出来,以数组的形式返回\n示例:\n\n    function Person(){}\n        Person.prototype.name = \"张三\";\n        Person.prototype.age = 20;\n        Person.prototype.sayName = function(){\n            console.log(\"原型方法!\");\n        };\n    console.log(Object.getOwnPropertyNames(Person.prototype)); \t//\t[\"constructor\", \"name\", \"age\", \"sayName\"]\n\n在平常的javaScript面向对象中,如果我们类的原型中没指定构造器,那么该构造器会默认为Object;\n在ECMAScript5中,提供了给原型对象重新设置构造器的方法:Object.defineProperty();\nECMAScript5兼容性: IE8+,FireFox4+\n下面我们就一起来看怎么调用该方法:\n\n    function Person(){}\n    Person.prototype = {\n        \"name\":\"小宋\",\n        \"age\":20,\n        \"job\":\"程序员\",\n        \"say\":function(){\n            console.log(\"我是原型的函数\");\n        }\n    };\n    Object.defineProperty(Person.prototype,\"constructor\",{\n        \"enumerable\":false,\n\t   //\t关闭枚举访问,默认为关闭状态(for in的时候不能读到该属性)\n        \"value\":Person\n\t  //\t指定原型构造器\n    });\n\n    var p1 = new Person();\n\n    var str = \"\";\n        for(var attr in p1){\n            str += attr + \"->\" + p1[attr] + \"\\n\";\n        }\n    console.log(str);\n    /**\n      *    name->小宋\n      *    age->20\n      *    job->程序员\n      *    say->function (){\n      *                console.log(\"我是原型的函数\");\n      *    }\n    **/\n\n或者我们可以直接通过设置类原型属性的方法来指定构造器\n\n    function Person(){}\n    Person.prototype = {\n        \"constructor\":Person,\n        //  指定原型构造器,这边指定的是可以被枚举的\n        \"name\":\"小宋\",\n        \"age\":20,\n        \"job\":\"程序员\",\n        \"say\":function(){\n            console.log(\"我是原型的函数\");\n        }\n    };\n\n    var p1 = new Person();\n\n    var str = \"\";\n    for(var attr in p1){\n        str += attr + \"->\" + p1[attr] + \"\\n\";\n    }\n    console.log(str);\n    /**\n      *    constructor->function Person(){\n      *\n      *    }\n      *    name->小宋\n      *    age->20\n      *    job->程序员\n      *    say->function (){\n      *                console.log(\"我是原型的函数\");\n      *    }\n    **/","slug":"2015-05-23-js-object-prototype","published":1,"updated":"2016-11-09T13:59:41.000Z","_id":"civ7fsee70005t95fhb73b0t7","comments":1,"photos":[],"link":"","content":"<p>javaScript原型:</p>\n<p>定义：每一个方法被创建时都有一个prototype属性,改属性是一个指针,总是指向一个对象。该对象可以将特定的属性和方法包含在内,起到一个被所有实例所共享的作用。</p>\n<pre><code>function Person(){\n\n}\n\nvar obj  = Person.prototype;\n    obj.name = &quot;小宋&quot;;\n    obj.age = 20;\n    obj.sayName = function(){\n        console.log(this.name);\n    };\n//    定义一个变量来引用原型,修改这个变量的属性达到修改原型的目的\n</code></pre><p>原型对象、构造方法、实例对象三者的关系</p>\n<p>1、构造方法.prototype = 原型对象</p>\n<p>2、原型对象的constructor = 构造方法</p>\n<p>3、实例对象.prototype = 原型对象</p>\n<p>原型中的常用方法</p>\n<p>1、isPrototypeOf      (判断一个对象是不是另一个对象的原型)<br>示例:</p>\n<pre><code>function Person(){}\nvar obj  = Person.prototype;\n    obj.name = &quot;小宋&quot;;\n    obj.age = 20;\n    obj.sayName = function(){\n        console.log(this.name);\n    };\nvar p = new Person();\nconsole.log(obj.isPrototypeOf(p1));        //    true\n</code></pre><p>2、Object.getPrototypeOf        (根据实例对象获取原型对象)<br>示例:</p>\n<pre><code>function Person(){}\nPerson.prototype.name = &quot;张三&quot;;\nPerson.prototype.age = 20;\nPerson.prototype.sayName = function(){\n    console.log(&quot;原型方法!&quot;);\n};\nvar p1 = new Person();\nconsole.log(Object.getPrototypeOf(p1));    //    Person的原型对象\n</code></pre><p>3、hasOwnProperty    (判断一个对象的属性是属于原型属性或者实例属性)<br>示例:</p>\n<pre><code>function Person(){}\n    Person.prototype.name = &quot;张三&quot;;\n    Person.prototype.age = 20;\n    Person.prototype.sayName = function(){\n        console.log(&quot;原型方法!&quot;);\n    };\nvar p1 = new Person();\np1.name = &quot;小宋&quot;;\nconsole.log(p1.hasOwnProperty(&quot;name&quot;));    //    true\n</code></pre><p>4、in操作符    (判断属性是否存在实例对象或原型对象中,类似于hasOwnProperty)<br>示例:</p>\n<pre><code>function Person(){}\n    Person.prototype.name = &quot;张三&quot;;\n    Person.prototype.age = 20;\n    Person.prototype.sayName = function(){\n        console.log(&quot;原型方法!&quot;);\n    };\nvar p1 = new Person();\np1.name = &quot;小宋&quot;;\nconsole.log(&quot;name&quot; in p1);    //    true\n</code></pre><p>5、Object.keys()    (取得当前对象下中所有键值,返回一个数组)<br>示例:</p>\n<pre><code>function Person(){}\n    Person.prototype.name = &quot;张三&quot;;\n    Person.prototype.age = 20;\n    Person.prototype.sayName = function(){\n        console.log(&quot;原型方法!&quot;);\n    };\nvar p7 = new Person();\nconsole.log(Object.keys(p7));    //    []\np7.name = &quot;z3&quot;;\np7.age = 20;\nconsole.log(Object.keys(p7));    //    [&quot;name&quot;, &quot;age&quot;]\nconsole.log(Object.keys(Person.prototype));    //    [&quot;name&quot;, &quot;age&quot;, &quot;sayName&quot;]\n</code></pre><p>6、Object.getOwnPropertyNames()    (枚举出该对象下所有属性,不管该属性是否可以被枚举,返回数组)<br>在ECMAScript中,对象原型下的constructor属性是不能被枚举的(for in),但是用Object.getOwnPropertyNames()方法可以把对象原型下所有属性都枚举出来,以数组的形式返回<br>示例:</p>\n<pre><code>function Person(){}\n    Person.prototype.name = &quot;张三&quot;;\n    Person.prototype.age = 20;\n    Person.prototype.sayName = function(){\n        console.log(&quot;原型方法!&quot;);\n    };\nconsole.log(Object.getOwnPropertyNames(Person.prototype));     //    [&quot;constructor&quot;, &quot;name&quot;, &quot;age&quot;, &quot;sayName&quot;]\n</code></pre><p>在平常的javaScript面向对象中,如果我们类的原型中没指定构造器,那么该构造器会默认为Object;<br>在ECMAScript5中,提供了给原型对象重新设置构造器的方法:Object.defineProperty();<br>ECMAScript5兼容性: IE8+,FireFox4+<br>下面我们就一起来看怎么调用该方法:</p>\n<pre><code>function Person(){}\nPerson.prototype = {\n    &quot;name&quot;:&quot;小宋&quot;,\n    &quot;age&quot;:20,\n    &quot;job&quot;:&quot;程序员&quot;,\n    &quot;say&quot;:function(){\n        console.log(&quot;我是原型的函数&quot;);\n    }\n};\nObject.defineProperty(Person.prototype,&quot;constructor&quot;,{\n    &quot;enumerable&quot;:false,\n   //    关闭枚举访问,默认为关闭状态(for in的时候不能读到该属性)\n    &quot;value&quot;:Person\n  //    指定原型构造器\n});\n\nvar p1 = new Person();\n\nvar str = &quot;&quot;;\n    for(var attr in p1){\n        str += attr + &quot;-&gt;&quot; + p1[attr] + &quot;\\n&quot;;\n    }\nconsole.log(str);\n/**\n  *    name-&gt;小宋\n  *    age-&gt;20\n  *    job-&gt;程序员\n  *    say-&gt;function (){\n  *                console.log(&quot;我是原型的函数&quot;);\n  *    }\n**/\n</code></pre><p>或者我们可以直接通过设置类原型属性的方法来指定构造器</p>\n<pre><code>function Person(){}\nPerson.prototype = {\n    &quot;constructor&quot;:Person,\n    //  指定原型构造器,这边指定的是可以被枚举的\n    &quot;name&quot;:&quot;小宋&quot;,\n    &quot;age&quot;:20,\n    &quot;job&quot;:&quot;程序员&quot;,\n    &quot;say&quot;:function(){\n        console.log(&quot;我是原型的函数&quot;);\n    }\n};\n\nvar p1 = new Person();\n\nvar str = &quot;&quot;;\nfor(var attr in p1){\n    str += attr + &quot;-&gt;&quot; + p1[attr] + &quot;\\n&quot;;\n}\nconsole.log(str);\n/**\n  *    constructor-&gt;function Person(){\n  *\n  *    }\n  *    name-&gt;小宋\n  *    age-&gt;20\n  *    job-&gt;程序员\n  *    say-&gt;function (){\n  *                console.log(&quot;我是原型的函数&quot;);\n  *    }\n**/\n</code></pre>","excerpt":"","more":"<p>javaScript原型:</p>\n<p>定义：每一个方法被创建时都有一个prototype属性,改属性是一个指针,总是指向一个对象。该对象可以将特定的属性和方法包含在内,起到一个被所有实例所共享的作用。</p>\n<pre><code>function Person(){\n\n}\n\nvar obj  = Person.prototype;\n    obj.name = &quot;小宋&quot;;\n    obj.age = 20;\n    obj.sayName = function(){\n        console.log(this.name);\n    };\n//    定义一个变量来引用原型,修改这个变量的属性达到修改原型的目的\n</code></pre><p>原型对象、构造方法、实例对象三者的关系</p>\n<p>1、构造方法.prototype = 原型对象</p>\n<p>2、原型对象的constructor = 构造方法</p>\n<p>3、实例对象.prototype = 原型对象</p>\n<p>原型中的常用方法</p>\n<p>1、isPrototypeOf      (判断一个对象是不是另一个对象的原型)<br>示例:</p>\n<pre><code>function Person(){}\nvar obj  = Person.prototype;\n    obj.name = &quot;小宋&quot;;\n    obj.age = 20;\n    obj.sayName = function(){\n        console.log(this.name);\n    };\nvar p = new Person();\nconsole.log(obj.isPrototypeOf(p1));        //    true\n</code></pre><p>2、Object.getPrototypeOf        (根据实例对象获取原型对象)<br>示例:</p>\n<pre><code>function Person(){}\nPerson.prototype.name = &quot;张三&quot;;\nPerson.prototype.age = 20;\nPerson.prototype.sayName = function(){\n    console.log(&quot;原型方法!&quot;);\n};\nvar p1 = new Person();\nconsole.log(Object.getPrototypeOf(p1));    //    Person的原型对象\n</code></pre><p>3、hasOwnProperty    (判断一个对象的属性是属于原型属性或者实例属性)<br>示例:</p>\n<pre><code>function Person(){}\n    Person.prototype.name = &quot;张三&quot;;\n    Person.prototype.age = 20;\n    Person.prototype.sayName = function(){\n        console.log(&quot;原型方法!&quot;);\n    };\nvar p1 = new Person();\np1.name = &quot;小宋&quot;;\nconsole.log(p1.hasOwnProperty(&quot;name&quot;));    //    true\n</code></pre><p>4、in操作符    (判断属性是否存在实例对象或原型对象中,类似于hasOwnProperty)<br>示例:</p>\n<pre><code>function Person(){}\n    Person.prototype.name = &quot;张三&quot;;\n    Person.prototype.age = 20;\n    Person.prototype.sayName = function(){\n        console.log(&quot;原型方法!&quot;);\n    };\nvar p1 = new Person();\np1.name = &quot;小宋&quot;;\nconsole.log(&quot;name&quot; in p1);    //    true\n</code></pre><p>5、Object.keys()    (取得当前对象下中所有键值,返回一个数组)<br>示例:</p>\n<pre><code>function Person(){}\n    Person.prototype.name = &quot;张三&quot;;\n    Person.prototype.age = 20;\n    Person.prototype.sayName = function(){\n        console.log(&quot;原型方法!&quot;);\n    };\nvar p7 = new Person();\nconsole.log(Object.keys(p7));    //    []\np7.name = &quot;z3&quot;;\np7.age = 20;\nconsole.log(Object.keys(p7));    //    [&quot;name&quot;, &quot;age&quot;]\nconsole.log(Object.keys(Person.prototype));    //    [&quot;name&quot;, &quot;age&quot;, &quot;sayName&quot;]\n</code></pre><p>6、Object.getOwnPropertyNames()    (枚举出该对象下所有属性,不管该属性是否可以被枚举,返回数组)<br>在ECMAScript中,对象原型下的constructor属性是不能被枚举的(for in),但是用Object.getOwnPropertyNames()方法可以把对象原型下所有属性都枚举出来,以数组的形式返回<br>示例:</p>\n<pre><code>function Person(){}\n    Person.prototype.name = &quot;张三&quot;;\n    Person.prototype.age = 20;\n    Person.prototype.sayName = function(){\n        console.log(&quot;原型方法!&quot;);\n    };\nconsole.log(Object.getOwnPropertyNames(Person.prototype));     //    [&quot;constructor&quot;, &quot;name&quot;, &quot;age&quot;, &quot;sayName&quot;]\n</code></pre><p>在平常的javaScript面向对象中,如果我们类的原型中没指定构造器,那么该构造器会默认为Object;<br>在ECMAScript5中,提供了给原型对象重新设置构造器的方法:Object.defineProperty();<br>ECMAScript5兼容性: IE8+,FireFox4+<br>下面我们就一起来看怎么调用该方法:</p>\n<pre><code>function Person(){}\nPerson.prototype = {\n    &quot;name&quot;:&quot;小宋&quot;,\n    &quot;age&quot;:20,\n    &quot;job&quot;:&quot;程序员&quot;,\n    &quot;say&quot;:function(){\n        console.log(&quot;我是原型的函数&quot;);\n    }\n};\nObject.defineProperty(Person.prototype,&quot;constructor&quot;,{\n    &quot;enumerable&quot;:false,\n   //    关闭枚举访问,默认为关闭状态(for in的时候不能读到该属性)\n    &quot;value&quot;:Person\n  //    指定原型构造器\n});\n\nvar p1 = new Person();\n\nvar str = &quot;&quot;;\n    for(var attr in p1){\n        str += attr + &quot;-&gt;&quot; + p1[attr] + &quot;\\n&quot;;\n    }\nconsole.log(str);\n/**\n  *    name-&gt;小宋\n  *    age-&gt;20\n  *    job-&gt;程序员\n  *    say-&gt;function (){\n  *                console.log(&quot;我是原型的函数&quot;);\n  *    }\n**/\n</code></pre><p>或者我们可以直接通过设置类原型属性的方法来指定构造器</p>\n<pre><code>function Person(){}\nPerson.prototype = {\n    &quot;constructor&quot;:Person,\n    //  指定原型构造器,这边指定的是可以被枚举的\n    &quot;name&quot;:&quot;小宋&quot;,\n    &quot;age&quot;:20,\n    &quot;job&quot;:&quot;程序员&quot;,\n    &quot;say&quot;:function(){\n        console.log(&quot;我是原型的函数&quot;);\n    }\n};\n\nvar p1 = new Person();\n\nvar str = &quot;&quot;;\nfor(var attr in p1){\n    str += attr + &quot;-&gt;&quot; + p1[attr] + &quot;\\n&quot;;\n}\nconsole.log(str);\n/**\n  *    constructor-&gt;function Person(){\n  *\n  *    }\n  *    name-&gt;小宋\n  *    age-&gt;20\n  *    job-&gt;程序员\n  *    say-&gt;function (){\n  *                console.log(&quot;我是原型的函数&quot;);\n  *    }\n**/\n</code></pre>"},{"layout":"post","title":"javascript实现继承","date":"2015-05-25T16:00:00.000Z","_content":"\n继承:\n\n继承是指一个对象拥有另外一个对象一些公共方法或属性。在大多数其他面向对象语言中，继承一个类只需使用一个关键字即可；但是在JS中想要达到继承公用成员的目的，需要采取一系列措施。JS属于原型式继承，得益于这种灵活性，我们既可以使用标准的基于类的继承，也可以使用更微妙一些的原型式继承。在JS中应该要明确一点，一切继承都是通过prototype来进行的，JS是基于对象来继承的，且不止一种继承方式。\n\n第一种：\n\n\t/**\n     * 父类SuperClass的构造器\n     * @param name\n     * @constructor\n     */\n\tfunction SpuerClass(name){\n\t\tthis.name = name;\t\n\t}\n\t\n\tSuperClass.prototype = {\n\t\t\"constructor\":SpuerClass,\n\t\t//\t修正构造器\n\t\t\"getName\":function(){\n\t\t\treturn this.name;\n\t\t}\n\t\t//\t父类原型对象下的getName方法\n\t};\n\n\t/**\n     * 子类SubClass的构造器\n     * @param name\n     * @param age\n     * @constructor\n     */\n\tfunction SubClass(name,age){\n\t\tSuperClass.call(this,name);\n\t\t//\tSuperClass.apply(this,[name]);\n\t\t//\t继承父类构造器\n\t}\n\t\n\tSubClass.prototype = new SuperClass();\n\t//\t继承父类的原型\n\t\n\tSubClass.prototype.constructor = SubClass;\n\t//\t修正子类的构造器\n\n\tSubClass.prototype.getAge = function(){\n\t\treturn this.age;\n\t}\n\t//\t子类原型对象下的getAge方法\n\n这种继承方式就是最简单的JS继承：伪造对象法。不足之处在于实例化SubClass时会调用两次父类的构造方法，且需要额外的保存原型链中实例化父类的对象，如果在属性和方法比较多的情况下，这样一来性能方面就大打折扣了，效果是达到了，但是执行速率受到了一定的影响。且耦合性较大，于是就有了下面的继承方式。\n\n第二种：\n\n\t/**\n     *\n     * @param sub 子类\n     * @param sup 父类\n     * 实现子类对父类原型的继承\n     */\n    function extend(sub,sup){       \n        var F = new Function();\n\t\t//  用一个空函数进行中转\n        \n        F.prototype = sup.prototype;\n        //  空函数的原型对象和父类的原型对象转换\n\n        sub.prototype = new F();\n\t\t//  原型继承\n        \n        sub.prototype.constructor = sub;\n\t    //  还原子类构造器\n\n\t\t//  指定子类构造方法\n        //  保存父类的原型对象\n\t\t//  1.解耦方便,降低耦合性 2.方便获得父类的原型对象\n\n        sub.superClass = sup.prototype;\n\t\t//  自定义子类的静态属性,接收父类的原型对象,\n\t\t//\t如果子类重写了父类方法，可以通过该属性来访问\n        if(sup.prototype.constructor == \n\t\t   Object.prototype.constructor){\n            sup.prototype.constructor = sup;\n        }\n        //  判断父类原型对象的构造器是否为父类本身\n\t\t//\t如果不是,手动还原构造器\n    }\n\n\t/**\n     * 父类SuperClass的构造器\n     * @param name\n     * @constructor\n     */\n\tfunction SpuerClass(name){\n\t\tthis.name = name;\t\n\t}\n\t\n\tSuperClass.prototype = {\n\t\t\"constructor\":SpuerClass,\n\t\t//\t修正构造器\n\t\t\"getName\":function(){\n\t\t\treturn this.name;\n\t\t}\n\t\t//\t父类原型对象下的getName方法\n\t};\n\n\t/**\n     * 子类SubClass的构造器\n     * @param name\n     * @param age\n     * @constructor\n     */\n\tfunction SubClass(name,age){\n\t\tSubClass.superClass.constroctur.call(this,name);\n\t\t//\t继承父类的name属性\n\t\tthis.age = age;\n\t}\n\t\n\textend(SubClass,SuperClass);\n\t//\t实现继承\n\n\tSubClass.prototype.getName = function(){\n\t\treturn \"你好,\" + this.name + \"!\";\n\t}\n\t//\t子类重写了父类的getName方法\n\n\tvar sub = new SubClass(\"小宋\",22);\n\tconsole.log(sub.getName());\n\t//\t你好,小宋\n\n\tconsole.log(SubClass.superClass.getName.call(sub));\n\t//\t通过子类的静态属性来访问父类方法\n\t//\t小宋\n\t\n上述代码也实现了子类对父类的继承，且是现在用的比较广泛的一种(类式继承)。\n个人认为这种方法的好处在于：\n\n1、仅在实例化对象的时候调用一次父类的构造函数；   \n2、且没有保存不必要的父类实例化的属性；   \n3、通过superClass属性，可以很轻松的访问被子类重写的父类方法；   \n4、降低耦合性。","source":"_posts/2015-05-26-js-object-extend.md","raw":"---\nlayout: post\ntitle: javascript实现继承\ndate: 2015-05-26\ncategories: [javascript, 继承]\n---\n\n继承:\n\n继承是指一个对象拥有另外一个对象一些公共方法或属性。在大多数其他面向对象语言中，继承一个类只需使用一个关键字即可；但是在JS中想要达到继承公用成员的目的，需要采取一系列措施。JS属于原型式继承，得益于这种灵活性，我们既可以使用标准的基于类的继承，也可以使用更微妙一些的原型式继承。在JS中应该要明确一点，一切继承都是通过prototype来进行的，JS是基于对象来继承的，且不止一种继承方式。\n\n第一种：\n\n\t/**\n     * 父类SuperClass的构造器\n     * @param name\n     * @constructor\n     */\n\tfunction SpuerClass(name){\n\t\tthis.name = name;\t\n\t}\n\t\n\tSuperClass.prototype = {\n\t\t\"constructor\":SpuerClass,\n\t\t//\t修正构造器\n\t\t\"getName\":function(){\n\t\t\treturn this.name;\n\t\t}\n\t\t//\t父类原型对象下的getName方法\n\t};\n\n\t/**\n     * 子类SubClass的构造器\n     * @param name\n     * @param age\n     * @constructor\n     */\n\tfunction SubClass(name,age){\n\t\tSuperClass.call(this,name);\n\t\t//\tSuperClass.apply(this,[name]);\n\t\t//\t继承父类构造器\n\t}\n\t\n\tSubClass.prototype = new SuperClass();\n\t//\t继承父类的原型\n\t\n\tSubClass.prototype.constructor = SubClass;\n\t//\t修正子类的构造器\n\n\tSubClass.prototype.getAge = function(){\n\t\treturn this.age;\n\t}\n\t//\t子类原型对象下的getAge方法\n\n这种继承方式就是最简单的JS继承：伪造对象法。不足之处在于实例化SubClass时会调用两次父类的构造方法，且需要额外的保存原型链中实例化父类的对象，如果在属性和方法比较多的情况下，这样一来性能方面就大打折扣了，效果是达到了，但是执行速率受到了一定的影响。且耦合性较大，于是就有了下面的继承方式。\n\n第二种：\n\n\t/**\n     *\n     * @param sub 子类\n     * @param sup 父类\n     * 实现子类对父类原型的继承\n     */\n    function extend(sub,sup){       \n        var F = new Function();\n\t\t//  用一个空函数进行中转\n        \n        F.prototype = sup.prototype;\n        //  空函数的原型对象和父类的原型对象转换\n\n        sub.prototype = new F();\n\t\t//  原型继承\n        \n        sub.prototype.constructor = sub;\n\t    //  还原子类构造器\n\n\t\t//  指定子类构造方法\n        //  保存父类的原型对象\n\t\t//  1.解耦方便,降低耦合性 2.方便获得父类的原型对象\n\n        sub.superClass = sup.prototype;\n\t\t//  自定义子类的静态属性,接收父类的原型对象,\n\t\t//\t如果子类重写了父类方法，可以通过该属性来访问\n        if(sup.prototype.constructor == \n\t\t   Object.prototype.constructor){\n            sup.prototype.constructor = sup;\n        }\n        //  判断父类原型对象的构造器是否为父类本身\n\t\t//\t如果不是,手动还原构造器\n    }\n\n\t/**\n     * 父类SuperClass的构造器\n     * @param name\n     * @constructor\n     */\n\tfunction SpuerClass(name){\n\t\tthis.name = name;\t\n\t}\n\t\n\tSuperClass.prototype = {\n\t\t\"constructor\":SpuerClass,\n\t\t//\t修正构造器\n\t\t\"getName\":function(){\n\t\t\treturn this.name;\n\t\t}\n\t\t//\t父类原型对象下的getName方法\n\t};\n\n\t/**\n     * 子类SubClass的构造器\n     * @param name\n     * @param age\n     * @constructor\n     */\n\tfunction SubClass(name,age){\n\t\tSubClass.superClass.constroctur.call(this,name);\n\t\t//\t继承父类的name属性\n\t\tthis.age = age;\n\t}\n\t\n\textend(SubClass,SuperClass);\n\t//\t实现继承\n\n\tSubClass.prototype.getName = function(){\n\t\treturn \"你好,\" + this.name + \"!\";\n\t}\n\t//\t子类重写了父类的getName方法\n\n\tvar sub = new SubClass(\"小宋\",22);\n\tconsole.log(sub.getName());\n\t//\t你好,小宋\n\n\tconsole.log(SubClass.superClass.getName.call(sub));\n\t//\t通过子类的静态属性来访问父类方法\n\t//\t小宋\n\t\n上述代码也实现了子类对父类的继承，且是现在用的比较广泛的一种(类式继承)。\n个人认为这种方法的好处在于：\n\n1、仅在实例化对象的时候调用一次父类的构造函数；   \n2、且没有保存不必要的父类实例化的属性；   \n3、通过superClass属性，可以很轻松的访问被子类重写的父类方法；   \n4、降低耦合性。","slug":"2015-05-26-js-object-extend","published":1,"updated":"2016-11-09T13:59:48.000Z","_id":"civ7fsee90007t95f5nprobu2","comments":1,"photos":[],"link":"","content":"<p>继承:</p>\n<p>继承是指一个对象拥有另外一个对象一些公共方法或属性。在大多数其他面向对象语言中，继承一个类只需使用一个关键字即可；但是在JS中想要达到继承公用成员的目的，需要采取一系列措施。JS属于原型式继承，得益于这种灵活性，我们既可以使用标准的基于类的继承，也可以使用更微妙一些的原型式继承。在JS中应该要明确一点，一切继承都是通过prototype来进行的，JS是基于对象来继承的，且不止一种继承方式。</p>\n<p>第一种：</p>\n<pre><code>/**\n * 父类SuperClass的构造器\n * @param name\n * @constructor\n */\nfunction SpuerClass(name){\n    this.name = name;    \n}\n\nSuperClass.prototype = {\n    &quot;constructor&quot;:SpuerClass,\n    //    修正构造器\n    &quot;getName&quot;:function(){\n        return this.name;\n    }\n    //    父类原型对象下的getName方法\n};\n\n/**\n * 子类SubClass的构造器\n * @param name\n * @param age\n * @constructor\n */\nfunction SubClass(name,age){\n    SuperClass.call(this,name);\n    //    SuperClass.apply(this,[name]);\n    //    继承父类构造器\n}\n\nSubClass.prototype = new SuperClass();\n//    继承父类的原型\n\nSubClass.prototype.constructor = SubClass;\n//    修正子类的构造器\n\nSubClass.prototype.getAge = function(){\n    return this.age;\n}\n//    子类原型对象下的getAge方法\n</code></pre><p>这种继承方式就是最简单的JS继承：伪造对象法。不足之处在于实例化SubClass时会调用两次父类的构造方法，且需要额外的保存原型链中实例化父类的对象，如果在属性和方法比较多的情况下，这样一来性能方面就大打折扣了，效果是达到了，但是执行速率受到了一定的影响。且耦合性较大，于是就有了下面的继承方式。</p>\n<p>第二种：</p>\n<pre><code>/**\n *\n * @param sub 子类\n * @param sup 父类\n * 实现子类对父类原型的继承\n */\nfunction extend(sub,sup){       \n    var F = new Function();\n    //  用一个空函数进行中转\n\n    F.prototype = sup.prototype;\n    //  空函数的原型对象和父类的原型对象转换\n\n    sub.prototype = new F();\n    //  原型继承\n\n    sub.prototype.constructor = sub;\n    //  还原子类构造器\n\n    //  指定子类构造方法\n    //  保存父类的原型对象\n    //  1.解耦方便,降低耦合性 2.方便获得父类的原型对象\n\n    sub.superClass = sup.prototype;\n    //  自定义子类的静态属性,接收父类的原型对象,\n    //    如果子类重写了父类方法，可以通过该属性来访问\n    if(sup.prototype.constructor == \n       Object.prototype.constructor){\n        sup.prototype.constructor = sup;\n    }\n    //  判断父类原型对象的构造器是否为父类本身\n    //    如果不是,手动还原构造器\n}\n\n/**\n * 父类SuperClass的构造器\n * @param name\n * @constructor\n */\nfunction SpuerClass(name){\n    this.name = name;    \n}\n\nSuperClass.prototype = {\n    &quot;constructor&quot;:SpuerClass,\n    //    修正构造器\n    &quot;getName&quot;:function(){\n        return this.name;\n    }\n    //    父类原型对象下的getName方法\n};\n\n/**\n * 子类SubClass的构造器\n * @param name\n * @param age\n * @constructor\n */\nfunction SubClass(name,age){\n    SubClass.superClass.constroctur.call(this,name);\n    //    继承父类的name属性\n    this.age = age;\n}\n\nextend(SubClass,SuperClass);\n//    实现继承\n\nSubClass.prototype.getName = function(){\n    return &quot;你好,&quot; + this.name + &quot;!&quot;;\n}\n//    子类重写了父类的getName方法\n\nvar sub = new SubClass(&quot;小宋&quot;,22);\nconsole.log(sub.getName());\n//    你好,小宋\n\nconsole.log(SubClass.superClass.getName.call(sub));\n//    通过子类的静态属性来访问父类方法\n//    小宋\n</code></pre><p>上述代码也实现了子类对父类的继承，且是现在用的比较广泛的一种(类式继承)。<br>个人认为这种方法的好处在于：</p>\n<p>1、仅在实例化对象的时候调用一次父类的构造函数；<br>2、且没有保存不必要的父类实例化的属性；<br>3、通过superClass属性，可以很轻松的访问被子类重写的父类方法；<br>4、降低耦合性。</p>\n","excerpt":"","more":"<p>继承:</p>\n<p>继承是指一个对象拥有另外一个对象一些公共方法或属性。在大多数其他面向对象语言中，继承一个类只需使用一个关键字即可；但是在JS中想要达到继承公用成员的目的，需要采取一系列措施。JS属于原型式继承，得益于这种灵活性，我们既可以使用标准的基于类的继承，也可以使用更微妙一些的原型式继承。在JS中应该要明确一点，一切继承都是通过prototype来进行的，JS是基于对象来继承的，且不止一种继承方式。</p>\n<p>第一种：</p>\n<pre><code>/**\n * 父类SuperClass的构造器\n * @param name\n * @constructor\n */\nfunction SpuerClass(name){\n    this.name = name;    \n}\n\nSuperClass.prototype = {\n    &quot;constructor&quot;:SpuerClass,\n    //    修正构造器\n    &quot;getName&quot;:function(){\n        return this.name;\n    }\n    //    父类原型对象下的getName方法\n};\n\n/**\n * 子类SubClass的构造器\n * @param name\n * @param age\n * @constructor\n */\nfunction SubClass(name,age){\n    SuperClass.call(this,name);\n    //    SuperClass.apply(this,[name]);\n    //    继承父类构造器\n}\n\nSubClass.prototype = new SuperClass();\n//    继承父类的原型\n\nSubClass.prototype.constructor = SubClass;\n//    修正子类的构造器\n\nSubClass.prototype.getAge = function(){\n    return this.age;\n}\n//    子类原型对象下的getAge方法\n</code></pre><p>这种继承方式就是最简单的JS继承：伪造对象法。不足之处在于实例化SubClass时会调用两次父类的构造方法，且需要额外的保存原型链中实例化父类的对象，如果在属性和方法比较多的情况下，这样一来性能方面就大打折扣了，效果是达到了，但是执行速率受到了一定的影响。且耦合性较大，于是就有了下面的继承方式。</p>\n<p>第二种：</p>\n<pre><code>/**\n *\n * @param sub 子类\n * @param sup 父类\n * 实现子类对父类原型的继承\n */\nfunction extend(sub,sup){       \n    var F = new Function();\n    //  用一个空函数进行中转\n\n    F.prototype = sup.prototype;\n    //  空函数的原型对象和父类的原型对象转换\n\n    sub.prototype = new F();\n    //  原型继承\n\n    sub.prototype.constructor = sub;\n    //  还原子类构造器\n\n    //  指定子类构造方法\n    //  保存父类的原型对象\n    //  1.解耦方便,降低耦合性 2.方便获得父类的原型对象\n\n    sub.superClass = sup.prototype;\n    //  自定义子类的静态属性,接收父类的原型对象,\n    //    如果子类重写了父类方法，可以通过该属性来访问\n    if(sup.prototype.constructor == \n       Object.prototype.constructor){\n        sup.prototype.constructor = sup;\n    }\n    //  判断父类原型对象的构造器是否为父类本身\n    //    如果不是,手动还原构造器\n}\n\n/**\n * 父类SuperClass的构造器\n * @param name\n * @constructor\n */\nfunction SpuerClass(name){\n    this.name = name;    \n}\n\nSuperClass.prototype = {\n    &quot;constructor&quot;:SpuerClass,\n    //    修正构造器\n    &quot;getName&quot;:function(){\n        return this.name;\n    }\n    //    父类原型对象下的getName方法\n};\n\n/**\n * 子类SubClass的构造器\n * @param name\n * @param age\n * @constructor\n */\nfunction SubClass(name,age){\n    SubClass.superClass.constroctur.call(this,name);\n    //    继承父类的name属性\n    this.age = age;\n}\n\nextend(SubClass,SuperClass);\n//    实现继承\n\nSubClass.prototype.getName = function(){\n    return &quot;你好,&quot; + this.name + &quot;!&quot;;\n}\n//    子类重写了父类的getName方法\n\nvar sub = new SubClass(&quot;小宋&quot;,22);\nconsole.log(sub.getName());\n//    你好,小宋\n\nconsole.log(SubClass.superClass.getName.call(sub));\n//    通过子类的静态属性来访问父类方法\n//    小宋\n</code></pre><p>上述代码也实现了子类对父类的继承，且是现在用的比较广泛的一种(类式继承)。<br>个人认为这种方法的好处在于：</p>\n<p>1、仅在实例化对象的时候调用一次父类的构造函数；<br>2、且没有保存不必要的父类实例化的属性；<br>3、通过superClass属性，可以很轻松的访问被子类重写的父类方法；<br>4、降低耦合性。</p>\n"},{"layout":"post","title":"javascript接口","date":"2015-05-26T16:00:00.000Z","_content":"\n接口:\n\n接口是提供了一种用以说明一个对象应该具有哪些方法的手段，但它并不规定这些方法应该如何实现。在JS中，没有像其他面向对象程序语言的interface关键字，所以实现的方法也语言不同；JS实现接口的主要方式主要为定义描述法、属性检测法和鸭式辨型法，其中鸭式辨型法是目前用的最多的。\n\n1、定义描述法\n\n\t/**\n     *  interface CompsiteImpl{\n     *      function add();\n     *      function remove();\n     *      function update();\n     *  }\n     */\n\n    /**\n     * 实现接口\n     * @constructor\n     */\n    function CompsiteImpl(){\n    }\n\n    CompsiteImpl.prototype = {\n        \"constructor\":CompsiteImpl,\n        \"add\":function(){\n            console.log(\"我是add方法！\");\n        },\n        \"remove\":function(){\n            console.log(\"我是remove方法！\");\n        },\n        \"update\":function(){\n            console.log(\"我是update方法！\");\n        }\n    };\n\n此方法也称注释法，顾名思义，就是通过一系列的注释来定义该类需要实现哪些接口方法，这是最简单定义接口的一种方法。但是此方法缺点实在太明显了，比如一个人代码写完了，他只能通过肉眼来判断是不是都把刚才注释里面的方法都实现了；他哪天代码做修改了，是否和注释一致等等的。只是属于一个类似于帮助文档的范畴，太死板。\n\n2、属性检测法\n\n\t/**\n     *  interface Compsite{\n     *      function add();\n     *      function remove();\n     *      function update();\n     *  }\n     *\n     *  interface FormItem{\n     *      function select();\n     *  }\n     *\n     */\n\n    //  实现接口\n    //  需要实现 Compsite FormItem\n    function CompsiteImpl(){\n        //  在类的内部定义一个变量\n        this.implementsInterface = [\"Compsite\",\"FormItem\"];\n    }\n\n    CompsiteImpl.prototype = {\n        \"constructor\":CompsiteImpl,\n        \"add\":function(){\n            console.log(\"add 方法\");\n        },\n        \"remove\":function(){\n\t\t\tconsole.log(\"remove 方法\");\n\t\t},\n        \"update\":function(){\n\t\t\tconsole.log(\"remove 方法\");},\n        \"select\":function(){\n\t\t\tconsole.log(\"select 方法\");\n\t\t}\n    };\n\n    /**\n     *\n     * @param instance\n     *\n     * 检测类的方法\n     */\n    function checkCompsiteImpl(instance){\n        //  判断当前对象是否实现了所有的接口\n        if(!isImplements(instance,\"Compsite\",\"FormItem\"))\n\t\t{\n            throw new Error(\"object does not implement \n\t\t\t\ta required interface\");\n        }\n    }\n\n    /**\n     *\n     * @param object\n     *\n     * 公共的、具体的检测方法(核心方法)\n     */\n    function isImplements(object){\n        for(var i = 1,l = arguments.length;\n\t\ti < l;i ++){\n            var interfaceName = arguments[i],\n                interfaceFound = false;\n            for(var j = 0,\n\t\t\t\tlen = object.implementsInterface.length;\n\t\t\tj < len;j ++)\n\t\t\t{\n                if(object.implementsInterface[j] ==\n\t\t\t interfaceName){\n                    interfaceFound = true;\n                }\n            }\n            if(!interfaceFound){\n                return false;\n            }\n            return true;\n        }\n    }\n\n    var c1 = new CompsiteImpl();\n    checkCompsiteImpl(c1);\n    c1.add();\n\n这种方法相对来说高级一点了，如果有一个接口没有没实现，会看到一个错误，代码不往下继续走了。但缺点在于仍无法判断是否真正实现了对应的接口方法，仅仅只是\"自称\"实现了接口，同时这种方法耦合性也比较高，放到另外一个地方可能就需要进行修改才能复用。\n\n3、鸭式辨型法\n\n\t/**\n     *\n     * @param name      接口名,字符串\n     * @param methods   需要实现的方法,接收方法的集合、数组\n     * @constructor\n     * 接口类\n     */\n    function Interface(name,methods){\n        //  判断接口的参数个数\n        if(arguments.length != 2){\n            throw new Error(\"this instance interface \n\t\t\tconstructor required 2 arguments!\");\n        }\n        this.name = name;\n        this.methods = [];\n        //  定义一个空数组,等待接收methods里面的方法名\n        for(var i = 0,len = methods.length; i < len; i ++){\n            if(typeof methods[i] !== \"string\"){\n                throw new Error(\"the Instance method name\n\t\t\t\t is error!\");\n            }\n            this.methods.push(methods[i]);\n        }\n    }\n\n    /**\n     *\n     * @param object\n     *\n     * 检验方法,如果通过,不做任何操作,否则抛出异常\n     */\n    Interface.ensureImplement = function(object){\n        //  至少得实现一个接口\n        if(arguments.length < 2){\n            throw new Error(\"Interface.ensureImplement \n\t\tconstructor arguments must be 2 \n\t\t\tor more arguments!\");\n        }\n        //  获得接口实例对象\n        for(var i = 1,len = arguments.length;\n\t\ti < len;i ++){\n            var instanceInterface = arguments[i];\n            //  判断参数是否为接口类的\n            if(!(instanceInterface instanceof Interface))\n\t\t\t{\n                throw new Error(\"the arguments\" + \n\t\t\t\tinstanceInterface + \"is \n\t\t\t\tnot an instance of Interface Class\");\n            }\n            //  循环接口实例对象里面的每个方法\n            for(var j = 0,l = instanceInterface.methods.length;\n\t\t\t j < l;j ++){\n                var methodName = \n\t\t\t\tinstanceInterface.methods[j];\n                //  接收每个方法的名字(字符串)\n                if(!arguments[0][methodName] || \n\t\ttypeof arguments[0][methodName] !== \"function\")\n\t\t{\n                    throw new Error(\"the method \"+ \n\t\t\t\t\tmethodName +\" is not found\");\n                }\n                //  不存在或者不是方法类型\n            }\n        }\n    };\n\n    //  实例化接口对象\n    var CompsiteInterface = new Interface(\"CompsiteInterface\",\n\t[\"add\",\"remove\"]),\n    FormInteInterface = new \n\tInterface(\"FormInteInterface\",\n\t[\"update\",\"select\"]);\n\n    /**\n     *\n     * @constructor\n     * 接口类\n     */\n    function CompsiteImpl(){\n    }\n    //  实现接口\n    CompsiteImpl.prototype = {\n        \"constructor\":CompsiteImpl,\n        add:function(){\n            console.log(\"add 方法\");\n        },\n        remove:function(){},\n        update:function(){},\n        select:function(){}\n    };\n\n    //  检验接口里的方法\n    var c1 = new CompsiteImpl\n\t(c1,CompsiteInterface,FormInteInterface);\n\n    Interface.ensureImplement\n\t(c1,CompsiteInterface,FormInteInterface);\n\n    c1.add();\n\n此方法就是目前最经典的一种方法，从上面的代码中可以看出，在这里完全采用的是面向对象的方法，通过实例化两个接口对象来声明需要实现的方法，最后实例化我们真正需要需要实例化的对象c1,通过Interface下的静态方法来判断是否已经实现全部接口，如果有一个没被实现则会看到具体是哪个没被实现，并且终止代码的继续运行，且耦合度较低。\n\n接口的好处主要是提高了系统相似模块的重用性，使得不同类的通信更加稳固。一旦实现接口，则必须实现接口中所有的方法。在大型系统中，接口的益处是显而易见的，但是如果在一个小的web系统中使用接口就显得画蛇添足了。\n","source":"_posts/2015-05-27-js-design-mode-interface.md","raw":"---\nlayout: post\ntitle: javascript接口\ndate: 2015-05-27\ncategories: [javascript, 接口]\n---\n\n接口:\n\n接口是提供了一种用以说明一个对象应该具有哪些方法的手段，但它并不规定这些方法应该如何实现。在JS中，没有像其他面向对象程序语言的interface关键字，所以实现的方法也语言不同；JS实现接口的主要方式主要为定义描述法、属性检测法和鸭式辨型法，其中鸭式辨型法是目前用的最多的。\n\n1、定义描述法\n\n\t/**\n     *  interface CompsiteImpl{\n     *      function add();\n     *      function remove();\n     *      function update();\n     *  }\n     */\n\n    /**\n     * 实现接口\n     * @constructor\n     */\n    function CompsiteImpl(){\n    }\n\n    CompsiteImpl.prototype = {\n        \"constructor\":CompsiteImpl,\n        \"add\":function(){\n            console.log(\"我是add方法！\");\n        },\n        \"remove\":function(){\n            console.log(\"我是remove方法！\");\n        },\n        \"update\":function(){\n            console.log(\"我是update方法！\");\n        }\n    };\n\n此方法也称注释法，顾名思义，就是通过一系列的注释来定义该类需要实现哪些接口方法，这是最简单定义接口的一种方法。但是此方法缺点实在太明显了，比如一个人代码写完了，他只能通过肉眼来判断是不是都把刚才注释里面的方法都实现了；他哪天代码做修改了，是否和注释一致等等的。只是属于一个类似于帮助文档的范畴，太死板。\n\n2、属性检测法\n\n\t/**\n     *  interface Compsite{\n     *      function add();\n     *      function remove();\n     *      function update();\n     *  }\n     *\n     *  interface FormItem{\n     *      function select();\n     *  }\n     *\n     */\n\n    //  实现接口\n    //  需要实现 Compsite FormItem\n    function CompsiteImpl(){\n        //  在类的内部定义一个变量\n        this.implementsInterface = [\"Compsite\",\"FormItem\"];\n    }\n\n    CompsiteImpl.prototype = {\n        \"constructor\":CompsiteImpl,\n        \"add\":function(){\n            console.log(\"add 方法\");\n        },\n        \"remove\":function(){\n\t\t\tconsole.log(\"remove 方法\");\n\t\t},\n        \"update\":function(){\n\t\t\tconsole.log(\"remove 方法\");},\n        \"select\":function(){\n\t\t\tconsole.log(\"select 方法\");\n\t\t}\n    };\n\n    /**\n     *\n     * @param instance\n     *\n     * 检测类的方法\n     */\n    function checkCompsiteImpl(instance){\n        //  判断当前对象是否实现了所有的接口\n        if(!isImplements(instance,\"Compsite\",\"FormItem\"))\n\t\t{\n            throw new Error(\"object does not implement \n\t\t\t\ta required interface\");\n        }\n    }\n\n    /**\n     *\n     * @param object\n     *\n     * 公共的、具体的检测方法(核心方法)\n     */\n    function isImplements(object){\n        for(var i = 1,l = arguments.length;\n\t\ti < l;i ++){\n            var interfaceName = arguments[i],\n                interfaceFound = false;\n            for(var j = 0,\n\t\t\t\tlen = object.implementsInterface.length;\n\t\t\tj < len;j ++)\n\t\t\t{\n                if(object.implementsInterface[j] ==\n\t\t\t interfaceName){\n                    interfaceFound = true;\n                }\n            }\n            if(!interfaceFound){\n                return false;\n            }\n            return true;\n        }\n    }\n\n    var c1 = new CompsiteImpl();\n    checkCompsiteImpl(c1);\n    c1.add();\n\n这种方法相对来说高级一点了，如果有一个接口没有没实现，会看到一个错误，代码不往下继续走了。但缺点在于仍无法判断是否真正实现了对应的接口方法，仅仅只是\"自称\"实现了接口，同时这种方法耦合性也比较高，放到另外一个地方可能就需要进行修改才能复用。\n\n3、鸭式辨型法\n\n\t/**\n     *\n     * @param name      接口名,字符串\n     * @param methods   需要实现的方法,接收方法的集合、数组\n     * @constructor\n     * 接口类\n     */\n    function Interface(name,methods){\n        //  判断接口的参数个数\n        if(arguments.length != 2){\n            throw new Error(\"this instance interface \n\t\t\tconstructor required 2 arguments!\");\n        }\n        this.name = name;\n        this.methods = [];\n        //  定义一个空数组,等待接收methods里面的方法名\n        for(var i = 0,len = methods.length; i < len; i ++){\n            if(typeof methods[i] !== \"string\"){\n                throw new Error(\"the Instance method name\n\t\t\t\t is error!\");\n            }\n            this.methods.push(methods[i]);\n        }\n    }\n\n    /**\n     *\n     * @param object\n     *\n     * 检验方法,如果通过,不做任何操作,否则抛出异常\n     */\n    Interface.ensureImplement = function(object){\n        //  至少得实现一个接口\n        if(arguments.length < 2){\n            throw new Error(\"Interface.ensureImplement \n\t\tconstructor arguments must be 2 \n\t\t\tor more arguments!\");\n        }\n        //  获得接口实例对象\n        for(var i = 1,len = arguments.length;\n\t\ti < len;i ++){\n            var instanceInterface = arguments[i];\n            //  判断参数是否为接口类的\n            if(!(instanceInterface instanceof Interface))\n\t\t\t{\n                throw new Error(\"the arguments\" + \n\t\t\t\tinstanceInterface + \"is \n\t\t\t\tnot an instance of Interface Class\");\n            }\n            //  循环接口实例对象里面的每个方法\n            for(var j = 0,l = instanceInterface.methods.length;\n\t\t\t j < l;j ++){\n                var methodName = \n\t\t\t\tinstanceInterface.methods[j];\n                //  接收每个方法的名字(字符串)\n                if(!arguments[0][methodName] || \n\t\ttypeof arguments[0][methodName] !== \"function\")\n\t\t{\n                    throw new Error(\"the method \"+ \n\t\t\t\t\tmethodName +\" is not found\");\n                }\n                //  不存在或者不是方法类型\n            }\n        }\n    };\n\n    //  实例化接口对象\n    var CompsiteInterface = new Interface(\"CompsiteInterface\",\n\t[\"add\",\"remove\"]),\n    FormInteInterface = new \n\tInterface(\"FormInteInterface\",\n\t[\"update\",\"select\"]);\n\n    /**\n     *\n     * @constructor\n     * 接口类\n     */\n    function CompsiteImpl(){\n    }\n    //  实现接口\n    CompsiteImpl.prototype = {\n        \"constructor\":CompsiteImpl,\n        add:function(){\n            console.log(\"add 方法\");\n        },\n        remove:function(){},\n        update:function(){},\n        select:function(){}\n    };\n\n    //  检验接口里的方法\n    var c1 = new CompsiteImpl\n\t(c1,CompsiteInterface,FormInteInterface);\n\n    Interface.ensureImplement\n\t(c1,CompsiteInterface,FormInteInterface);\n\n    c1.add();\n\n此方法就是目前最经典的一种方法，从上面的代码中可以看出，在这里完全采用的是面向对象的方法，通过实例化两个接口对象来声明需要实现的方法，最后实例化我们真正需要需要实例化的对象c1,通过Interface下的静态方法来判断是否已经实现全部接口，如果有一个没被实现则会看到具体是哪个没被实现，并且终止代码的继续运行，且耦合度较低。\n\n接口的好处主要是提高了系统相似模块的重用性，使得不同类的通信更加稳固。一旦实现接口，则必须实现接口中所有的方法。在大型系统中，接口的益处是显而易见的，但是如果在一个小的web系统中使用接口就显得画蛇添足了。\n","slug":"2015-05-27-js-design-mode-interface","published":1,"updated":"2016-11-09T13:59:56.000Z","_id":"civ7fseeb0009t95f2h2381ab","comments":1,"photos":[],"link":"","content":"<p>接口:</p>\n<p>接口是提供了一种用以说明一个对象应该具有哪些方法的手段，但它并不规定这些方法应该如何实现。在JS中，没有像其他面向对象程序语言的interface关键字，所以实现的方法也语言不同；JS实现接口的主要方式主要为定义描述法、属性检测法和鸭式辨型法，其中鸭式辨型法是目前用的最多的。</p>\n<p>1、定义描述法</p>\n<pre><code>/**\n *  interface CompsiteImpl{\n *      function add();\n *      function remove();\n *      function update();\n *  }\n */\n\n/**\n * 实现接口\n * @constructor\n */\nfunction CompsiteImpl(){\n}\n\nCompsiteImpl.prototype = {\n    &quot;constructor&quot;:CompsiteImpl,\n    &quot;add&quot;:function(){\n        console.log(&quot;我是add方法！&quot;);\n    },\n    &quot;remove&quot;:function(){\n        console.log(&quot;我是remove方法！&quot;);\n    },\n    &quot;update&quot;:function(){\n        console.log(&quot;我是update方法！&quot;);\n    }\n};\n</code></pre><p>此方法也称注释法，顾名思义，就是通过一系列的注释来定义该类需要实现哪些接口方法，这是最简单定义接口的一种方法。但是此方法缺点实在太明显了，比如一个人代码写完了，他只能通过肉眼来判断是不是都把刚才注释里面的方法都实现了；他哪天代码做修改了，是否和注释一致等等的。只是属于一个类似于帮助文档的范畴，太死板。</p>\n<p>2、属性检测法</p>\n<pre><code>/**\n *  interface Compsite{\n *      function add();\n *      function remove();\n *      function update();\n *  }\n *\n *  interface FormItem{\n *      function select();\n *  }\n *\n */\n\n//  实现接口\n//  需要实现 Compsite FormItem\nfunction CompsiteImpl(){\n    //  在类的内部定义一个变量\n    this.implementsInterface = [&quot;Compsite&quot;,&quot;FormItem&quot;];\n}\n\nCompsiteImpl.prototype = {\n    &quot;constructor&quot;:CompsiteImpl,\n    &quot;add&quot;:function(){\n        console.log(&quot;add 方法&quot;);\n    },\n    &quot;remove&quot;:function(){\n        console.log(&quot;remove 方法&quot;);\n    },\n    &quot;update&quot;:function(){\n        console.log(&quot;remove 方法&quot;);},\n    &quot;select&quot;:function(){\n        console.log(&quot;select 方法&quot;);\n    }\n};\n\n/**\n *\n * @param instance\n *\n * 检测类的方法\n */\nfunction checkCompsiteImpl(instance){\n    //  判断当前对象是否实现了所有的接口\n    if(!isImplements(instance,&quot;Compsite&quot;,&quot;FormItem&quot;))\n    {\n        throw new Error(&quot;object does not implement \n            a required interface&quot;);\n    }\n}\n\n/**\n *\n * @param object\n *\n * 公共的、具体的检测方法(核心方法)\n */\nfunction isImplements(object){\n    for(var i = 1,l = arguments.length;\n    i &lt; l;i ++){\n        var interfaceName = arguments[i],\n            interfaceFound = false;\n        for(var j = 0,\n            len = object.implementsInterface.length;\n        j &lt; len;j ++)\n        {\n            if(object.implementsInterface[j] ==\n         interfaceName){\n                interfaceFound = true;\n            }\n        }\n        if(!interfaceFound){\n            return false;\n        }\n        return true;\n    }\n}\n\nvar c1 = new CompsiteImpl();\ncheckCompsiteImpl(c1);\nc1.add();\n</code></pre><p>这种方法相对来说高级一点了，如果有一个接口没有没实现，会看到一个错误，代码不往下继续走了。但缺点在于仍无法判断是否真正实现了对应的接口方法，仅仅只是”自称”实现了接口，同时这种方法耦合性也比较高，放到另外一个地方可能就需要进行修改才能复用。</p>\n<p>3、鸭式辨型法</p>\n<pre><code>/**\n *\n * @param name      接口名,字符串\n * @param methods   需要实现的方法,接收方法的集合、数组\n * @constructor\n * 接口类\n */\nfunction Interface(name,methods){\n    //  判断接口的参数个数\n    if(arguments.length != 2){\n        throw new Error(&quot;this instance interface \n        constructor required 2 arguments!&quot;);\n    }\n    this.name = name;\n    this.methods = [];\n    //  定义一个空数组,等待接收methods里面的方法名\n    for(var i = 0,len = methods.length; i &lt; len; i ++){\n        if(typeof methods[i] !== &quot;string&quot;){\n            throw new Error(&quot;the Instance method name\n             is error!&quot;);\n        }\n        this.methods.push(methods[i]);\n    }\n}\n\n/**\n *\n * @param object\n *\n * 检验方法,如果通过,不做任何操作,否则抛出异常\n */\nInterface.ensureImplement = function(object){\n    //  至少得实现一个接口\n    if(arguments.length &lt; 2){\n        throw new Error(&quot;Interface.ensureImplement \n    constructor arguments must be 2 \n        or more arguments!&quot;);\n    }\n    //  获得接口实例对象\n    for(var i = 1,len = arguments.length;\n    i &lt; len;i ++){\n        var instanceInterface = arguments[i];\n        //  判断参数是否为接口类的\n        if(!(instanceInterface instanceof Interface))\n        {\n            throw new Error(&quot;the arguments&quot; + \n            instanceInterface + &quot;is \n            not an instance of Interface Class&quot;);\n        }\n        //  循环接口实例对象里面的每个方法\n        for(var j = 0,l = instanceInterface.methods.length;\n         j &lt; l;j ++){\n            var methodName = \n            instanceInterface.methods[j];\n            //  接收每个方法的名字(字符串)\n            if(!arguments[0][methodName] || \n    typeof arguments[0][methodName] !== &quot;function&quot;)\n    {\n                throw new Error(&quot;the method &quot;+ \n                methodName +&quot; is not found&quot;);\n            }\n            //  不存在或者不是方法类型\n        }\n    }\n};\n\n//  实例化接口对象\nvar CompsiteInterface = new Interface(&quot;CompsiteInterface&quot;,\n[&quot;add&quot;,&quot;remove&quot;]),\nFormInteInterface = new \nInterface(&quot;FormInteInterface&quot;,\n[&quot;update&quot;,&quot;select&quot;]);\n\n/**\n *\n * @constructor\n * 接口类\n */\nfunction CompsiteImpl(){\n}\n//  实现接口\nCompsiteImpl.prototype = {\n    &quot;constructor&quot;:CompsiteImpl,\n    add:function(){\n        console.log(&quot;add 方法&quot;);\n    },\n    remove:function(){},\n    update:function(){},\n    select:function(){}\n};\n\n//  检验接口里的方法\nvar c1 = new CompsiteImpl\n(c1,CompsiteInterface,FormInteInterface);\n\nInterface.ensureImplement\n(c1,CompsiteInterface,FormInteInterface);\n\nc1.add();\n</code></pre><p>此方法就是目前最经典的一种方法，从上面的代码中可以看出，在这里完全采用的是面向对象的方法，通过实例化两个接口对象来声明需要实现的方法，最后实例化我们真正需要需要实例化的对象c1,通过Interface下的静态方法来判断是否已经实现全部接口，如果有一个没被实现则会看到具体是哪个没被实现，并且终止代码的继续运行，且耦合度较低。</p>\n<p>接口的好处主要是提高了系统相似模块的重用性，使得不同类的通信更加稳固。一旦实现接口，则必须实现接口中所有的方法。在大型系统中，接口的益处是显而易见的，但是如果在一个小的web系统中使用接口就显得画蛇添足了。</p>\n","excerpt":"","more":"<p>接口:</p>\n<p>接口是提供了一种用以说明一个对象应该具有哪些方法的手段，但它并不规定这些方法应该如何实现。在JS中，没有像其他面向对象程序语言的interface关键字，所以实现的方法也语言不同；JS实现接口的主要方式主要为定义描述法、属性检测法和鸭式辨型法，其中鸭式辨型法是目前用的最多的。</p>\n<p>1、定义描述法</p>\n<pre><code>/**\n *  interface CompsiteImpl{\n *      function add();\n *      function remove();\n *      function update();\n *  }\n */\n\n/**\n * 实现接口\n * @constructor\n */\nfunction CompsiteImpl(){\n}\n\nCompsiteImpl.prototype = {\n    &quot;constructor&quot;:CompsiteImpl,\n    &quot;add&quot;:function(){\n        console.log(&quot;我是add方法！&quot;);\n    },\n    &quot;remove&quot;:function(){\n        console.log(&quot;我是remove方法！&quot;);\n    },\n    &quot;update&quot;:function(){\n        console.log(&quot;我是update方法！&quot;);\n    }\n};\n</code></pre><p>此方法也称注释法，顾名思义，就是通过一系列的注释来定义该类需要实现哪些接口方法，这是最简单定义接口的一种方法。但是此方法缺点实在太明显了，比如一个人代码写完了，他只能通过肉眼来判断是不是都把刚才注释里面的方法都实现了；他哪天代码做修改了，是否和注释一致等等的。只是属于一个类似于帮助文档的范畴，太死板。</p>\n<p>2、属性检测法</p>\n<pre><code>/**\n *  interface Compsite{\n *      function add();\n *      function remove();\n *      function update();\n *  }\n *\n *  interface FormItem{\n *      function select();\n *  }\n *\n */\n\n//  实现接口\n//  需要实现 Compsite FormItem\nfunction CompsiteImpl(){\n    //  在类的内部定义一个变量\n    this.implementsInterface = [&quot;Compsite&quot;,&quot;FormItem&quot;];\n}\n\nCompsiteImpl.prototype = {\n    &quot;constructor&quot;:CompsiteImpl,\n    &quot;add&quot;:function(){\n        console.log(&quot;add 方法&quot;);\n    },\n    &quot;remove&quot;:function(){\n        console.log(&quot;remove 方法&quot;);\n    },\n    &quot;update&quot;:function(){\n        console.log(&quot;remove 方法&quot;);},\n    &quot;select&quot;:function(){\n        console.log(&quot;select 方法&quot;);\n    }\n};\n\n/**\n *\n * @param instance\n *\n * 检测类的方法\n */\nfunction checkCompsiteImpl(instance){\n    //  判断当前对象是否实现了所有的接口\n    if(!isImplements(instance,&quot;Compsite&quot;,&quot;FormItem&quot;))\n    {\n        throw new Error(&quot;object does not implement \n            a required interface&quot;);\n    }\n}\n\n/**\n *\n * @param object\n *\n * 公共的、具体的检测方法(核心方法)\n */\nfunction isImplements(object){\n    for(var i = 1,l = arguments.length;\n    i &lt; l;i ++){\n        var interfaceName = arguments[i],\n            interfaceFound = false;\n        for(var j = 0,\n            len = object.implementsInterface.length;\n        j &lt; len;j ++)\n        {\n            if(object.implementsInterface[j] ==\n         interfaceName){\n                interfaceFound = true;\n            }\n        }\n        if(!interfaceFound){\n            return false;\n        }\n        return true;\n    }\n}\n\nvar c1 = new CompsiteImpl();\ncheckCompsiteImpl(c1);\nc1.add();\n</code></pre><p>这种方法相对来说高级一点了，如果有一个接口没有没实现，会看到一个错误，代码不往下继续走了。但缺点在于仍无法判断是否真正实现了对应的接口方法，仅仅只是”自称”实现了接口，同时这种方法耦合性也比较高，放到另外一个地方可能就需要进行修改才能复用。</p>\n<p>3、鸭式辨型法</p>\n<pre><code>/**\n *\n * @param name      接口名,字符串\n * @param methods   需要实现的方法,接收方法的集合、数组\n * @constructor\n * 接口类\n */\nfunction Interface(name,methods){\n    //  判断接口的参数个数\n    if(arguments.length != 2){\n        throw new Error(&quot;this instance interface \n        constructor required 2 arguments!&quot;);\n    }\n    this.name = name;\n    this.methods = [];\n    //  定义一个空数组,等待接收methods里面的方法名\n    for(var i = 0,len = methods.length; i &lt; len; i ++){\n        if(typeof methods[i] !== &quot;string&quot;){\n            throw new Error(&quot;the Instance method name\n             is error!&quot;);\n        }\n        this.methods.push(methods[i]);\n    }\n}\n\n/**\n *\n * @param object\n *\n * 检验方法,如果通过,不做任何操作,否则抛出异常\n */\nInterface.ensureImplement = function(object){\n    //  至少得实现一个接口\n    if(arguments.length &lt; 2){\n        throw new Error(&quot;Interface.ensureImplement \n    constructor arguments must be 2 \n        or more arguments!&quot;);\n    }\n    //  获得接口实例对象\n    for(var i = 1,len = arguments.length;\n    i &lt; len;i ++){\n        var instanceInterface = arguments[i];\n        //  判断参数是否为接口类的\n        if(!(instanceInterface instanceof Interface))\n        {\n            throw new Error(&quot;the arguments&quot; + \n            instanceInterface + &quot;is \n            not an instance of Interface Class&quot;);\n        }\n        //  循环接口实例对象里面的每个方法\n        for(var j = 0,l = instanceInterface.methods.length;\n         j &lt; l;j ++){\n            var methodName = \n            instanceInterface.methods[j];\n            //  接收每个方法的名字(字符串)\n            if(!arguments[0][methodName] || \n    typeof arguments[0][methodName] !== &quot;function&quot;)\n    {\n                throw new Error(&quot;the method &quot;+ \n                methodName +&quot; is not found&quot;);\n            }\n            //  不存在或者不是方法类型\n        }\n    }\n};\n\n//  实例化接口对象\nvar CompsiteInterface = new Interface(&quot;CompsiteInterface&quot;,\n[&quot;add&quot;,&quot;remove&quot;]),\nFormInteInterface = new \nInterface(&quot;FormInteInterface&quot;,\n[&quot;update&quot;,&quot;select&quot;]);\n\n/**\n *\n * @constructor\n * 接口类\n */\nfunction CompsiteImpl(){\n}\n//  实现接口\nCompsiteImpl.prototype = {\n    &quot;constructor&quot;:CompsiteImpl,\n    add:function(){\n        console.log(&quot;add 方法&quot;);\n    },\n    remove:function(){},\n    update:function(){},\n    select:function(){}\n};\n\n//  检验接口里的方法\nvar c1 = new CompsiteImpl\n(c1,CompsiteInterface,FormInteInterface);\n\nInterface.ensureImplement\n(c1,CompsiteInterface,FormInteInterface);\n\nc1.add();\n</code></pre><p>此方法就是目前最经典的一种方法，从上面的代码中可以看出，在这里完全采用的是面向对象的方法，通过实例化两个接口对象来声明需要实现的方法，最后实例化我们真正需要需要实例化的对象c1,通过Interface下的静态方法来判断是否已经实现全部接口，如果有一个没被实现则会看到具体是哪个没被实现，并且终止代码的继续运行，且耦合度较低。</p>\n<p>接口的好处主要是提高了系统相似模块的重用性，使得不同类的通信更加稳固。一旦实现接口，则必须实现接口中所有的方法。在大型系统中，接口的益处是显而易见的，但是如果在一个小的web系统中使用接口就显得画蛇添足了。</p>\n"},{"layout":"post","title":"javascript桥梁模式","date":"2015-06-02T16:00:00.000Z","_content":"\n桥模式:\n\n桥梁模式可以用来弱化它与使用它的类和对象之间的耦合，就是将抽象与其实现隔离开来，以便二者独立变化；这种模式对于JavaScript中常见的时间驱动的编程有很大益处，桥梁模式最常见和实际的应用场合之一是时间监听器回调函数。\n\n可能我们平时写代码就用到了桥模式，比如看下面的例子：\n\n    var btn = document.getElementById(\"btn\");\n    \n    btn.onclick = function(){\n\t   bridgeHandle();\n    }\n\n    function bridgeHandle(){\n        var msg = btn.value;\n        sendRequest(msg);\n    }\n\n    // 这里情况，比如ajax请求\n    function sendRequest(msg){\n        console.log(msg);\n    }\n\n在上面的代码中，bridgeHandle就是一个桥梁，原来的sendRequest应该可以写在onclick事件里面，那么这样的写法有什么好处呢？个人认为有以下几点。\n\n1、 实现解耦：把原来要通过点击来触发的逻辑代码抽离出来，成为一个单独的部分；     \n2、方便做单元测试：我们可以单独调用sendRequest方法来测试ajax请求(假设)的返回等是否是我们预期的；   \n3、功能模块化，符合现在前端发展的趋势，便于自己和他人维护。\n\n\n 在桥模式中，还有一个概念叫“特权函数”，我们都知道在面向对象程序设计中，类的私有成员变量或者私有方法是不能被外部访问或者调用的，但是特权函数给我们提供了这一方便的接口。\n\n\tfunction PublicClass(){\n\t    var name = \"张三\";\n\t    //  私有属性\n\t\n\t    this.getter = function(){\n\t        return name;\n\t    };\n\t    //  访问私有属性getter,特权函数\n\t\n\t    function _privateMethod(){\n\t        return \"我是私有方法！\";\n\t    }\n\t\n\t    this.bridgeMethod = function(){\n\t        return privateMethod();\n\t    };\n\t\n\t}\n\t\n\tvar class = new PublicClass();\n\tconsole.log(class.getter());\t//\t张三\n\tconsole.log(class.bridgeMethod());\t//\t我是私有方法！\n\n在上面的例子中，PublicClass中有name这个私有成员变量和_privateMethod这个私有方法，如果在没有特权函数的情况下我们是不能访问和调用的的，但是通过模式，我们就完成了对私有成员变量和私有方法的访问和调用。\n\n桥模式也可以把多个单元组织在一起，再看下面：\n\n    function Class1(a,b,c){\n        this.a = a;\n        this.b = b;\n        this.c = c;\n    }\n    //\t第一个class\n\n    function Class2(d,e){\n        this.d = d;\n        this.e = e;\n    }\n    //\t第二个class\n\n    function BridgeClass(a,b,c,d,e){\n        this.class1 = new Class1(a,b,c);\n        this.class2 = new Class2(d,e);\n    }\n\n假设Class1和Class2都实现了比较复杂的逻辑，在其他一个class中我们需要这个类的实例，这时候，就可以像上面的例子一样，定义一个BridgeClass，传入Class1和Class2需要的参数，分别实例化，作为自己的属性。这样就完成了不同单元的组织。","source":"_posts/2015-06-03-js-design-mode-bridge.md","raw":"---\nlayout: post\ntitle: javascript桥梁模式\ndate: 2015-06-03\ncategories: [javascript, 设计模式]\n---\n\n桥模式:\n\n桥梁模式可以用来弱化它与使用它的类和对象之间的耦合，就是将抽象与其实现隔离开来，以便二者独立变化；这种模式对于JavaScript中常见的时间驱动的编程有很大益处，桥梁模式最常见和实际的应用场合之一是时间监听器回调函数。\n\n可能我们平时写代码就用到了桥模式，比如看下面的例子：\n\n    var btn = document.getElementById(\"btn\");\n    \n    btn.onclick = function(){\n\t   bridgeHandle();\n    }\n\n    function bridgeHandle(){\n        var msg = btn.value;\n        sendRequest(msg);\n    }\n\n    // 这里情况，比如ajax请求\n    function sendRequest(msg){\n        console.log(msg);\n    }\n\n在上面的代码中，bridgeHandle就是一个桥梁，原来的sendRequest应该可以写在onclick事件里面，那么这样的写法有什么好处呢？个人认为有以下几点。\n\n1、 实现解耦：把原来要通过点击来触发的逻辑代码抽离出来，成为一个单独的部分；     \n2、方便做单元测试：我们可以单独调用sendRequest方法来测试ajax请求(假设)的返回等是否是我们预期的；   \n3、功能模块化，符合现在前端发展的趋势，便于自己和他人维护。\n\n\n 在桥模式中，还有一个概念叫“特权函数”，我们都知道在面向对象程序设计中，类的私有成员变量或者私有方法是不能被外部访问或者调用的，但是特权函数给我们提供了这一方便的接口。\n\n\tfunction PublicClass(){\n\t    var name = \"张三\";\n\t    //  私有属性\n\t\n\t    this.getter = function(){\n\t        return name;\n\t    };\n\t    //  访问私有属性getter,特权函数\n\t\n\t    function _privateMethod(){\n\t        return \"我是私有方法！\";\n\t    }\n\t\n\t    this.bridgeMethod = function(){\n\t        return privateMethod();\n\t    };\n\t\n\t}\n\t\n\tvar class = new PublicClass();\n\tconsole.log(class.getter());\t//\t张三\n\tconsole.log(class.bridgeMethod());\t//\t我是私有方法！\n\n在上面的例子中，PublicClass中有name这个私有成员变量和_privateMethod这个私有方法，如果在没有特权函数的情况下我们是不能访问和调用的的，但是通过模式，我们就完成了对私有成员变量和私有方法的访问和调用。\n\n桥模式也可以把多个单元组织在一起，再看下面：\n\n    function Class1(a,b,c){\n        this.a = a;\n        this.b = b;\n        this.c = c;\n    }\n    //\t第一个class\n\n    function Class2(d,e){\n        this.d = d;\n        this.e = e;\n    }\n    //\t第二个class\n\n    function BridgeClass(a,b,c,d,e){\n        this.class1 = new Class1(a,b,c);\n        this.class2 = new Class2(d,e);\n    }\n\n假设Class1和Class2都实现了比较复杂的逻辑，在其他一个class中我们需要这个类的实例，这时候，就可以像上面的例子一样，定义一个BridgeClass，传入Class1和Class2需要的参数，分别实例化，作为自己的属性。这样就完成了不同单元的组织。","slug":"2015-06-03-js-design-mode-bridge","published":1,"updated":"2016-11-09T14:00:24.000Z","_id":"civ7fseef000ct95fxbhf80y0","comments":1,"photos":[],"link":"","content":"<p>桥模式:</p>\n<p>桥梁模式可以用来弱化它与使用它的类和对象之间的耦合，就是将抽象与其实现隔离开来，以便二者独立变化；这种模式对于JavaScript中常见的时间驱动的编程有很大益处，桥梁模式最常见和实际的应用场合之一是时间监听器回调函数。</p>\n<p>可能我们平时写代码就用到了桥模式，比如看下面的例子：</p>\n<pre><code>var btn = document.getElementById(&quot;btn&quot;);\n\nbtn.onclick = function(){\n   bridgeHandle();\n}\n\nfunction bridgeHandle(){\n    var msg = btn.value;\n    sendRequest(msg);\n}\n\n// 这里情况，比如ajax请求\nfunction sendRequest(msg){\n    console.log(msg);\n}\n</code></pre><p>在上面的代码中，bridgeHandle就是一个桥梁，原来的sendRequest应该可以写在onclick事件里面，那么这样的写法有什么好处呢？个人认为有以下几点。</p>\n<p>1、 实现解耦：把原来要通过点击来触发的逻辑代码抽离出来，成为一个单独的部分；<br>2、方便做单元测试：我们可以单独调用sendRequest方法来测试ajax请求(假设)的返回等是否是我们预期的；<br>3、功能模块化，符合现在前端发展的趋势，便于自己和他人维护。</p>\n<p> 在桥模式中，还有一个概念叫“特权函数”，我们都知道在面向对象程序设计中，类的私有成员变量或者私有方法是不能被外部访问或者调用的，但是特权函数给我们提供了这一方便的接口。</p>\n<pre><code>function PublicClass(){\n    var name = &quot;张三&quot;;\n    //  私有属性\n\n    this.getter = function(){\n        return name;\n    };\n    //  访问私有属性getter,特权函数\n\n    function _privateMethod(){\n        return &quot;我是私有方法！&quot;;\n    }\n\n    this.bridgeMethod = function(){\n        return privateMethod();\n    };\n\n}\n\nvar class = new PublicClass();\nconsole.log(class.getter());    //    张三\nconsole.log(class.bridgeMethod());    //    我是私有方法！\n</code></pre><p>在上面的例子中，PublicClass中有name这个私有成员变量和_privateMethod这个私有方法，如果在没有特权函数的情况下我们是不能访问和调用的的，但是通过模式，我们就完成了对私有成员变量和私有方法的访问和调用。</p>\n<p>桥模式也可以把多个单元组织在一起，再看下面：</p>\n<pre><code>function Class1(a,b,c){\n    this.a = a;\n    this.b = b;\n    this.c = c;\n}\n//    第一个class\n\nfunction Class2(d,e){\n    this.d = d;\n    this.e = e;\n}\n//    第二个class\n\nfunction BridgeClass(a,b,c,d,e){\n    this.class1 = new Class1(a,b,c);\n    this.class2 = new Class2(d,e);\n}\n</code></pre><p>假设Class1和Class2都实现了比较复杂的逻辑，在其他一个class中我们需要这个类的实例，这时候，就可以像上面的例子一样，定义一个BridgeClass，传入Class1和Class2需要的参数，分别实例化，作为自己的属性。这样就完成了不同单元的组织。</p>\n","excerpt":"","more":"<p>桥模式:</p>\n<p>桥梁模式可以用来弱化它与使用它的类和对象之间的耦合，就是将抽象与其实现隔离开来，以便二者独立变化；这种模式对于JavaScript中常见的时间驱动的编程有很大益处，桥梁模式最常见和实际的应用场合之一是时间监听器回调函数。</p>\n<p>可能我们平时写代码就用到了桥模式，比如看下面的例子：</p>\n<pre><code>var btn = document.getElementById(&quot;btn&quot;);\n\nbtn.onclick = function(){\n   bridgeHandle();\n}\n\nfunction bridgeHandle(){\n    var msg = btn.value;\n    sendRequest(msg);\n}\n\n// 这里情况，比如ajax请求\nfunction sendRequest(msg){\n    console.log(msg);\n}\n</code></pre><p>在上面的代码中，bridgeHandle就是一个桥梁，原来的sendRequest应该可以写在onclick事件里面，那么这样的写法有什么好处呢？个人认为有以下几点。</p>\n<p>1、 实现解耦：把原来要通过点击来触发的逻辑代码抽离出来，成为一个单独的部分；<br>2、方便做单元测试：我们可以单独调用sendRequest方法来测试ajax请求(假设)的返回等是否是我们预期的；<br>3、功能模块化，符合现在前端发展的趋势，便于自己和他人维护。</p>\n<p> 在桥模式中，还有一个概念叫“特权函数”，我们都知道在面向对象程序设计中，类的私有成员变量或者私有方法是不能被外部访问或者调用的，但是特权函数给我们提供了这一方便的接口。</p>\n<pre><code>function PublicClass(){\n    var name = &quot;张三&quot;;\n    //  私有属性\n\n    this.getter = function(){\n        return name;\n    };\n    //  访问私有属性getter,特权函数\n\n    function _privateMethod(){\n        return &quot;我是私有方法！&quot;;\n    }\n\n    this.bridgeMethod = function(){\n        return privateMethod();\n    };\n\n}\n\nvar class = new PublicClass();\nconsole.log(class.getter());    //    张三\nconsole.log(class.bridgeMethod());    //    我是私有方法！\n</code></pre><p>在上面的例子中，PublicClass中有name这个私有成员变量和_privateMethod这个私有方法，如果在没有特权函数的情况下我们是不能访问和调用的的，但是通过模式，我们就完成了对私有成员变量和私有方法的访问和调用。</p>\n<p>桥模式也可以把多个单元组织在一起，再看下面：</p>\n<pre><code>function Class1(a,b,c){\n    this.a = a;\n    this.b = b;\n    this.c = c;\n}\n//    第一个class\n\nfunction Class2(d,e){\n    this.d = d;\n    this.e = e;\n}\n//    第二个class\n\nfunction BridgeClass(a,b,c,d,e){\n    this.class1 = new Class1(a,b,c);\n    this.class2 = new Class2(d,e);\n}\n</code></pre><p>假设Class1和Class2都实现了比较复杂的逻辑，在其他一个class中我们需要这个类的实例，这时候，就可以像上面的例子一样，定义一个BridgeClass，传入Class1和Class2需要的参数，分别实例化，作为自己的属性。这样就完成了不同单元的组织。</p>\n"},{"layout":"post","title":"javascript适配器模式","date":"2015-06-12T16:00:00.000Z","_content":"\n适配器模式:\n\n适配器,顾名思义,我们生活中能见到很多这样的例子,举个最简单的例子吧:\n我现在有一台老台式机电脑和刚买的新式电脑,我们都知道,老台式机上的插口都是圆口(F32型插口),而新式电脑上的都是USB插口,假如我现在想在新式电脑上用老式电脑上的那个鼠标,但是插口又不一样,那怎么办呢？我们现在就需要一个转换器来中转,这个转换器就完成了完成由老到新的转换功能。\n\n\n再举个实际开发中可能会遇到情况:比如公司新进一批前端,然后公司急于做一个项目,需要这几个前端一起参与才能按时交工,但是这几个前端里面有的会prototype.js不会YUI,然后有的会YUI不会prototype.js,而产品经理最后说采取YUI,由于项目时间比较紧,所以没那么大的成本来给他们把这两个库都培训一遍,这时候问题来了,怎么样让这些人都参与到开发中来呢？且看下面的模拟:\n\n我们来模拟一个最简单的选择器\n\n\n    //  模拟prototype $ function(不需要传递任何的形参,直接通过arguments对象取得传入的实参)\n    function $(){\n        var ele = [];\n        for(var i = 0;i < arguments.length;i ++){\n            var el = arguments[i];\n            if(typeof el === \"string\"){\n                el = document.getElementById(el);\n            }\n            if(el.length == 1){\n                return el;\n            }\n            ele.push(el);\n        }\n        return ele;\n    }\n    \n    //  模拟YUI中的get (必须传递一个参数,不是字符串就是数组)\n    var YAHOO = {};\n    YAHOO.get = function(el){\n        if(typeof el === \"string\"){\n            return document.getElementById(el);\n        }else if(el instanceof Array){\n            var ele = [];\n            for(var i = 0;i < el.length;i ++){\n                  ele[ele.length] = YAHOO.get(el[i]);\n            }\n            return ele;\n        }else if(el){\n            return el;\n        }else{\n            return null;\n        }\n    };\n    \n    //  适配器方法\n        function YUIToPrototypeAdapter(){\n            //  YUI开发永远传递一个参数\n            if(arguments.length == 1){\n                //  YUI方案\n                var e = arguments[0];\n                return $.apply(window,e instanceof  Array ? e : new Array(e));\n            }else{\n                //  prototype处理方案\n                return $.apply(window,arguments);\n            }\n        }\n\n        YAHOO.get = YUIToPrototypeAdapter;\n\n        window.onload = function(){\n            //  $(\"div1\",\"div2\")            prototype风格\n            //  YAHOO.get([\"div1\",\"div2\"])  YUI风格\n            console.log($(\"div1\",\"div2\"));\n            console.log(YAHOO.get([\"div1\",\"div2\"]));\n        };\n    \n\n\n这边的YUIToPrototypeAdapter就是一个适配器方法,根据传入参数类型的不同采取不同的方案处理,相对完美的解决了框架间的适配问题。","source":"_posts/2015-06-13-js-design-mode-adoptor.md","raw":"---\nlayout: post\ntitle: javascript适配器模式\ndate: 2015-06-13\ncategories: [javascript, 设计模式]\n---\n\n适配器模式:\n\n适配器,顾名思义,我们生活中能见到很多这样的例子,举个最简单的例子吧:\n我现在有一台老台式机电脑和刚买的新式电脑,我们都知道,老台式机上的插口都是圆口(F32型插口),而新式电脑上的都是USB插口,假如我现在想在新式电脑上用老式电脑上的那个鼠标,但是插口又不一样,那怎么办呢？我们现在就需要一个转换器来中转,这个转换器就完成了完成由老到新的转换功能。\n\n\n再举个实际开发中可能会遇到情况:比如公司新进一批前端,然后公司急于做一个项目,需要这几个前端一起参与才能按时交工,但是这几个前端里面有的会prototype.js不会YUI,然后有的会YUI不会prototype.js,而产品经理最后说采取YUI,由于项目时间比较紧,所以没那么大的成本来给他们把这两个库都培训一遍,这时候问题来了,怎么样让这些人都参与到开发中来呢？且看下面的模拟:\n\n我们来模拟一个最简单的选择器\n\n\n    //  模拟prototype $ function(不需要传递任何的形参,直接通过arguments对象取得传入的实参)\n    function $(){\n        var ele = [];\n        for(var i = 0;i < arguments.length;i ++){\n            var el = arguments[i];\n            if(typeof el === \"string\"){\n                el = document.getElementById(el);\n            }\n            if(el.length == 1){\n                return el;\n            }\n            ele.push(el);\n        }\n        return ele;\n    }\n    \n    //  模拟YUI中的get (必须传递一个参数,不是字符串就是数组)\n    var YAHOO = {};\n    YAHOO.get = function(el){\n        if(typeof el === \"string\"){\n            return document.getElementById(el);\n        }else if(el instanceof Array){\n            var ele = [];\n            for(var i = 0;i < el.length;i ++){\n                  ele[ele.length] = YAHOO.get(el[i]);\n            }\n            return ele;\n        }else if(el){\n            return el;\n        }else{\n            return null;\n        }\n    };\n    \n    //  适配器方法\n        function YUIToPrototypeAdapter(){\n            //  YUI开发永远传递一个参数\n            if(arguments.length == 1){\n                //  YUI方案\n                var e = arguments[0];\n                return $.apply(window,e instanceof  Array ? e : new Array(e));\n            }else{\n                //  prototype处理方案\n                return $.apply(window,arguments);\n            }\n        }\n\n        YAHOO.get = YUIToPrototypeAdapter;\n\n        window.onload = function(){\n            //  $(\"div1\",\"div2\")            prototype风格\n            //  YAHOO.get([\"div1\",\"div2\"])  YUI风格\n            console.log($(\"div1\",\"div2\"));\n            console.log(YAHOO.get([\"div1\",\"div2\"]));\n        };\n    \n\n\n这边的YUIToPrototypeAdapter就是一个适配器方法,根据传入参数类型的不同采取不同的方案处理,相对完美的解决了框架间的适配问题。","slug":"2015-06-13-js-design-mode-adoptor","published":1,"updated":"2016-11-09T14:00:39.000Z","_id":"civ7fseeg000et95fbvvtd990","comments":1,"photos":[],"link":"","content":"<p>适配器模式:</p>\n<p>适配器,顾名思义,我们生活中能见到很多这样的例子,举个最简单的例子吧:<br>我现在有一台老台式机电脑和刚买的新式电脑,我们都知道,老台式机上的插口都是圆口(F32型插口),而新式电脑上的都是USB插口,假如我现在想在新式电脑上用老式电脑上的那个鼠标,但是插口又不一样,那怎么办呢？我们现在就需要一个转换器来中转,这个转换器就完成了完成由老到新的转换功能。</p>\n<p>再举个实际开发中可能会遇到情况:比如公司新进一批前端,然后公司急于做一个项目,需要这几个前端一起参与才能按时交工,但是这几个前端里面有的会prototype.js不会YUI,然后有的会YUI不会prototype.js,而产品经理最后说采取YUI,由于项目时间比较紧,所以没那么大的成本来给他们把这两个库都培训一遍,这时候问题来了,怎么样让这些人都参与到开发中来呢？且看下面的模拟:</p>\n<p>我们来模拟一个最简单的选择器</p>\n<pre><code>//  模拟prototype $ function(不需要传递任何的形参,直接通过arguments对象取得传入的实参)\nfunction $(){\n    var ele = [];\n    for(var i = 0;i &lt; arguments.length;i ++){\n        var el = arguments[i];\n        if(typeof el === &quot;string&quot;){\n            el = document.getElementById(el);\n        }\n        if(el.length == 1){\n            return el;\n        }\n        ele.push(el);\n    }\n    return ele;\n}\n\n//  模拟YUI中的get (必须传递一个参数,不是字符串就是数组)\nvar YAHOO = {};\nYAHOO.get = function(el){\n    if(typeof el === &quot;string&quot;){\n        return document.getElementById(el);\n    }else if(el instanceof Array){\n        var ele = [];\n        for(var i = 0;i &lt; el.length;i ++){\n              ele[ele.length] = YAHOO.get(el[i]);\n        }\n        return ele;\n    }else if(el){\n        return el;\n    }else{\n        return null;\n    }\n};\n\n//  适配器方法\n    function YUIToPrototypeAdapter(){\n        //  YUI开发永远传递一个参数\n        if(arguments.length == 1){\n            //  YUI方案\n            var e = arguments[0];\n            return $.apply(window,e instanceof  Array ? e : new Array(e));\n        }else{\n            //  prototype处理方案\n            return $.apply(window,arguments);\n        }\n    }\n\n    YAHOO.get = YUIToPrototypeAdapter;\n\n    window.onload = function(){\n        //  $(&quot;div1&quot;,&quot;div2&quot;)            prototype风格\n        //  YAHOO.get([&quot;div1&quot;,&quot;div2&quot;])  YUI风格\n        console.log($(&quot;div1&quot;,&quot;div2&quot;));\n        console.log(YAHOO.get([&quot;div1&quot;,&quot;div2&quot;]));\n    };\n</code></pre><p>这边的YUIToPrototypeAdapter就是一个适配器方法,根据传入参数类型的不同采取不同的方案处理,相对完美的解决了框架间的适配问题。</p>\n","excerpt":"","more":"<p>适配器模式:</p>\n<p>适配器,顾名思义,我们生活中能见到很多这样的例子,举个最简单的例子吧:<br>我现在有一台老台式机电脑和刚买的新式电脑,我们都知道,老台式机上的插口都是圆口(F32型插口),而新式电脑上的都是USB插口,假如我现在想在新式电脑上用老式电脑上的那个鼠标,但是插口又不一样,那怎么办呢？我们现在就需要一个转换器来中转,这个转换器就完成了完成由老到新的转换功能。</p>\n<p>再举个实际开发中可能会遇到情况:比如公司新进一批前端,然后公司急于做一个项目,需要这几个前端一起参与才能按时交工,但是这几个前端里面有的会prototype.js不会YUI,然后有的会YUI不会prototype.js,而产品经理最后说采取YUI,由于项目时间比较紧,所以没那么大的成本来给他们把这两个库都培训一遍,这时候问题来了,怎么样让这些人都参与到开发中来呢？且看下面的模拟:</p>\n<p>我们来模拟一个最简单的选择器</p>\n<pre><code>//  模拟prototype $ function(不需要传递任何的形参,直接通过arguments对象取得传入的实参)\nfunction $(){\n    var ele = [];\n    for(var i = 0;i &lt; arguments.length;i ++){\n        var el = arguments[i];\n        if(typeof el === &quot;string&quot;){\n            el = document.getElementById(el);\n        }\n        if(el.length == 1){\n            return el;\n        }\n        ele.push(el);\n    }\n    return ele;\n}\n\n//  模拟YUI中的get (必须传递一个参数,不是字符串就是数组)\nvar YAHOO = {};\nYAHOO.get = function(el){\n    if(typeof el === &quot;string&quot;){\n        return document.getElementById(el);\n    }else if(el instanceof Array){\n        var ele = [];\n        for(var i = 0;i &lt; el.length;i ++){\n              ele[ele.length] = YAHOO.get(el[i]);\n        }\n        return ele;\n    }else if(el){\n        return el;\n    }else{\n        return null;\n    }\n};\n\n//  适配器方法\n    function YUIToPrototypeAdapter(){\n        //  YUI开发永远传递一个参数\n        if(arguments.length == 1){\n            //  YUI方案\n            var e = arguments[0];\n            return $.apply(window,e instanceof  Array ? e : new Array(e));\n        }else{\n            //  prototype处理方案\n            return $.apply(window,arguments);\n        }\n    }\n\n    YAHOO.get = YUIToPrototypeAdapter;\n\n    window.onload = function(){\n        //  $(&quot;div1&quot;,&quot;div2&quot;)            prototype风格\n        //  YAHOO.get([&quot;div1&quot;,&quot;div2&quot;])  YUI风格\n        console.log($(&quot;div1&quot;,&quot;div2&quot;));\n        console.log(YAHOO.get([&quot;div1&quot;,&quot;div2&quot;]));\n    };\n</code></pre><p>这边的YUIToPrototypeAdapter就是一个适配器方法,根据传入参数类型的不同采取不同的方案处理,相对完美的解决了框架间的适配问题。</p>\n"},{"layout":"post","title":"javascript组合模式","date":"2015-06-08T16:00:00.000Z","_content":"\n组合模式:\n\n在组合模式中，对象有两种形式，一种是叶子对象，一种是组合对象，其中组合对象是叶子对象的组成，有时候我们需要通过简单的控制来完成工作，组合模式就派上了用场。\n\n下面我们模拟一个场景，模拟公司内部的一个，上级(组合对象)只要交代给部门领导(组合对象)，再由部门领导交付具体的指令给具体的员工(叶子对象)来完成具体的工作。\n\n\n先来看看传统的做法：\n\n    /**\n      *\n      * 公司类\n      **/\n    function Org(name){\n        this.name = name;\n        this.depts = [];\n    }\n    Org.prototype = {\n        \"constructor\":Org,\n        \"addDepts\":function(child){\n            this.depts.push(child);\n            return this;\n            //  添加部门,return this 提供链式调用\n        },\n        \"getDepts\":function(){\n            return this.depts;\n            //  获取部门\n        }\n    };\n\n    /**\n      *\n      * 部门类\n      **/\n    function Dept(name){\n        this.name = name;\n        this.persons = [];\n    }\n    Dept.prototype = {\n        \"constructor\":Dept,\n        \"addPersons\":function(child){\n            this.persons.push(child);\n            return this;\n            //  添加部门员工\n        },\n        \"getPersons\":function(){\n            return this.persons;\n            //  获取部门员工\n        }\n    };\n\n    /**\n      *\n      * 员工类\n      **/\n    function Person(name){\n        this.name = name;\n    }\n    commonUtil.wrap(Person.prototype,{\n        \"constructor\":Person,\n        \"hardWorking\":function(){\n            console.log(this.name + \" ... 努力工作！\");\n            //  xxx ... 努力工作\n        },\n        \"sleeping\":function(){\n            console.log(this.name + \"睡觉！\");\n            //  xxx 睡觉！\n        }\n    });\n\n    var p1 = new Person(\"张1\"),\n        p2 = new Person(\"张2\"),\n        p3 = new Person(\"张3\"),\n        p4 = new Person(\"张4\"),\n        p5 = new Person(\"张5\"),\n        p6 = new Person(\"张6\"),\n        dept1 = new Dept(\"开发\"),\n        dept2 = new Dept(\"销售\"),\n        org = new Org(\"某某公司\");\n    //  实例化对象    \n\n    dept1.addPersons(p1).addPersons(p2).addPersons(p3);\n    dept2.addPersons(p4).addPersons(p5).addPersons(p6);\n    org.addDepts(dept1).addDepts(dept2);\n    //  添加部门和部门员工\n    \n    for(var i = 0,depts = org.getDepts();i < depts.length;i ++){\n        for(j = 0,persons = depts[i].getPersons();j < persons.length;j ++){\n            if(persons[j][\"name\"] === \"张3\"){\n                persons[j].hardWorking();\n            }\n        }\n    }\n    //  具体的让张3努力工作\n    \n在上面的例子我们可以看到,如果想要\"张三\"这个人执行hardWorking方法，需要写两层循环，现在只是两层结构，要是在多层的情况下，可能就需要递归神马了，甚是麻烦。\n\n再来看看组合模式吧！这边的commomUtil下的方法和工厂模式里面的用的一样的。\n\n    var CompositeInterface = new commonUtil.Interface(\"CompositeInterface\",[\"addChild\",\"getChild\"]),\n    LeafInterface = new commonUtil.Interface(\"LeafInterface\",[\"hardWorking\",\"sleeping\"]);\n            //  定义组合对象和叶子对象需要实现的接口\n            \n    /**\n     * 组合对象\n     * @param name\n     * @constructor\n     */\n    function Composite(name){\n        this.name = name;\n        this.type = \"Composite\";\n        //  说明当前对象类型\n        this.children = [];\n        //  承装孩子（叶子节点）的数组\n    }\n    commonUtil.wrap(Composite.prototype,{\n        \"constructor\":Composite,\n        \"addChild\":function(child){\n            this.children.push(child);\n            return this;\n        },\n        \"getChild\":function(name){\n            var list = [],\n                pushLeaf = function(item){\n                    if(this.name === name || item[\"type\"] === \"Composite\"){\n                          item[\"children\"].each(arguments.callee);\n                         // pushLeaf(item[\"children\"]);\n                    }else if(item[\"type\"] === \"Leaf\") {\n                        list.push(item);\n                    }\n                };\n            if(name && this.name !== name){\n                //  返回指定类型的叶子对象\n                this.children.each(function(item){\n                    if(item[\"name\"] === name && item[\"type\"] === \"Composite\"){\n                        item[\"children\"].each(pushLeaf);\n                    }\n                    //  二级节点\n                    if(item[\"name\"] !== name && item[\"type\"] === \"Composite\"){\n                        item[\"children\"].each(arguments.callee);\n                    }\n                    //  三级、四级...\n                    if(item[\"name\"] === name && item[\"type\"] === \"Leaf\"){\n                        list.push(item);\n                    }\n                });\n            }else{\n                //  返回所有叶子对象\n                this.children.each(pushLeaf);\n            }\n            return list;\n        },\n        \"hardWorking\":function(name){\n            var leafObjects = this.getChild(name);\n            //  得到所有的叶子类型对象\n            for(var i = 0,l = leafObjects.length;i < l;i ++){\n                leafObjects[i] && leafObjects[i].hardWorking(leafObjects[i][\"name\"]);\n            }\n        },\n        \"sleeping\":function(name){\n            var leafObjects = this.getChild(name);\n            //  得到所有的叶子类型对象\n            for(var i = 0,l = leafObjects.length;i < l;i ++){\n                leafObjects[i].sleeping(leafObjects[i][\"name\"]);\n            }\n        }\n    });\n        \n    /**\n     * 叶子对象\n     * @param name\n     * @constructor\n     */\n    function Leaf(name){\n        this.name = name;\n        this.type = \"Leaf\";\n        //  说明当前对象类型\n    }\n    commonUtil.wrap(Leaf.prototype,{\n        \"constructor\":Leaf,\n        \"addChild\":function(child){\n            throw new Error(\"this method is disabled\");\n            //  叶子节点下没有添加子节点的方法,所以调用的时候抛异常\n        },\n        \"getChild\":function(name){\n            if(this.name === name){\n                return this;\n            }\n            return null;\n        },\n        \"hardWorking\":function(){\n            console.log(this.name + \" ... 努力工作！\");\n        },\n        \"sleeping\":function(name){\n            console.log(this.name + \" ... 睡觉！\");\n        }\n    });\n    \n    var p1 = new Leaf(\"张1\"),\n        p2 = new Leaf(\"张2\"),\n        p3 = new Leaf(\"张3\"),\n        p4 = new Leaf(\"张4\"),\n        p5 = new Leaf(\"张5\"),\n        p6 = new Leaf(\"张6\"),\n        p7 = new Leaf(\"张7\"),\n        p8 = new Leaf(\"张8\"),\n        p9 = new Leaf(\"张9\"),\n        p10 = new Leaf(\"张10\"),\n        p11 = new Leaf(\"张11\"),\n        p12 = new Leaf(\"张12\"),\n        dept1 = new Composite(\"南京开发部\"),\n        dept2 = new Composite(\"南京销售部\"),\n        dept3 = new Composite(\"杭州开发部\"),\n        dept4 = new Composite(\"杭州销售部\"),\n        org = new Composite(\"xx公司\"),\n        org2 = new Composite(\"南京分公司\"),\n        org3 = new Composite(\"杭州分公司\");\n        //  实例化一些对象\n\n        dept1.addChild(p1).addChild(p2).addChild(p3);\n        dept2.addChild(p4).addChild(p5).addChild(p6);\n        dept3.addChild(p7).addChild(p8).addChild(p9);\n        dept4.addChild(p10).addChild(p11).addChild(p12);\n        //  组装二级、三级、叶子节点\n\n        org2.addChild(dept1).addChild(dept2);\n        org3.addChild(dept3).addChild(dept4);\n        org.addChild(org2).addChild(org3);\n        //  组装分公司和总公司\n\n        org.hardWorking();  \n        //  总公司下面的人都执行hardWork方法\n        org.hardWorking(\"南京分公司\");  \n        //  南京分公司下面的人都执行hardWork方法\n        org.hardWorking(\"杭州开发部\");  \n        //  某级子节点(组合对象)下面的人都执行hardWork方法\n        org.hardWorking(\"张12\");  \n        //  具体某人执行hardWork方法\n        \n怎么样,看完这个例子是不是感觉比传统的调用方法简单多了,现在就2种类型的对象,虽然组合对象下封装的方法,只要传入具体的某个部门或者员工就能走它下面的方法;这么好的模式,何乐而不为？","source":"_posts/2015-06-09-js-design-mode-composite.md","raw":"---\nlayout: post\ntitle: javascript组合模式\ndate: 2015-06-09\ncategories: [javascript, 设计模式]\n---\n\n组合模式:\n\n在组合模式中，对象有两种形式，一种是叶子对象，一种是组合对象，其中组合对象是叶子对象的组成，有时候我们需要通过简单的控制来完成工作，组合模式就派上了用场。\n\n下面我们模拟一个场景，模拟公司内部的一个，上级(组合对象)只要交代给部门领导(组合对象)，再由部门领导交付具体的指令给具体的员工(叶子对象)来完成具体的工作。\n\n\n先来看看传统的做法：\n\n    /**\n      *\n      * 公司类\n      **/\n    function Org(name){\n        this.name = name;\n        this.depts = [];\n    }\n    Org.prototype = {\n        \"constructor\":Org,\n        \"addDepts\":function(child){\n            this.depts.push(child);\n            return this;\n            //  添加部门,return this 提供链式调用\n        },\n        \"getDepts\":function(){\n            return this.depts;\n            //  获取部门\n        }\n    };\n\n    /**\n      *\n      * 部门类\n      **/\n    function Dept(name){\n        this.name = name;\n        this.persons = [];\n    }\n    Dept.prototype = {\n        \"constructor\":Dept,\n        \"addPersons\":function(child){\n            this.persons.push(child);\n            return this;\n            //  添加部门员工\n        },\n        \"getPersons\":function(){\n            return this.persons;\n            //  获取部门员工\n        }\n    };\n\n    /**\n      *\n      * 员工类\n      **/\n    function Person(name){\n        this.name = name;\n    }\n    commonUtil.wrap(Person.prototype,{\n        \"constructor\":Person,\n        \"hardWorking\":function(){\n            console.log(this.name + \" ... 努力工作！\");\n            //  xxx ... 努力工作\n        },\n        \"sleeping\":function(){\n            console.log(this.name + \"睡觉！\");\n            //  xxx 睡觉！\n        }\n    });\n\n    var p1 = new Person(\"张1\"),\n        p2 = new Person(\"张2\"),\n        p3 = new Person(\"张3\"),\n        p4 = new Person(\"张4\"),\n        p5 = new Person(\"张5\"),\n        p6 = new Person(\"张6\"),\n        dept1 = new Dept(\"开发\"),\n        dept2 = new Dept(\"销售\"),\n        org = new Org(\"某某公司\");\n    //  实例化对象    \n\n    dept1.addPersons(p1).addPersons(p2).addPersons(p3);\n    dept2.addPersons(p4).addPersons(p5).addPersons(p6);\n    org.addDepts(dept1).addDepts(dept2);\n    //  添加部门和部门员工\n    \n    for(var i = 0,depts = org.getDepts();i < depts.length;i ++){\n        for(j = 0,persons = depts[i].getPersons();j < persons.length;j ++){\n            if(persons[j][\"name\"] === \"张3\"){\n                persons[j].hardWorking();\n            }\n        }\n    }\n    //  具体的让张3努力工作\n    \n在上面的例子我们可以看到,如果想要\"张三\"这个人执行hardWorking方法，需要写两层循环，现在只是两层结构，要是在多层的情况下，可能就需要递归神马了，甚是麻烦。\n\n再来看看组合模式吧！这边的commomUtil下的方法和工厂模式里面的用的一样的。\n\n    var CompositeInterface = new commonUtil.Interface(\"CompositeInterface\",[\"addChild\",\"getChild\"]),\n    LeafInterface = new commonUtil.Interface(\"LeafInterface\",[\"hardWorking\",\"sleeping\"]);\n            //  定义组合对象和叶子对象需要实现的接口\n            \n    /**\n     * 组合对象\n     * @param name\n     * @constructor\n     */\n    function Composite(name){\n        this.name = name;\n        this.type = \"Composite\";\n        //  说明当前对象类型\n        this.children = [];\n        //  承装孩子（叶子节点）的数组\n    }\n    commonUtil.wrap(Composite.prototype,{\n        \"constructor\":Composite,\n        \"addChild\":function(child){\n            this.children.push(child);\n            return this;\n        },\n        \"getChild\":function(name){\n            var list = [],\n                pushLeaf = function(item){\n                    if(this.name === name || item[\"type\"] === \"Composite\"){\n                          item[\"children\"].each(arguments.callee);\n                         // pushLeaf(item[\"children\"]);\n                    }else if(item[\"type\"] === \"Leaf\") {\n                        list.push(item);\n                    }\n                };\n            if(name && this.name !== name){\n                //  返回指定类型的叶子对象\n                this.children.each(function(item){\n                    if(item[\"name\"] === name && item[\"type\"] === \"Composite\"){\n                        item[\"children\"].each(pushLeaf);\n                    }\n                    //  二级节点\n                    if(item[\"name\"] !== name && item[\"type\"] === \"Composite\"){\n                        item[\"children\"].each(arguments.callee);\n                    }\n                    //  三级、四级...\n                    if(item[\"name\"] === name && item[\"type\"] === \"Leaf\"){\n                        list.push(item);\n                    }\n                });\n            }else{\n                //  返回所有叶子对象\n                this.children.each(pushLeaf);\n            }\n            return list;\n        },\n        \"hardWorking\":function(name){\n            var leafObjects = this.getChild(name);\n            //  得到所有的叶子类型对象\n            for(var i = 0,l = leafObjects.length;i < l;i ++){\n                leafObjects[i] && leafObjects[i].hardWorking(leafObjects[i][\"name\"]);\n            }\n        },\n        \"sleeping\":function(name){\n            var leafObjects = this.getChild(name);\n            //  得到所有的叶子类型对象\n            for(var i = 0,l = leafObjects.length;i < l;i ++){\n                leafObjects[i].sleeping(leafObjects[i][\"name\"]);\n            }\n        }\n    });\n        \n    /**\n     * 叶子对象\n     * @param name\n     * @constructor\n     */\n    function Leaf(name){\n        this.name = name;\n        this.type = \"Leaf\";\n        //  说明当前对象类型\n    }\n    commonUtil.wrap(Leaf.prototype,{\n        \"constructor\":Leaf,\n        \"addChild\":function(child){\n            throw new Error(\"this method is disabled\");\n            //  叶子节点下没有添加子节点的方法,所以调用的时候抛异常\n        },\n        \"getChild\":function(name){\n            if(this.name === name){\n                return this;\n            }\n            return null;\n        },\n        \"hardWorking\":function(){\n            console.log(this.name + \" ... 努力工作！\");\n        },\n        \"sleeping\":function(name){\n            console.log(this.name + \" ... 睡觉！\");\n        }\n    });\n    \n    var p1 = new Leaf(\"张1\"),\n        p2 = new Leaf(\"张2\"),\n        p3 = new Leaf(\"张3\"),\n        p4 = new Leaf(\"张4\"),\n        p5 = new Leaf(\"张5\"),\n        p6 = new Leaf(\"张6\"),\n        p7 = new Leaf(\"张7\"),\n        p8 = new Leaf(\"张8\"),\n        p9 = new Leaf(\"张9\"),\n        p10 = new Leaf(\"张10\"),\n        p11 = new Leaf(\"张11\"),\n        p12 = new Leaf(\"张12\"),\n        dept1 = new Composite(\"南京开发部\"),\n        dept2 = new Composite(\"南京销售部\"),\n        dept3 = new Composite(\"杭州开发部\"),\n        dept4 = new Composite(\"杭州销售部\"),\n        org = new Composite(\"xx公司\"),\n        org2 = new Composite(\"南京分公司\"),\n        org3 = new Composite(\"杭州分公司\");\n        //  实例化一些对象\n\n        dept1.addChild(p1).addChild(p2).addChild(p3);\n        dept2.addChild(p4).addChild(p5).addChild(p6);\n        dept3.addChild(p7).addChild(p8).addChild(p9);\n        dept4.addChild(p10).addChild(p11).addChild(p12);\n        //  组装二级、三级、叶子节点\n\n        org2.addChild(dept1).addChild(dept2);\n        org3.addChild(dept3).addChild(dept4);\n        org.addChild(org2).addChild(org3);\n        //  组装分公司和总公司\n\n        org.hardWorking();  \n        //  总公司下面的人都执行hardWork方法\n        org.hardWorking(\"南京分公司\");  \n        //  南京分公司下面的人都执行hardWork方法\n        org.hardWorking(\"杭州开发部\");  \n        //  某级子节点(组合对象)下面的人都执行hardWork方法\n        org.hardWorking(\"张12\");  \n        //  具体某人执行hardWork方法\n        \n怎么样,看完这个例子是不是感觉比传统的调用方法简单多了,现在就2种类型的对象,虽然组合对象下封装的方法,只要传入具体的某个部门或者员工就能走它下面的方法;这么好的模式,何乐而不为？","slug":"2015-06-09-js-design-mode-composite","published":1,"updated":"2016-11-09T14:00:33.000Z","_id":"civ7fseei000gt95fqforx0s2","comments":1,"photos":[],"link":"","content":"<p>组合模式:</p>\n<p>在组合模式中，对象有两种形式，一种是叶子对象，一种是组合对象，其中组合对象是叶子对象的组成，有时候我们需要通过简单的控制来完成工作，组合模式就派上了用场。</p>\n<p>下面我们模拟一个场景，模拟公司内部的一个，上级(组合对象)只要交代给部门领导(组合对象)，再由部门领导交付具体的指令给具体的员工(叶子对象)来完成具体的工作。</p>\n<p>先来看看传统的做法：</p>\n<pre><code>/**\n  *\n  * 公司类\n  **/\nfunction Org(name){\n    this.name = name;\n    this.depts = [];\n}\nOrg.prototype = {\n    &quot;constructor&quot;:Org,\n    &quot;addDepts&quot;:function(child){\n        this.depts.push(child);\n        return this;\n        //  添加部门,return this 提供链式调用\n    },\n    &quot;getDepts&quot;:function(){\n        return this.depts;\n        //  获取部门\n    }\n};\n\n/**\n  *\n  * 部门类\n  **/\nfunction Dept(name){\n    this.name = name;\n    this.persons = [];\n}\nDept.prototype = {\n    &quot;constructor&quot;:Dept,\n    &quot;addPersons&quot;:function(child){\n        this.persons.push(child);\n        return this;\n        //  添加部门员工\n    },\n    &quot;getPersons&quot;:function(){\n        return this.persons;\n        //  获取部门员工\n    }\n};\n\n/**\n  *\n  * 员工类\n  **/\nfunction Person(name){\n    this.name = name;\n}\ncommonUtil.wrap(Person.prototype,{\n    &quot;constructor&quot;:Person,\n    &quot;hardWorking&quot;:function(){\n        console.log(this.name + &quot; ... 努力工作！&quot;);\n        //  xxx ... 努力工作\n    },\n    &quot;sleeping&quot;:function(){\n        console.log(this.name + &quot;睡觉！&quot;);\n        //  xxx 睡觉！\n    }\n});\n\nvar p1 = new Person(&quot;张1&quot;),\n    p2 = new Person(&quot;张2&quot;),\n    p3 = new Person(&quot;张3&quot;),\n    p4 = new Person(&quot;张4&quot;),\n    p5 = new Person(&quot;张5&quot;),\n    p6 = new Person(&quot;张6&quot;),\n    dept1 = new Dept(&quot;开发&quot;),\n    dept2 = new Dept(&quot;销售&quot;),\n    org = new Org(&quot;某某公司&quot;);\n//  实例化对象    \n\ndept1.addPersons(p1).addPersons(p2).addPersons(p3);\ndept2.addPersons(p4).addPersons(p5).addPersons(p6);\norg.addDepts(dept1).addDepts(dept2);\n//  添加部门和部门员工\n\nfor(var i = 0,depts = org.getDepts();i &lt; depts.length;i ++){\n    for(j = 0,persons = depts[i].getPersons();j &lt; persons.length;j ++){\n        if(persons[j][&quot;name&quot;] === &quot;张3&quot;){\n            persons[j].hardWorking();\n        }\n    }\n}\n//  具体的让张3努力工作\n</code></pre><p>在上面的例子我们可以看到,如果想要”张三”这个人执行hardWorking方法，需要写两层循环，现在只是两层结构，要是在多层的情况下，可能就需要递归神马了，甚是麻烦。</p>\n<p>再来看看组合模式吧！这边的commomUtil下的方法和工厂模式里面的用的一样的。</p>\n<pre><code>var CompositeInterface = new commonUtil.Interface(&quot;CompositeInterface&quot;,[&quot;addChild&quot;,&quot;getChild&quot;]),\nLeafInterface = new commonUtil.Interface(&quot;LeafInterface&quot;,[&quot;hardWorking&quot;,&quot;sleeping&quot;]);\n        //  定义组合对象和叶子对象需要实现的接口\n\n/**\n * 组合对象\n * @param name\n * @constructor\n */\nfunction Composite(name){\n    this.name = name;\n    this.type = &quot;Composite&quot;;\n    //  说明当前对象类型\n    this.children = [];\n    //  承装孩子（叶子节点）的数组\n}\ncommonUtil.wrap(Composite.prototype,{\n    &quot;constructor&quot;:Composite,\n    &quot;addChild&quot;:function(child){\n        this.children.push(child);\n        return this;\n    },\n    &quot;getChild&quot;:function(name){\n        var list = [],\n            pushLeaf = function(item){\n                if(this.name === name || item[&quot;type&quot;] === &quot;Composite&quot;){\n                      item[&quot;children&quot;].each(arguments.callee);\n                     // pushLeaf(item[&quot;children&quot;]);\n                }else if(item[&quot;type&quot;] === &quot;Leaf&quot;) {\n                    list.push(item);\n                }\n            };\n        if(name &amp;&amp; this.name !== name){\n            //  返回指定类型的叶子对象\n            this.children.each(function(item){\n                if(item[&quot;name&quot;] === name &amp;&amp; item[&quot;type&quot;] === &quot;Composite&quot;){\n                    item[&quot;children&quot;].each(pushLeaf);\n                }\n                //  二级节点\n                if(item[&quot;name&quot;] !== name &amp;&amp; item[&quot;type&quot;] === &quot;Composite&quot;){\n                    item[&quot;children&quot;].each(arguments.callee);\n                }\n                //  三级、四级...\n                if(item[&quot;name&quot;] === name &amp;&amp; item[&quot;type&quot;] === &quot;Leaf&quot;){\n                    list.push(item);\n                }\n            });\n        }else{\n            //  返回所有叶子对象\n            this.children.each(pushLeaf);\n        }\n        return list;\n    },\n    &quot;hardWorking&quot;:function(name){\n        var leafObjects = this.getChild(name);\n        //  得到所有的叶子类型对象\n        for(var i = 0,l = leafObjects.length;i &lt; l;i ++){\n            leafObjects[i] &amp;&amp; leafObjects[i].hardWorking(leafObjects[i][&quot;name&quot;]);\n        }\n    },\n    &quot;sleeping&quot;:function(name){\n        var leafObjects = this.getChild(name);\n        //  得到所有的叶子类型对象\n        for(var i = 0,l = leafObjects.length;i &lt; l;i ++){\n            leafObjects[i].sleeping(leafObjects[i][&quot;name&quot;]);\n        }\n    }\n});\n\n/**\n * 叶子对象\n * @param name\n * @constructor\n */\nfunction Leaf(name){\n    this.name = name;\n    this.type = &quot;Leaf&quot;;\n    //  说明当前对象类型\n}\ncommonUtil.wrap(Leaf.prototype,{\n    &quot;constructor&quot;:Leaf,\n    &quot;addChild&quot;:function(child){\n        throw new Error(&quot;this method is disabled&quot;);\n        //  叶子节点下没有添加子节点的方法,所以调用的时候抛异常\n    },\n    &quot;getChild&quot;:function(name){\n        if(this.name === name){\n            return this;\n        }\n        return null;\n    },\n    &quot;hardWorking&quot;:function(){\n        console.log(this.name + &quot; ... 努力工作！&quot;);\n    },\n    &quot;sleeping&quot;:function(name){\n        console.log(this.name + &quot; ... 睡觉！&quot;);\n    }\n});\n\nvar p1 = new Leaf(&quot;张1&quot;),\n    p2 = new Leaf(&quot;张2&quot;),\n    p3 = new Leaf(&quot;张3&quot;),\n    p4 = new Leaf(&quot;张4&quot;),\n    p5 = new Leaf(&quot;张5&quot;),\n    p6 = new Leaf(&quot;张6&quot;),\n    p7 = new Leaf(&quot;张7&quot;),\n    p8 = new Leaf(&quot;张8&quot;),\n    p9 = new Leaf(&quot;张9&quot;),\n    p10 = new Leaf(&quot;张10&quot;),\n    p11 = new Leaf(&quot;张11&quot;),\n    p12 = new Leaf(&quot;张12&quot;),\n    dept1 = new Composite(&quot;南京开发部&quot;),\n    dept2 = new Composite(&quot;南京销售部&quot;),\n    dept3 = new Composite(&quot;杭州开发部&quot;),\n    dept4 = new Composite(&quot;杭州销售部&quot;),\n    org = new Composite(&quot;xx公司&quot;),\n    org2 = new Composite(&quot;南京分公司&quot;),\n    org3 = new Composite(&quot;杭州分公司&quot;);\n    //  实例化一些对象\n\n    dept1.addChild(p1).addChild(p2).addChild(p3);\n    dept2.addChild(p4).addChild(p5).addChild(p6);\n    dept3.addChild(p7).addChild(p8).addChild(p9);\n    dept4.addChild(p10).addChild(p11).addChild(p12);\n    //  组装二级、三级、叶子节点\n\n    org2.addChild(dept1).addChild(dept2);\n    org3.addChild(dept3).addChild(dept4);\n    org.addChild(org2).addChild(org3);\n    //  组装分公司和总公司\n\n    org.hardWorking();  \n    //  总公司下面的人都执行hardWork方法\n    org.hardWorking(&quot;南京分公司&quot;);  \n    //  南京分公司下面的人都执行hardWork方法\n    org.hardWorking(&quot;杭州开发部&quot;);  \n    //  某级子节点(组合对象)下面的人都执行hardWork方法\n    org.hardWorking(&quot;张12&quot;);  \n    //  具体某人执行hardWork方法\n</code></pre><p>怎么样,看完这个例子是不是感觉比传统的调用方法简单多了,现在就2种类型的对象,虽然组合对象下封装的方法,只要传入具体的某个部门或者员工就能走它下面的方法;这么好的模式,何乐而不为？</p>\n","excerpt":"","more":"<p>组合模式:</p>\n<p>在组合模式中，对象有两种形式，一种是叶子对象，一种是组合对象，其中组合对象是叶子对象的组成，有时候我们需要通过简单的控制来完成工作，组合模式就派上了用场。</p>\n<p>下面我们模拟一个场景，模拟公司内部的一个，上级(组合对象)只要交代给部门领导(组合对象)，再由部门领导交付具体的指令给具体的员工(叶子对象)来完成具体的工作。</p>\n<p>先来看看传统的做法：</p>\n<pre><code>/**\n  *\n  * 公司类\n  **/\nfunction Org(name){\n    this.name = name;\n    this.depts = [];\n}\nOrg.prototype = {\n    &quot;constructor&quot;:Org,\n    &quot;addDepts&quot;:function(child){\n        this.depts.push(child);\n        return this;\n        //  添加部门,return this 提供链式调用\n    },\n    &quot;getDepts&quot;:function(){\n        return this.depts;\n        //  获取部门\n    }\n};\n\n/**\n  *\n  * 部门类\n  **/\nfunction Dept(name){\n    this.name = name;\n    this.persons = [];\n}\nDept.prototype = {\n    &quot;constructor&quot;:Dept,\n    &quot;addPersons&quot;:function(child){\n        this.persons.push(child);\n        return this;\n        //  添加部门员工\n    },\n    &quot;getPersons&quot;:function(){\n        return this.persons;\n        //  获取部门员工\n    }\n};\n\n/**\n  *\n  * 员工类\n  **/\nfunction Person(name){\n    this.name = name;\n}\ncommonUtil.wrap(Person.prototype,{\n    &quot;constructor&quot;:Person,\n    &quot;hardWorking&quot;:function(){\n        console.log(this.name + &quot; ... 努力工作！&quot;);\n        //  xxx ... 努力工作\n    },\n    &quot;sleeping&quot;:function(){\n        console.log(this.name + &quot;睡觉！&quot;);\n        //  xxx 睡觉！\n    }\n});\n\nvar p1 = new Person(&quot;张1&quot;),\n    p2 = new Person(&quot;张2&quot;),\n    p3 = new Person(&quot;张3&quot;),\n    p4 = new Person(&quot;张4&quot;),\n    p5 = new Person(&quot;张5&quot;),\n    p6 = new Person(&quot;张6&quot;),\n    dept1 = new Dept(&quot;开发&quot;),\n    dept2 = new Dept(&quot;销售&quot;),\n    org = new Org(&quot;某某公司&quot;);\n//  实例化对象    \n\ndept1.addPersons(p1).addPersons(p2).addPersons(p3);\ndept2.addPersons(p4).addPersons(p5).addPersons(p6);\norg.addDepts(dept1).addDepts(dept2);\n//  添加部门和部门员工\n\nfor(var i = 0,depts = org.getDepts();i &lt; depts.length;i ++){\n    for(j = 0,persons = depts[i].getPersons();j &lt; persons.length;j ++){\n        if(persons[j][&quot;name&quot;] === &quot;张3&quot;){\n            persons[j].hardWorking();\n        }\n    }\n}\n//  具体的让张3努力工作\n</code></pre><p>在上面的例子我们可以看到,如果想要”张三”这个人执行hardWorking方法，需要写两层循环，现在只是两层结构，要是在多层的情况下，可能就需要递归神马了，甚是麻烦。</p>\n<p>再来看看组合模式吧！这边的commomUtil下的方法和工厂模式里面的用的一样的。</p>\n<pre><code>var CompositeInterface = new commonUtil.Interface(&quot;CompositeInterface&quot;,[&quot;addChild&quot;,&quot;getChild&quot;]),\nLeafInterface = new commonUtil.Interface(&quot;LeafInterface&quot;,[&quot;hardWorking&quot;,&quot;sleeping&quot;]);\n        //  定义组合对象和叶子对象需要实现的接口\n\n/**\n * 组合对象\n * @param name\n * @constructor\n */\nfunction Composite(name){\n    this.name = name;\n    this.type = &quot;Composite&quot;;\n    //  说明当前对象类型\n    this.children = [];\n    //  承装孩子（叶子节点）的数组\n}\ncommonUtil.wrap(Composite.prototype,{\n    &quot;constructor&quot;:Composite,\n    &quot;addChild&quot;:function(child){\n        this.children.push(child);\n        return this;\n    },\n    &quot;getChild&quot;:function(name){\n        var list = [],\n            pushLeaf = function(item){\n                if(this.name === name || item[&quot;type&quot;] === &quot;Composite&quot;){\n                      item[&quot;children&quot;].each(arguments.callee);\n                     // pushLeaf(item[&quot;children&quot;]);\n                }else if(item[&quot;type&quot;] === &quot;Leaf&quot;) {\n                    list.push(item);\n                }\n            };\n        if(name &amp;&amp; this.name !== name){\n            //  返回指定类型的叶子对象\n            this.children.each(function(item){\n                if(item[&quot;name&quot;] === name &amp;&amp; item[&quot;type&quot;] === &quot;Composite&quot;){\n                    item[&quot;children&quot;].each(pushLeaf);\n                }\n                //  二级节点\n                if(item[&quot;name&quot;] !== name &amp;&amp; item[&quot;type&quot;] === &quot;Composite&quot;){\n                    item[&quot;children&quot;].each(arguments.callee);\n                }\n                //  三级、四级...\n                if(item[&quot;name&quot;] === name &amp;&amp; item[&quot;type&quot;] === &quot;Leaf&quot;){\n                    list.push(item);\n                }\n            });\n        }else{\n            //  返回所有叶子对象\n            this.children.each(pushLeaf);\n        }\n        return list;\n    },\n    &quot;hardWorking&quot;:function(name){\n        var leafObjects = this.getChild(name);\n        //  得到所有的叶子类型对象\n        for(var i = 0,l = leafObjects.length;i &lt; l;i ++){\n            leafObjects[i] &amp;&amp; leafObjects[i].hardWorking(leafObjects[i][&quot;name&quot;]);\n        }\n    },\n    &quot;sleeping&quot;:function(name){\n        var leafObjects = this.getChild(name);\n        //  得到所有的叶子类型对象\n        for(var i = 0,l = leafObjects.length;i &lt; l;i ++){\n            leafObjects[i].sleeping(leafObjects[i][&quot;name&quot;]);\n        }\n    }\n});\n\n/**\n * 叶子对象\n * @param name\n * @constructor\n */\nfunction Leaf(name){\n    this.name = name;\n    this.type = &quot;Leaf&quot;;\n    //  说明当前对象类型\n}\ncommonUtil.wrap(Leaf.prototype,{\n    &quot;constructor&quot;:Leaf,\n    &quot;addChild&quot;:function(child){\n        throw new Error(&quot;this method is disabled&quot;);\n        //  叶子节点下没有添加子节点的方法,所以调用的时候抛异常\n    },\n    &quot;getChild&quot;:function(name){\n        if(this.name === name){\n            return this;\n        }\n        return null;\n    },\n    &quot;hardWorking&quot;:function(){\n        console.log(this.name + &quot; ... 努力工作！&quot;);\n    },\n    &quot;sleeping&quot;:function(name){\n        console.log(this.name + &quot; ... 睡觉！&quot;);\n    }\n});\n\nvar p1 = new Leaf(&quot;张1&quot;),\n    p2 = new Leaf(&quot;张2&quot;),\n    p3 = new Leaf(&quot;张3&quot;),\n    p4 = new Leaf(&quot;张4&quot;),\n    p5 = new Leaf(&quot;张5&quot;),\n    p6 = new Leaf(&quot;张6&quot;),\n    p7 = new Leaf(&quot;张7&quot;),\n    p8 = new Leaf(&quot;张8&quot;),\n    p9 = new Leaf(&quot;张9&quot;),\n    p10 = new Leaf(&quot;张10&quot;),\n    p11 = new Leaf(&quot;张11&quot;),\n    p12 = new Leaf(&quot;张12&quot;),\n    dept1 = new Composite(&quot;南京开发部&quot;),\n    dept2 = new Composite(&quot;南京销售部&quot;),\n    dept3 = new Composite(&quot;杭州开发部&quot;),\n    dept4 = new Composite(&quot;杭州销售部&quot;),\n    org = new Composite(&quot;xx公司&quot;),\n    org2 = new Composite(&quot;南京分公司&quot;),\n    org3 = new Composite(&quot;杭州分公司&quot;);\n    //  实例化一些对象\n\n    dept1.addChild(p1).addChild(p2).addChild(p3);\n    dept2.addChild(p4).addChild(p5).addChild(p6);\n    dept3.addChild(p7).addChild(p8).addChild(p9);\n    dept4.addChild(p10).addChild(p11).addChild(p12);\n    //  组装二级、三级、叶子节点\n\n    org2.addChild(dept1).addChild(dept2);\n    org3.addChild(dept3).addChild(dept4);\n    org.addChild(org2).addChild(org3);\n    //  组装分公司和总公司\n\n    org.hardWorking();  \n    //  总公司下面的人都执行hardWork方法\n    org.hardWorking(&quot;南京分公司&quot;);  \n    //  南京分公司下面的人都执行hardWork方法\n    org.hardWorking(&quot;杭州开发部&quot;);  \n    //  某级子节点(组合对象)下面的人都执行hardWork方法\n    org.hardWorking(&quot;张12&quot;);  \n    //  具体某人执行hardWork方法\n</code></pre><p>怎么样,看完这个例子是不是感觉比传统的调用方法简单多了,现在就2种类型的对象,虽然组合对象下封装的方法,只要传入具体的某个部门或者员工就能走它下面的方法;这么好的模式,何乐而不为？</p>\n"},{"layout":"post","title":"javascript工厂模式","date":"2015-05-30T16:00:00.000Z","_content":"\n工厂模式:\n\n创建一个对象常常需要复杂的过程，所以不适合在一个复杂的对象中。创建对象可能会导致大量的重复代码，也可能提供不了足够级别的抽象。工厂方法模式通过定义一个单独的创建对象的方法来解决这些问题，由子类实现这个方法来创建具体类型的对象。\n\n简单工厂：\n类本身实现了所有功能代码，通过实例化调用其方法来完成某些功能。\n\n抽象工厂：\n类本身定一些抽象方法，通过给子类继承的方式，来重写父类的抽象方法，该类不能被实例化，只能通过实例化它的子类来完成某些功能。\n\n        /**\n         * 注：\n         * commonUtil.wrap(xxx.prototype,{})和xxx.prototype = {}功能相同\n         * commonUtil.extend()是实现继承那边类式继承的代码功能\n         * commonUtil.Interface和commonUtil.Interface.ensureImplement是实现接口那边鸭式辨型的代码功能\n         *\n         * */\n         \n----------\n\n这是简单工厂的一个示例：\n\n\t/*\n\t\t功能描述：\n\t\t有三种类型的车(奔驰,宝马,奥迪),现在要买车,定义一个汽车4店类卖车\n\t\t逻辑流程：\n\t\t\n\t*/\n\n\t/**\n\t  * 汽车商店构造器\n\t  * @constructor\n\t  */\n\tfunction CarShop() {}\n\n        commonUtil.wrap(CarShop.prototype, {\n            \"constructor\": CarShop,\n            \"sellCar\": function (type) {\n                var car;\n                switch (type) {\n                    case \"Benz\":\n                        car = new Benz();\n                        break;\n                    case \"Bmw\":\n                        car = new Bmw();\n                        break;\n                    case \"Audi\":\n                        car = new Audi();\n                        break;\n                    default:\n                        \"not to buy!\"\n                }\n\t\t//\t通过传入的参数判断到底要实例哪个牌子的车对象(造车)\n                return car;\n            }\n        });\n        //  拓展原型对象\n\n        /**\n         * SuperClass\n         * @constructor\n         */\n        function BaseCar(){}\n\n        commonUtil.wrap(BaseCar.prototype,{\n            \"start\": function () {\n                console.log(\"我的\"+ this.constructor.name +\"启动了！\");\n            },\n            \"run\": function () {\n                console.log(\"我的\"+ this.constructor.name +\"开走了！\");\n            }\n        });\n\n        //  Class benz bmw audi\n        //  子类应该先继承BaseCar类,再拓展或重写自己的方法\n\t \t//\t奔驰\t\n        function Benz() {\n        }\n        commonUtil.extend(Benz,BaseCar);\n\n\t\t//\t宝马\n        function Bmw() {\n        }\n        commonUtil.extend(Bmw,BaseCar);\n\n\t\t//\t奥迪\n        function Audi() {\n        }\n        commonUtil.extend(Audi,BaseCar);\n        //  三个子类分别继承父类\n\n        var shop = new CarShop();\n\t \t//\t实例化汽车商店\n        var car = shop.sellCar(\"Bmw\");\n\t\t//\t从商店里买走辆宝马\n        car.start();\n        car.run();\n\n        var car2 = shop.sellCar(\"Audi\");\n\t\t//\t从商店买走一辆奥迪\n        car2.start();\n        car2.run();\n\n从上面的例子中可以看到，在CarShop这个类中，把所有工作都做了，但是在实际生活中，汽车4S店负责的就只有卖车等工作，不会和现在这个例子一样把生产车的例子也做了，而且在这个例子中，该汽车4S店提供了3种品牌的车(本初、宝马、奥迪)，根据需求决定具体出哪一种车。所以，我们有必要把代码优化下，让汽车店只负责卖车。其他的工作和它没太大关系，于是，就有了抽象工厂的概念。\n\n        var CarInterface = new commonUtil.Interface(\"CarInterface\", [\"start\", \"run\"]);\n        //  接口对象的实例\n\n\t\t/**\n         * 卖车的商店(抽象类)\n         * 抽象类 -> 用来被之类继承\n         * @constructor\n         * */\n        function CarShop() {\n        }\n\n        commonUtil.wrap(CarShop.prototype, {\n            \"constructor\": CarShop,\n            \"sellCar\": function (type) {\n                throw new Error(\"method sellCar is an abstruct method!\");\n            }//\t卖车，给子类继承重写\n        });\n        //  拓展原型对象\n\n        //  奔驰4S店类\n        function BenzCarShop(){}\n        commonUtil.extend(BenzCarShop,CarShop);\n        commonUtil.wrap(BenzCarShop.prototype,{\n            \"constructor\":BenzCarShop,\n            \"sellCar\":function(type){\n                var car;\n                var types = [\"Benz\"];\n                for(var t in types){\n                    if(types[t] === type){\n                        //  如果商店里有想要的型号,就走这边\n                        car = CarFactory.createCar(type);\n                    }else{\n                        //  没有此类型的车\n                        console.log(\"没有此型号！\");\n                    }\n                }\n                return car;\n                //  数组中存放所有奔驰类型的汽车\n            }\n        });\n\n        //  宝马4S店类\n        function BmwCarShop(){}\n        commonUtil.extend(BmwCarShop,CarShop);\n        commonUtil.wrap(BmwCarShop.prototype,{\n            \"constructor\":BmwCarShop,\n            \"sellCar\":function(type){\n                var car;\n                var types = [\"Bmw\"];\n                for(var t in types){\n                    if(types[t] === type){\n                        //  如果商店里有想要的型号,就走这边\n                        car = CarFactory.createCar(type);\n                    }else{\n                        //  没有此类型的车\n                        console.log(\"没有此型号！\");\n                    }\n                }\n                return car;\n            }\n        });\n\n \t\t//  奥迪4S店类\n        function AudiCarShop(){}\n        commonUtil.extend(AudiCarShop,CarShop);\n        commonUtil.wrap(BmwCarShop.prototype,{\n            \"constructor\":AudiCarShop,\n            \"sellCar\":function(type){\n                var car;\n                var types = [\"Audi\"];\n                for(var t in types){\n                    if(types[t] === type){\n                        //  如果商店里有想要的型号,就走这边\n                        car = CarFactory.createCar(type);\n                    }else{\n                        //  没有此类型的车\n                        console.log(\"没有此型号！\");\n                    }\n                }\n                return car;\n            }\n        });\n\t \t//\t创建3个汽车4S店类，分别完成对汽车店类的继承\n\n        var CarFactory = {\n            \"createCar\":function(type){\n                var car;\n                //  动态创建车\n                car = eval(\"new \"+ type +\"();\");\n                //  利用eval动态创建传入的车实例\n                commonUtil.Interface.ensureImplement(car,CarInterface);\n                //  检验接口是否实现\n                return car;\n            }\n        };\n        //  创建生产一台车的工厂(单体模式)\n\n        /**\n         * SuperClass\n         * @constructor\n         */\n        function BaseCar(){}\n\n        commonUtil.wrap(BaseCar.prototype,{\n            \"start\": function () {\n                console.log(\"老子的\"+ this.constructor.name +\"启动了！\");\n            },\n            \"run\": function () {\n                console.log(\"老子的\"+ this.constructor.name +\"开走了！\");\n            }\n        });\n\n        //  Class benz bmw audi\n        //  子类应该先继承父类,再拓展或重写自己的方法\n\n        function Benz() {\n        }\n        commonUtil.extend(Benz,BaseCar);\n\n        function Bmw() {\n        }\n        commonUtil.extend(Bmw,BaseCar);\n        commonUtil.wrap(Bmw.prototype,{\n            \"driveBmw\":function(){\n                console.log(\"开宝马！\");\n            },\n            \"run\":function(){\n                console.log(\"宝马开走了！\");\n            }\n        });\n\n        function Audi() {\n        }\n        commonUtil.extend(Audi,BaseCar);\n        //  三个子类分别继承父类,并且拓展自己的方法\n\n        var benz = new BenzCarShop(),\n            bmw = new BmwCarShop(),\n            benzCar = benz.sellCar(\"Benz\"),\n            bmwCar = bmw.sellCar(\"Bmw\");\n\t\t//去具体的某个4S店卖车\n\n        benzCar.run();\n        bmwCar.run();\t\n\n在上面的抽象工厂中，汽车类之提供了一个抽象方法，给各子类继承和重写，而生产的工作交给了具体某种汽车厂商的造车厂，卖车的工作细分到具体某种品牌的4S店，这样，才是我们日常生活中的正常逻辑(买什么车,去什么4S店 -> 卖车 -> 生产车 -> 买车)。\n\n","source":"_posts/2015-05-31-js-design-mode-factory.md","raw":"---\nlayout: post\ntitle: javascript工厂模式\ndate: 2015-05-31\ncategories: [javascript, 设计模式]\n---\n\n工厂模式:\n\n创建一个对象常常需要复杂的过程，所以不适合在一个复杂的对象中。创建对象可能会导致大量的重复代码，也可能提供不了足够级别的抽象。工厂方法模式通过定义一个单独的创建对象的方法来解决这些问题，由子类实现这个方法来创建具体类型的对象。\n\n简单工厂：\n类本身实现了所有功能代码，通过实例化调用其方法来完成某些功能。\n\n抽象工厂：\n类本身定一些抽象方法，通过给子类继承的方式，来重写父类的抽象方法，该类不能被实例化，只能通过实例化它的子类来完成某些功能。\n\n        /**\n         * 注：\n         * commonUtil.wrap(xxx.prototype,{})和xxx.prototype = {}功能相同\n         * commonUtil.extend()是实现继承那边类式继承的代码功能\n         * commonUtil.Interface和commonUtil.Interface.ensureImplement是实现接口那边鸭式辨型的代码功能\n         *\n         * */\n         \n----------\n\n这是简单工厂的一个示例：\n\n\t/*\n\t\t功能描述：\n\t\t有三种类型的车(奔驰,宝马,奥迪),现在要买车,定义一个汽车4店类卖车\n\t\t逻辑流程：\n\t\t\n\t*/\n\n\t/**\n\t  * 汽车商店构造器\n\t  * @constructor\n\t  */\n\tfunction CarShop() {}\n\n        commonUtil.wrap(CarShop.prototype, {\n            \"constructor\": CarShop,\n            \"sellCar\": function (type) {\n                var car;\n                switch (type) {\n                    case \"Benz\":\n                        car = new Benz();\n                        break;\n                    case \"Bmw\":\n                        car = new Bmw();\n                        break;\n                    case \"Audi\":\n                        car = new Audi();\n                        break;\n                    default:\n                        \"not to buy!\"\n                }\n\t\t//\t通过传入的参数判断到底要实例哪个牌子的车对象(造车)\n                return car;\n            }\n        });\n        //  拓展原型对象\n\n        /**\n         * SuperClass\n         * @constructor\n         */\n        function BaseCar(){}\n\n        commonUtil.wrap(BaseCar.prototype,{\n            \"start\": function () {\n                console.log(\"我的\"+ this.constructor.name +\"启动了！\");\n            },\n            \"run\": function () {\n                console.log(\"我的\"+ this.constructor.name +\"开走了！\");\n            }\n        });\n\n        //  Class benz bmw audi\n        //  子类应该先继承BaseCar类,再拓展或重写自己的方法\n\t \t//\t奔驰\t\n        function Benz() {\n        }\n        commonUtil.extend(Benz,BaseCar);\n\n\t\t//\t宝马\n        function Bmw() {\n        }\n        commonUtil.extend(Bmw,BaseCar);\n\n\t\t//\t奥迪\n        function Audi() {\n        }\n        commonUtil.extend(Audi,BaseCar);\n        //  三个子类分别继承父类\n\n        var shop = new CarShop();\n\t \t//\t实例化汽车商店\n        var car = shop.sellCar(\"Bmw\");\n\t\t//\t从商店里买走辆宝马\n        car.start();\n        car.run();\n\n        var car2 = shop.sellCar(\"Audi\");\n\t\t//\t从商店买走一辆奥迪\n        car2.start();\n        car2.run();\n\n从上面的例子中可以看到，在CarShop这个类中，把所有工作都做了，但是在实际生活中，汽车4S店负责的就只有卖车等工作，不会和现在这个例子一样把生产车的例子也做了，而且在这个例子中，该汽车4S店提供了3种品牌的车(本初、宝马、奥迪)，根据需求决定具体出哪一种车。所以，我们有必要把代码优化下，让汽车店只负责卖车。其他的工作和它没太大关系，于是，就有了抽象工厂的概念。\n\n        var CarInterface = new commonUtil.Interface(\"CarInterface\", [\"start\", \"run\"]);\n        //  接口对象的实例\n\n\t\t/**\n         * 卖车的商店(抽象类)\n         * 抽象类 -> 用来被之类继承\n         * @constructor\n         * */\n        function CarShop() {\n        }\n\n        commonUtil.wrap(CarShop.prototype, {\n            \"constructor\": CarShop,\n            \"sellCar\": function (type) {\n                throw new Error(\"method sellCar is an abstruct method!\");\n            }//\t卖车，给子类继承重写\n        });\n        //  拓展原型对象\n\n        //  奔驰4S店类\n        function BenzCarShop(){}\n        commonUtil.extend(BenzCarShop,CarShop);\n        commonUtil.wrap(BenzCarShop.prototype,{\n            \"constructor\":BenzCarShop,\n            \"sellCar\":function(type){\n                var car;\n                var types = [\"Benz\"];\n                for(var t in types){\n                    if(types[t] === type){\n                        //  如果商店里有想要的型号,就走这边\n                        car = CarFactory.createCar(type);\n                    }else{\n                        //  没有此类型的车\n                        console.log(\"没有此型号！\");\n                    }\n                }\n                return car;\n                //  数组中存放所有奔驰类型的汽车\n            }\n        });\n\n        //  宝马4S店类\n        function BmwCarShop(){}\n        commonUtil.extend(BmwCarShop,CarShop);\n        commonUtil.wrap(BmwCarShop.prototype,{\n            \"constructor\":BmwCarShop,\n            \"sellCar\":function(type){\n                var car;\n                var types = [\"Bmw\"];\n                for(var t in types){\n                    if(types[t] === type){\n                        //  如果商店里有想要的型号,就走这边\n                        car = CarFactory.createCar(type);\n                    }else{\n                        //  没有此类型的车\n                        console.log(\"没有此型号！\");\n                    }\n                }\n                return car;\n            }\n        });\n\n \t\t//  奥迪4S店类\n        function AudiCarShop(){}\n        commonUtil.extend(AudiCarShop,CarShop);\n        commonUtil.wrap(BmwCarShop.prototype,{\n            \"constructor\":AudiCarShop,\n            \"sellCar\":function(type){\n                var car;\n                var types = [\"Audi\"];\n                for(var t in types){\n                    if(types[t] === type){\n                        //  如果商店里有想要的型号,就走这边\n                        car = CarFactory.createCar(type);\n                    }else{\n                        //  没有此类型的车\n                        console.log(\"没有此型号！\");\n                    }\n                }\n                return car;\n            }\n        });\n\t \t//\t创建3个汽车4S店类，分别完成对汽车店类的继承\n\n        var CarFactory = {\n            \"createCar\":function(type){\n                var car;\n                //  动态创建车\n                car = eval(\"new \"+ type +\"();\");\n                //  利用eval动态创建传入的车实例\n                commonUtil.Interface.ensureImplement(car,CarInterface);\n                //  检验接口是否实现\n                return car;\n            }\n        };\n        //  创建生产一台车的工厂(单体模式)\n\n        /**\n         * SuperClass\n         * @constructor\n         */\n        function BaseCar(){}\n\n        commonUtil.wrap(BaseCar.prototype,{\n            \"start\": function () {\n                console.log(\"老子的\"+ this.constructor.name +\"启动了！\");\n            },\n            \"run\": function () {\n                console.log(\"老子的\"+ this.constructor.name +\"开走了！\");\n            }\n        });\n\n        //  Class benz bmw audi\n        //  子类应该先继承父类,再拓展或重写自己的方法\n\n        function Benz() {\n        }\n        commonUtil.extend(Benz,BaseCar);\n\n        function Bmw() {\n        }\n        commonUtil.extend(Bmw,BaseCar);\n        commonUtil.wrap(Bmw.prototype,{\n            \"driveBmw\":function(){\n                console.log(\"开宝马！\");\n            },\n            \"run\":function(){\n                console.log(\"宝马开走了！\");\n            }\n        });\n\n        function Audi() {\n        }\n        commonUtil.extend(Audi,BaseCar);\n        //  三个子类分别继承父类,并且拓展自己的方法\n\n        var benz = new BenzCarShop(),\n            bmw = new BmwCarShop(),\n            benzCar = benz.sellCar(\"Benz\"),\n            bmwCar = bmw.sellCar(\"Bmw\");\n\t\t//去具体的某个4S店卖车\n\n        benzCar.run();\n        bmwCar.run();\t\n\n在上面的抽象工厂中，汽车类之提供了一个抽象方法，给各子类继承和重写，而生产的工作交给了具体某种汽车厂商的造车厂，卖车的工作细分到具体某种品牌的4S店，这样，才是我们日常生活中的正常逻辑(买什么车,去什么4S店 -> 卖车 -> 生产车 -> 买车)。\n\n","slug":"2015-05-31-js-design-mode-factory","published":1,"updated":"2016-11-09T14:00:08.000Z","_id":"civ7fseek000it95fo6i1w4ae","comments":1,"photos":[],"link":"","content":"<p>工厂模式:</p>\n<p>创建一个对象常常需要复杂的过程，所以不适合在一个复杂的对象中。创建对象可能会导致大量的重复代码，也可能提供不了足够级别的抽象。工厂方法模式通过定义一个单独的创建对象的方法来解决这些问题，由子类实现这个方法来创建具体类型的对象。</p>\n<p>简单工厂：<br>类本身实现了所有功能代码，通过实例化调用其方法来完成某些功能。</p>\n<p>抽象工厂：<br>类本身定一些抽象方法，通过给子类继承的方式，来重写父类的抽象方法，该类不能被实例化，只能通过实例化它的子类来完成某些功能。</p>\n<pre><code>/**\n * 注：\n * commonUtil.wrap(xxx.prototype,{})和xxx.prototype = {}功能相同\n * commonUtil.extend()是实现继承那边类式继承的代码功能\n * commonUtil.Interface和commonUtil.Interface.ensureImplement是实现接口那边鸭式辨型的代码功能\n *\n * */\n</code></pre><hr>\n<p>这是简单工厂的一个示例：</p>\n<pre><code>/*\n    功能描述：\n    有三种类型的车(奔驰,宝马,奥迪),现在要买车,定义一个汽车4店类卖车\n    逻辑流程：\n\n*/\n\n/**\n  * 汽车商店构造器\n  * @constructor\n  */\nfunction CarShop() {}\n\n    commonUtil.wrap(CarShop.prototype, {\n        &quot;constructor&quot;: CarShop,\n        &quot;sellCar&quot;: function (type) {\n            var car;\n            switch (type) {\n                case &quot;Benz&quot;:\n                    car = new Benz();\n                    break;\n                case &quot;Bmw&quot;:\n                    car = new Bmw();\n                    break;\n                case &quot;Audi&quot;:\n                    car = new Audi();\n                    break;\n                default:\n                    &quot;not to buy!&quot;\n            }\n    //    通过传入的参数判断到底要实例哪个牌子的车对象(造车)\n            return car;\n        }\n    });\n    //  拓展原型对象\n\n    /**\n     * SuperClass\n     * @constructor\n     */\n    function BaseCar(){}\n\n    commonUtil.wrap(BaseCar.prototype,{\n        &quot;start&quot;: function () {\n            console.log(&quot;我的&quot;+ this.constructor.name +&quot;启动了！&quot;);\n        },\n        &quot;run&quot;: function () {\n            console.log(&quot;我的&quot;+ this.constructor.name +&quot;开走了！&quot;);\n        }\n    });\n\n    //  Class benz bmw audi\n    //  子类应该先继承BaseCar类,再拓展或重写自己的方法\n     //    奔驰    \n    function Benz() {\n    }\n    commonUtil.extend(Benz,BaseCar);\n\n    //    宝马\n    function Bmw() {\n    }\n    commonUtil.extend(Bmw,BaseCar);\n\n    //    奥迪\n    function Audi() {\n    }\n    commonUtil.extend(Audi,BaseCar);\n    //  三个子类分别继承父类\n\n    var shop = new CarShop();\n     //    实例化汽车商店\n    var car = shop.sellCar(&quot;Bmw&quot;);\n    //    从商店里买走辆宝马\n    car.start();\n    car.run();\n\n    var car2 = shop.sellCar(&quot;Audi&quot;);\n    //    从商店买走一辆奥迪\n    car2.start();\n    car2.run();\n</code></pre><p>从上面的例子中可以看到，在CarShop这个类中，把所有工作都做了，但是在实际生活中，汽车4S店负责的就只有卖车等工作，不会和现在这个例子一样把生产车的例子也做了，而且在这个例子中，该汽车4S店提供了3种品牌的车(本初、宝马、奥迪)，根据需求决定具体出哪一种车。所以，我们有必要把代码优化下，让汽车店只负责卖车。其他的工作和它没太大关系，于是，就有了抽象工厂的概念。</p>\n<pre><code>var CarInterface = new commonUtil.Interface(&quot;CarInterface&quot;, [&quot;start&quot;, &quot;run&quot;]);\n//  接口对象的实例\n\n/**\n * 卖车的商店(抽象类)\n * 抽象类 -&gt; 用来被之类继承\n * @constructor\n * */\nfunction CarShop() {\n}\n\ncommonUtil.wrap(CarShop.prototype, {\n    &quot;constructor&quot;: CarShop,\n    &quot;sellCar&quot;: function (type) {\n        throw new Error(&quot;method sellCar is an abstruct method!&quot;);\n    }//    卖车，给子类继承重写\n});\n//  拓展原型对象\n\n//  奔驰4S店类\nfunction BenzCarShop(){}\ncommonUtil.extend(BenzCarShop,CarShop);\ncommonUtil.wrap(BenzCarShop.prototype,{\n    &quot;constructor&quot;:BenzCarShop,\n    &quot;sellCar&quot;:function(type){\n        var car;\n        var types = [&quot;Benz&quot;];\n        for(var t in types){\n            if(types[t] === type){\n                //  如果商店里有想要的型号,就走这边\n                car = CarFactory.createCar(type);\n            }else{\n                //  没有此类型的车\n                console.log(&quot;没有此型号！&quot;);\n            }\n        }\n        return car;\n        //  数组中存放所有奔驰类型的汽车\n    }\n});\n\n//  宝马4S店类\nfunction BmwCarShop(){}\ncommonUtil.extend(BmwCarShop,CarShop);\ncommonUtil.wrap(BmwCarShop.prototype,{\n    &quot;constructor&quot;:BmwCarShop,\n    &quot;sellCar&quot;:function(type){\n        var car;\n        var types = [&quot;Bmw&quot;];\n        for(var t in types){\n            if(types[t] === type){\n                //  如果商店里有想要的型号,就走这边\n                car = CarFactory.createCar(type);\n            }else{\n                //  没有此类型的车\n                console.log(&quot;没有此型号！&quot;);\n            }\n        }\n        return car;\n    }\n});\n\n //  奥迪4S店类\nfunction AudiCarShop(){}\ncommonUtil.extend(AudiCarShop,CarShop);\ncommonUtil.wrap(BmwCarShop.prototype,{\n    &quot;constructor&quot;:AudiCarShop,\n    &quot;sellCar&quot;:function(type){\n        var car;\n        var types = [&quot;Audi&quot;];\n        for(var t in types){\n            if(types[t] === type){\n                //  如果商店里有想要的型号,就走这边\n                car = CarFactory.createCar(type);\n            }else{\n                //  没有此类型的车\n                console.log(&quot;没有此型号！&quot;);\n            }\n        }\n        return car;\n    }\n});\n //    创建3个汽车4S店类，分别完成对汽车店类的继承\n\nvar CarFactory = {\n    &quot;createCar&quot;:function(type){\n        var car;\n        //  动态创建车\n        car = eval(&quot;new &quot;+ type +&quot;();&quot;);\n        //  利用eval动态创建传入的车实例\n        commonUtil.Interface.ensureImplement(car,CarInterface);\n        //  检验接口是否实现\n        return car;\n    }\n};\n//  创建生产一台车的工厂(单体模式)\n\n/**\n * SuperClass\n * @constructor\n */\nfunction BaseCar(){}\n\ncommonUtil.wrap(BaseCar.prototype,{\n    &quot;start&quot;: function () {\n        console.log(&quot;老子的&quot;+ this.constructor.name +&quot;启动了！&quot;);\n    },\n    &quot;run&quot;: function () {\n        console.log(&quot;老子的&quot;+ this.constructor.name +&quot;开走了！&quot;);\n    }\n});\n\n//  Class benz bmw audi\n//  子类应该先继承父类,再拓展或重写自己的方法\n\nfunction Benz() {\n}\ncommonUtil.extend(Benz,BaseCar);\n\nfunction Bmw() {\n}\ncommonUtil.extend(Bmw,BaseCar);\ncommonUtil.wrap(Bmw.prototype,{\n    &quot;driveBmw&quot;:function(){\n        console.log(&quot;开宝马！&quot;);\n    },\n    &quot;run&quot;:function(){\n        console.log(&quot;宝马开走了！&quot;);\n    }\n});\n\nfunction Audi() {\n}\ncommonUtil.extend(Audi,BaseCar);\n//  三个子类分别继承父类,并且拓展自己的方法\n\nvar benz = new BenzCarShop(),\n    bmw = new BmwCarShop(),\n    benzCar = benz.sellCar(&quot;Benz&quot;),\n    bmwCar = bmw.sellCar(&quot;Bmw&quot;);\n//去具体的某个4S店卖车\n\nbenzCar.run();\nbmwCar.run();    \n</code></pre><p>在上面的抽象工厂中，汽车类之提供了一个抽象方法，给各子类继承和重写，而生产的工作交给了具体某种汽车厂商的造车厂，卖车的工作细分到具体某种品牌的4S店，这样，才是我们日常生活中的正常逻辑(买什么车,去什么4S店 -&gt; 卖车 -&gt; 生产车 -&gt; 买车)。</p>\n","excerpt":"","more":"<p>工厂模式:</p>\n<p>创建一个对象常常需要复杂的过程，所以不适合在一个复杂的对象中。创建对象可能会导致大量的重复代码，也可能提供不了足够级别的抽象。工厂方法模式通过定义一个单独的创建对象的方法来解决这些问题，由子类实现这个方法来创建具体类型的对象。</p>\n<p>简单工厂：<br>类本身实现了所有功能代码，通过实例化调用其方法来完成某些功能。</p>\n<p>抽象工厂：<br>类本身定一些抽象方法，通过给子类继承的方式，来重写父类的抽象方法，该类不能被实例化，只能通过实例化它的子类来完成某些功能。</p>\n<pre><code>/**\n * 注：\n * commonUtil.wrap(xxx.prototype,{})和xxx.prototype = {}功能相同\n * commonUtil.extend()是实现继承那边类式继承的代码功能\n * commonUtil.Interface和commonUtil.Interface.ensureImplement是实现接口那边鸭式辨型的代码功能\n *\n * */\n</code></pre><hr>\n<p>这是简单工厂的一个示例：</p>\n<pre><code>/*\n    功能描述：\n    有三种类型的车(奔驰,宝马,奥迪),现在要买车,定义一个汽车4店类卖车\n    逻辑流程：\n\n*/\n\n/**\n  * 汽车商店构造器\n  * @constructor\n  */\nfunction CarShop() {}\n\n    commonUtil.wrap(CarShop.prototype, {\n        &quot;constructor&quot;: CarShop,\n        &quot;sellCar&quot;: function (type) {\n            var car;\n            switch (type) {\n                case &quot;Benz&quot;:\n                    car = new Benz();\n                    break;\n                case &quot;Bmw&quot;:\n                    car = new Bmw();\n                    break;\n                case &quot;Audi&quot;:\n                    car = new Audi();\n                    break;\n                default:\n                    &quot;not to buy!&quot;\n            }\n    //    通过传入的参数判断到底要实例哪个牌子的车对象(造车)\n            return car;\n        }\n    });\n    //  拓展原型对象\n\n    /**\n     * SuperClass\n     * @constructor\n     */\n    function BaseCar(){}\n\n    commonUtil.wrap(BaseCar.prototype,{\n        &quot;start&quot;: function () {\n            console.log(&quot;我的&quot;+ this.constructor.name +&quot;启动了！&quot;);\n        },\n        &quot;run&quot;: function () {\n            console.log(&quot;我的&quot;+ this.constructor.name +&quot;开走了！&quot;);\n        }\n    });\n\n    //  Class benz bmw audi\n    //  子类应该先继承BaseCar类,再拓展或重写自己的方法\n     //    奔驰    \n    function Benz() {\n    }\n    commonUtil.extend(Benz,BaseCar);\n\n    //    宝马\n    function Bmw() {\n    }\n    commonUtil.extend(Bmw,BaseCar);\n\n    //    奥迪\n    function Audi() {\n    }\n    commonUtil.extend(Audi,BaseCar);\n    //  三个子类分别继承父类\n\n    var shop = new CarShop();\n     //    实例化汽车商店\n    var car = shop.sellCar(&quot;Bmw&quot;);\n    //    从商店里买走辆宝马\n    car.start();\n    car.run();\n\n    var car2 = shop.sellCar(&quot;Audi&quot;);\n    //    从商店买走一辆奥迪\n    car2.start();\n    car2.run();\n</code></pre><p>从上面的例子中可以看到，在CarShop这个类中，把所有工作都做了，但是在实际生活中，汽车4S店负责的就只有卖车等工作，不会和现在这个例子一样把生产车的例子也做了，而且在这个例子中，该汽车4S店提供了3种品牌的车(本初、宝马、奥迪)，根据需求决定具体出哪一种车。所以，我们有必要把代码优化下，让汽车店只负责卖车。其他的工作和它没太大关系，于是，就有了抽象工厂的概念。</p>\n<pre><code>var CarInterface = new commonUtil.Interface(&quot;CarInterface&quot;, [&quot;start&quot;, &quot;run&quot;]);\n//  接口对象的实例\n\n/**\n * 卖车的商店(抽象类)\n * 抽象类 -&gt; 用来被之类继承\n * @constructor\n * */\nfunction CarShop() {\n}\n\ncommonUtil.wrap(CarShop.prototype, {\n    &quot;constructor&quot;: CarShop,\n    &quot;sellCar&quot;: function (type) {\n        throw new Error(&quot;method sellCar is an abstruct method!&quot;);\n    }//    卖车，给子类继承重写\n});\n//  拓展原型对象\n\n//  奔驰4S店类\nfunction BenzCarShop(){}\ncommonUtil.extend(BenzCarShop,CarShop);\ncommonUtil.wrap(BenzCarShop.prototype,{\n    &quot;constructor&quot;:BenzCarShop,\n    &quot;sellCar&quot;:function(type){\n        var car;\n        var types = [&quot;Benz&quot;];\n        for(var t in types){\n            if(types[t] === type){\n                //  如果商店里有想要的型号,就走这边\n                car = CarFactory.createCar(type);\n            }else{\n                //  没有此类型的车\n                console.log(&quot;没有此型号！&quot;);\n            }\n        }\n        return car;\n        //  数组中存放所有奔驰类型的汽车\n    }\n});\n\n//  宝马4S店类\nfunction BmwCarShop(){}\ncommonUtil.extend(BmwCarShop,CarShop);\ncommonUtil.wrap(BmwCarShop.prototype,{\n    &quot;constructor&quot;:BmwCarShop,\n    &quot;sellCar&quot;:function(type){\n        var car;\n        var types = [&quot;Bmw&quot;];\n        for(var t in types){\n            if(types[t] === type){\n                //  如果商店里有想要的型号,就走这边\n                car = CarFactory.createCar(type);\n            }else{\n                //  没有此类型的车\n                console.log(&quot;没有此型号！&quot;);\n            }\n        }\n        return car;\n    }\n});\n\n //  奥迪4S店类\nfunction AudiCarShop(){}\ncommonUtil.extend(AudiCarShop,CarShop);\ncommonUtil.wrap(BmwCarShop.prototype,{\n    &quot;constructor&quot;:AudiCarShop,\n    &quot;sellCar&quot;:function(type){\n        var car;\n        var types = [&quot;Audi&quot;];\n        for(var t in types){\n            if(types[t] === type){\n                //  如果商店里有想要的型号,就走这边\n                car = CarFactory.createCar(type);\n            }else{\n                //  没有此类型的车\n                console.log(&quot;没有此型号！&quot;);\n            }\n        }\n        return car;\n    }\n});\n //    创建3个汽车4S店类，分别完成对汽车店类的继承\n\nvar CarFactory = {\n    &quot;createCar&quot;:function(type){\n        var car;\n        //  动态创建车\n        car = eval(&quot;new &quot;+ type +&quot;();&quot;);\n        //  利用eval动态创建传入的车实例\n        commonUtil.Interface.ensureImplement(car,CarInterface);\n        //  检验接口是否实现\n        return car;\n    }\n};\n//  创建生产一台车的工厂(单体模式)\n\n/**\n * SuperClass\n * @constructor\n */\nfunction BaseCar(){}\n\ncommonUtil.wrap(BaseCar.prototype,{\n    &quot;start&quot;: function () {\n        console.log(&quot;老子的&quot;+ this.constructor.name +&quot;启动了！&quot;);\n    },\n    &quot;run&quot;: function () {\n        console.log(&quot;老子的&quot;+ this.constructor.name +&quot;开走了！&quot;);\n    }\n});\n\n//  Class benz bmw audi\n//  子类应该先继承父类,再拓展或重写自己的方法\n\nfunction Benz() {\n}\ncommonUtil.extend(Benz,BaseCar);\n\nfunction Bmw() {\n}\ncommonUtil.extend(Bmw,BaseCar);\ncommonUtil.wrap(Bmw.prototype,{\n    &quot;driveBmw&quot;:function(){\n        console.log(&quot;开宝马！&quot;);\n    },\n    &quot;run&quot;:function(){\n        console.log(&quot;宝马开走了！&quot;);\n    }\n});\n\nfunction Audi() {\n}\ncommonUtil.extend(Audi,BaseCar);\n//  三个子类分别继承父类,并且拓展自己的方法\n\nvar benz = new BenzCarShop(),\n    bmw = new BmwCarShop(),\n    benzCar = benz.sellCar(&quot;Benz&quot;),\n    bmwCar = bmw.sellCar(&quot;Bmw&quot;);\n//去具体的某个4S店卖车\n\nbenzCar.run();\nbmwCar.run();    \n</code></pre><p>在上面的抽象工厂中，汽车类之提供了一个抽象方法，给各子类继承和重写，而生产的工作交给了具体某种汽车厂商的造车厂，卖车的工作细分到具体某种品牌的4S店，这样，才是我们日常生活中的正常逻辑(买什么车,去什么4S店 -&gt; 卖车 -&gt; 生产车 -&gt; 买车)。</p>\n"},{"layout":"post","title":"javascript门面模式","date":"2015-06-20T16:00:00.000Z","_content":"\n在javascript中，门面模式常常是开发人员最亲密的朋友。它是几乎所有javascript库的核心原则。通过创建一些使得方法让复杂系统变得更加简单易用,门面模式可以使库提供的工具更容易理解。\n\n先来看看门面模式的写法:\n\n    function a(x){\n        //  do something...\n    }\n    \n    function b(y){\n        //  do something...\n    }\n    \n    /**\n     * 把a和b封装成一个方法(在一个方法里同时调用a、b)\n     * @param x\n     * @param y\n     */\n    function facadeAB(x,y){\n        a(x);\n        b(y);\n    }\n\n在我们平时开发中,可能就用到了门面模式,比如我们现在封装一个绑定事件的方法:\n\n    function bindEvent(el,ev,fn){\n        if(el.addEventListner){\n            el.addEventListener(ev,fn,false);\n        }else if(el.attachEvent){\n            el.attachEvent(\"on\" + ev,fn);\n        }else{\n            el[\"on\" + ev] = fn;\n        }\n    };\n    \n这个就是一个门面模式,里面对于事件的绑定是隐蔽的,只提供bindEvent给其他地方调用。\n\n再来看个例子,这次我们给一个dom元素给些css样式,就可以用下面的方法实现:\n\n    window.onload = function(){\n        setStyle([\"div1\",\"div2\",\"div3\"],{\n            \"width\":\"300px\",\n            \"height\":\"300px\",\n            \"backgroundColor\":\"red\",\n            \"font-size\":\"70px\"\n        });\n    };\n\n    /**\n     * 简单的门面模式\n     * @param ele\n     * @param css\n     */\n    function setStyle(ele,css){\n        for(var i = 0;i < ele.length;i ++){\n            for(var j in css){\n                (j in css) && (document.getElementById(ele[i]).style[j] = css[j]);\n            }\n        }\n    }\n\n在不使用门面模式的时候,完成这个功能可能需要下面这样来写:\n\n    window.onload = function(){\n        var ele = document.getElementById(\"div1\"),\n            ele2 = document.getElementById(\"div2\"),\n            ele3 = document.getElementById(\"div3\"),\n            eleArr = [ele,ele2,ele3];\n            \n        for(var i = 0,l = eleArr.length;i < l;i ++){\n            ele[i].style.width = \"300px\";\n            ele[i].style.height = \"300px\";\n            .\n            .\n            .\n        }\n    }; \n\n其实在jQuery或者其他很多前端类库中,用很多这样的接口,它们都给我们提供了门面模式,使得我们只需要调用一个方法就免去了很多的兼容性写法(比如ajax)。\n\n门面模式大概有下面几个优点\n\n1.解耦(降低了客户端与子系统的耦合关系,让子系统内部的模块能更容易扩展和维护)    \n2.简单易用(只需要调用门面接口,即可完成某些特定功能)    \n3.更好的划分访问层次(有些方法是对内的,有些方法是需要暴露到外部的,这样既方便外部使用,又方便内部维护)\n","source":"_posts/2015-06-21-js-design-mode-facade.md","raw":"---\nlayout: post\ntitle: javascript门面模式\ndate: 2015-06-21\ncategories: [javascript, 设计模式]\n---\n\n在javascript中，门面模式常常是开发人员最亲密的朋友。它是几乎所有javascript库的核心原则。通过创建一些使得方法让复杂系统变得更加简单易用,门面模式可以使库提供的工具更容易理解。\n\n先来看看门面模式的写法:\n\n    function a(x){\n        //  do something...\n    }\n    \n    function b(y){\n        //  do something...\n    }\n    \n    /**\n     * 把a和b封装成一个方法(在一个方法里同时调用a、b)\n     * @param x\n     * @param y\n     */\n    function facadeAB(x,y){\n        a(x);\n        b(y);\n    }\n\n在我们平时开发中,可能就用到了门面模式,比如我们现在封装一个绑定事件的方法:\n\n    function bindEvent(el,ev,fn){\n        if(el.addEventListner){\n            el.addEventListener(ev,fn,false);\n        }else if(el.attachEvent){\n            el.attachEvent(\"on\" + ev,fn);\n        }else{\n            el[\"on\" + ev] = fn;\n        }\n    };\n    \n这个就是一个门面模式,里面对于事件的绑定是隐蔽的,只提供bindEvent给其他地方调用。\n\n再来看个例子,这次我们给一个dom元素给些css样式,就可以用下面的方法实现:\n\n    window.onload = function(){\n        setStyle([\"div1\",\"div2\",\"div3\"],{\n            \"width\":\"300px\",\n            \"height\":\"300px\",\n            \"backgroundColor\":\"red\",\n            \"font-size\":\"70px\"\n        });\n    };\n\n    /**\n     * 简单的门面模式\n     * @param ele\n     * @param css\n     */\n    function setStyle(ele,css){\n        for(var i = 0;i < ele.length;i ++){\n            for(var j in css){\n                (j in css) && (document.getElementById(ele[i]).style[j] = css[j]);\n            }\n        }\n    }\n\n在不使用门面模式的时候,完成这个功能可能需要下面这样来写:\n\n    window.onload = function(){\n        var ele = document.getElementById(\"div1\"),\n            ele2 = document.getElementById(\"div2\"),\n            ele3 = document.getElementById(\"div3\"),\n            eleArr = [ele,ele2,ele3];\n            \n        for(var i = 0,l = eleArr.length;i < l;i ++){\n            ele[i].style.width = \"300px\";\n            ele[i].style.height = \"300px\";\n            .\n            .\n            .\n        }\n    }; \n\n其实在jQuery或者其他很多前端类库中,用很多这样的接口,它们都给我们提供了门面模式,使得我们只需要调用一个方法就免去了很多的兼容性写法(比如ajax)。\n\n门面模式大概有下面几个优点\n\n1.解耦(降低了客户端与子系统的耦合关系,让子系统内部的模块能更容易扩展和维护)    \n2.简单易用(只需要调用门面接口,即可完成某些特定功能)    \n3.更好的划分访问层次(有些方法是对内的,有些方法是需要暴露到外部的,这样既方便外部使用,又方便内部维护)\n","slug":"2015-06-21-js-design-mode-facade","published":1,"updated":"2016-11-09T14:00:46.000Z","_id":"civ7fseem000kt95fg2rsxyss","comments":1,"photos":[],"link":"","content":"<p>在javascript中，门面模式常常是开发人员最亲密的朋友。它是几乎所有javascript库的核心原则。通过创建一些使得方法让复杂系统变得更加简单易用,门面模式可以使库提供的工具更容易理解。</p>\n<p>先来看看门面模式的写法:</p>\n<pre><code>function a(x){\n    //  do something...\n}\n\nfunction b(y){\n    //  do something...\n}\n\n/**\n * 把a和b封装成一个方法(在一个方法里同时调用a、b)\n * @param x\n * @param y\n */\nfunction facadeAB(x,y){\n    a(x);\n    b(y);\n}\n</code></pre><p>在我们平时开发中,可能就用到了门面模式,比如我们现在封装一个绑定事件的方法:</p>\n<pre><code>function bindEvent(el,ev,fn){\n    if(el.addEventListner){\n        el.addEventListener(ev,fn,false);\n    }else if(el.attachEvent){\n        el.attachEvent(&quot;on&quot; + ev,fn);\n    }else{\n        el[&quot;on&quot; + ev] = fn;\n    }\n};\n</code></pre><p>这个就是一个门面模式,里面对于事件的绑定是隐蔽的,只提供bindEvent给其他地方调用。</p>\n<p>再来看个例子,这次我们给一个dom元素给些css样式,就可以用下面的方法实现:</p>\n<pre><code>window.onload = function(){\n    setStyle([&quot;div1&quot;,&quot;div2&quot;,&quot;div3&quot;],{\n        &quot;width&quot;:&quot;300px&quot;,\n        &quot;height&quot;:&quot;300px&quot;,\n        &quot;backgroundColor&quot;:&quot;red&quot;,\n        &quot;font-size&quot;:&quot;70px&quot;\n    });\n};\n\n/**\n * 简单的门面模式\n * @param ele\n * @param css\n */\nfunction setStyle(ele,css){\n    for(var i = 0;i &lt; ele.length;i ++){\n        for(var j in css){\n            (j in css) &amp;&amp; (document.getElementById(ele[i]).style[j] = css[j]);\n        }\n    }\n}\n</code></pre><p>在不使用门面模式的时候,完成这个功能可能需要下面这样来写:</p>\n<pre><code>window.onload = function(){\n    var ele = document.getElementById(&quot;div1&quot;),\n        ele2 = document.getElementById(&quot;div2&quot;),\n        ele3 = document.getElementById(&quot;div3&quot;),\n        eleArr = [ele,ele2,ele3];\n\n    for(var i = 0,l = eleArr.length;i &lt; l;i ++){\n        ele[i].style.width = &quot;300px&quot;;\n        ele[i].style.height = &quot;300px&quot;;\n        .\n        .\n        .\n    }\n}; \n</code></pre><p>其实在jQuery或者其他很多前端类库中,用很多这样的接口,它们都给我们提供了门面模式,使得我们只需要调用一个方法就免去了很多的兼容性写法(比如ajax)。</p>\n<p>门面模式大概有下面几个优点</p>\n<p>1.解耦(降低了客户端与子系统的耦合关系,让子系统内部的模块能更容易扩展和维护)<br>2.简单易用(只需要调用门面接口,即可完成某些特定功能)<br>3.更好的划分访问层次(有些方法是对内的,有些方法是需要暴露到外部的,这样既方便外部使用,又方便内部维护)</p>\n","excerpt":"","more":"<p>在javascript中，门面模式常常是开发人员最亲密的朋友。它是几乎所有javascript库的核心原则。通过创建一些使得方法让复杂系统变得更加简单易用,门面模式可以使库提供的工具更容易理解。</p>\n<p>先来看看门面模式的写法:</p>\n<pre><code>function a(x){\n    //  do something...\n}\n\nfunction b(y){\n    //  do something...\n}\n\n/**\n * 把a和b封装成一个方法(在一个方法里同时调用a、b)\n * @param x\n * @param y\n */\nfunction facadeAB(x,y){\n    a(x);\n    b(y);\n}\n</code></pre><p>在我们平时开发中,可能就用到了门面模式,比如我们现在封装一个绑定事件的方法:</p>\n<pre><code>function bindEvent(el,ev,fn){\n    if(el.addEventListner){\n        el.addEventListener(ev,fn,false);\n    }else if(el.attachEvent){\n        el.attachEvent(&quot;on&quot; + ev,fn);\n    }else{\n        el[&quot;on&quot; + ev] = fn;\n    }\n};\n</code></pre><p>这个就是一个门面模式,里面对于事件的绑定是隐蔽的,只提供bindEvent给其他地方调用。</p>\n<p>再来看个例子,这次我们给一个dom元素给些css样式,就可以用下面的方法实现:</p>\n<pre><code>window.onload = function(){\n    setStyle([&quot;div1&quot;,&quot;div2&quot;,&quot;div3&quot;],{\n        &quot;width&quot;:&quot;300px&quot;,\n        &quot;height&quot;:&quot;300px&quot;,\n        &quot;backgroundColor&quot;:&quot;red&quot;,\n        &quot;font-size&quot;:&quot;70px&quot;\n    });\n};\n\n/**\n * 简单的门面模式\n * @param ele\n * @param css\n */\nfunction setStyle(ele,css){\n    for(var i = 0;i &lt; ele.length;i ++){\n        for(var j in css){\n            (j in css) &amp;&amp; (document.getElementById(ele[i]).style[j] = css[j]);\n        }\n    }\n}\n</code></pre><p>在不使用门面模式的时候,完成这个功能可能需要下面这样来写:</p>\n<pre><code>window.onload = function(){\n    var ele = document.getElementById(&quot;div1&quot;),\n        ele2 = document.getElementById(&quot;div2&quot;),\n        ele3 = document.getElementById(&quot;div3&quot;),\n        eleArr = [ele,ele2,ele3];\n\n    for(var i = 0,l = eleArr.length;i &lt; l;i ++){\n        ele[i].style.width = &quot;300px&quot;;\n        ele[i].style.height = &quot;300px&quot;;\n        .\n        .\n        .\n    }\n}; \n</code></pre><p>其实在jQuery或者其他很多前端类库中,用很多这样的接口,它们都给我们提供了门面模式,使得我们只需要调用一个方法就免去了很多的兼容性写法(比如ajax)。</p>\n<p>门面模式大概有下面几个优点</p>\n<p>1.解耦(降低了客户端与子系统的耦合关系,让子系统内部的模块能更容易扩展和维护)<br>2.简单易用(只需要调用门面接口,即可完成某些特定功能)<br>3.更好的划分访问层次(有些方法是对内的,有些方法是需要暴露到外部的,这样既方便外部使用,又方便内部维护)</p>\n"},{"layout":"post","title":"javascript装饰者模式","date":"2015-07-14T16:00:00.000Z","_content":"\njs装饰者模式可以把一个对象(类/函数)透明地包装在另外一个对象上,完成对被装饰者添加一些新功能的作用。\n\n装饰者模式的特点:\n- 不修改原对象的原本结构来进行功能添加;\n- 装饰对象和原对象具有相同的接口，可以使客户以与原对象相同的方式使用装饰对象;\n- 装饰对象中包含原对象的引用，即装饰对象为真正的原对象在此包装的对象。\n\n\n先看个小例子:\n\n        function getDate(){\n        var date = new Date();\n        return date.toString();\n    }\n    function toUpperCaseDecorator(fn){\n        return (function(f){\n            return f.apply(this,arguments).toUpperCase();\n        })(fn);\n    }\n    console.log(getDate());\n    //  Thu Jun 25 2015 23:05:04 GMT+0800 (CST)\n    console.log(toUpperCaseDecorator(getDate));\n    //  THU JUN 25 2015 23:05:04 GMT+0800 (CST)\n        \n在上面的例子中,getDate作为一个被装饰者(完成获取当前时间的字符串形式),toUpperCaseDecorator作为一个装饰者,在原来的基础上把原来的小写字母改成了大小,在这里就相当于添加了一个新功能。\n\n下面我们就还是拿汽车来模拟一个具体的场景:\n\n需求:现在要造一辆车,既然是车嘛,肯定有很多的零部件,这里就拿车载冰箱和车灯来说吧;比如我的车主结构20000元,车载冰箱10000元,车灯10000元,那我肯定在组装的时候就把价格给它加上去,来看具体的代码。\n\n        var CarInterface = new commonUtil.Interface(\"CarInterface\",[\"getPrice\",\"assenble\"]);\n        //  定义\n        function Car(car){\n            this.car = car;\n            //  为了让子类继承(让子类多一个父类的引用)\n            commonUtil.Interface.ensureImplement(this,CarInterface);\n            //  检测接口\n        }\n        commonUtil.wrap(Car.prototype,{\n            \"constructor\":Car,\n            \"getPrice\":function(){\n                return 200000;\n            },\n            \"assenble\":function(){\n                console.log(\"组装汽车\");\n            }\n        });\n        //  新需求:加上light,icebox\n        function lightDecorator(car){\n            //  参数car代表原始对象\n            lightDecorator.superClass.constructor.call(this,car);\n            //  构造方法继承\n            //  this.car = car;\n            //  为了让子类继承(让子类多一个父类的引用)\n            //  commonUtil.ensureImplement(this,CarInterface);\n            //  检测接口\n        }\n        commonUtil.extend(lightDecorator,Car);\n        //  继承\n        commonUtil.wrap(lightDecorator.prototype,{\n            \"constructor\":lightDecorator,\n            \"getPrice\":function(){\n                return this.car.getPrice() + 10000;\n            },\n            \"assenble\":function(){\n                console.log(\"组装车灯\");\n            }\n        });\n        //  重写父类的方法会影响继承过来的方法\n        function iceBoxDecorator(car){\n            //  参数car代表原始对象\n            iceBoxDecorator.superClass.constructor.call(this,car);\n            //  构造方法继承\n            //  this.car = car;\n            //  为了让子类继承(让子类多一个父类的引用)\n            //  commonUtil.ensureImplement(this,CarInterface);\n            //  检测接口\n        }\n        commonUtil.extend(iceBoxDecorator,Car);\n        //  继承\n        commonUtil.wrap(iceBoxDecorator.prototype,{\n            \"constructor\":iceBoxDecorator,\n            \"getPrice\":function(){\n                return this.car.getPrice() + 20000;\n            },\n            \"assenble\":function(){\n                console.log(\"组装冰箱\");\n            }\n        });\n        var car = new Car();\n        console.log(car.getPrice());\n        car.assenble();\n        car = new lightDecorator(car);\n        //  在原来的基础上装上车灯\n        console.log(car.getPrice());\n        car = new iceBoxDecorator(car);\n        //  在原来的基础上装上车载冰箱\n        console.log(car.getPrice());\n        \n通过上面的代码,我们的车就由原来的车框架,给它装上了车载冰箱和车灯,同时又没有修改原来车这个类的代码而拓展了它的功能。实现方式就是定义一个父类Car,提供一些原型方法,然后再定义子类来继承车这个类,并对父类的方法进行重写。\n","source":"_posts/2015-07-15-js-design-mode-decorator.md","raw":"---\nlayout: post\ntitle: javascript装饰者模式\ndate: 2015-07-15\ncategories: [javascript, 设计模式]\n---\n\njs装饰者模式可以把一个对象(类/函数)透明地包装在另外一个对象上,完成对被装饰者添加一些新功能的作用。\n\n装饰者模式的特点:\n- 不修改原对象的原本结构来进行功能添加;\n- 装饰对象和原对象具有相同的接口，可以使客户以与原对象相同的方式使用装饰对象;\n- 装饰对象中包含原对象的引用，即装饰对象为真正的原对象在此包装的对象。\n\n\n先看个小例子:\n\n        function getDate(){\n        var date = new Date();\n        return date.toString();\n    }\n    function toUpperCaseDecorator(fn){\n        return (function(f){\n            return f.apply(this,arguments).toUpperCase();\n        })(fn);\n    }\n    console.log(getDate());\n    //  Thu Jun 25 2015 23:05:04 GMT+0800 (CST)\n    console.log(toUpperCaseDecorator(getDate));\n    //  THU JUN 25 2015 23:05:04 GMT+0800 (CST)\n        \n在上面的例子中,getDate作为一个被装饰者(完成获取当前时间的字符串形式),toUpperCaseDecorator作为一个装饰者,在原来的基础上把原来的小写字母改成了大小,在这里就相当于添加了一个新功能。\n\n下面我们就还是拿汽车来模拟一个具体的场景:\n\n需求:现在要造一辆车,既然是车嘛,肯定有很多的零部件,这里就拿车载冰箱和车灯来说吧;比如我的车主结构20000元,车载冰箱10000元,车灯10000元,那我肯定在组装的时候就把价格给它加上去,来看具体的代码。\n\n        var CarInterface = new commonUtil.Interface(\"CarInterface\",[\"getPrice\",\"assenble\"]);\n        //  定义\n        function Car(car){\n            this.car = car;\n            //  为了让子类继承(让子类多一个父类的引用)\n            commonUtil.Interface.ensureImplement(this,CarInterface);\n            //  检测接口\n        }\n        commonUtil.wrap(Car.prototype,{\n            \"constructor\":Car,\n            \"getPrice\":function(){\n                return 200000;\n            },\n            \"assenble\":function(){\n                console.log(\"组装汽车\");\n            }\n        });\n        //  新需求:加上light,icebox\n        function lightDecorator(car){\n            //  参数car代表原始对象\n            lightDecorator.superClass.constructor.call(this,car);\n            //  构造方法继承\n            //  this.car = car;\n            //  为了让子类继承(让子类多一个父类的引用)\n            //  commonUtil.ensureImplement(this,CarInterface);\n            //  检测接口\n        }\n        commonUtil.extend(lightDecorator,Car);\n        //  继承\n        commonUtil.wrap(lightDecorator.prototype,{\n            \"constructor\":lightDecorator,\n            \"getPrice\":function(){\n                return this.car.getPrice() + 10000;\n            },\n            \"assenble\":function(){\n                console.log(\"组装车灯\");\n            }\n        });\n        //  重写父类的方法会影响继承过来的方法\n        function iceBoxDecorator(car){\n            //  参数car代表原始对象\n            iceBoxDecorator.superClass.constructor.call(this,car);\n            //  构造方法继承\n            //  this.car = car;\n            //  为了让子类继承(让子类多一个父类的引用)\n            //  commonUtil.ensureImplement(this,CarInterface);\n            //  检测接口\n        }\n        commonUtil.extend(iceBoxDecorator,Car);\n        //  继承\n        commonUtil.wrap(iceBoxDecorator.prototype,{\n            \"constructor\":iceBoxDecorator,\n            \"getPrice\":function(){\n                return this.car.getPrice() + 20000;\n            },\n            \"assenble\":function(){\n                console.log(\"组装冰箱\");\n            }\n        });\n        var car = new Car();\n        console.log(car.getPrice());\n        car.assenble();\n        car = new lightDecorator(car);\n        //  在原来的基础上装上车灯\n        console.log(car.getPrice());\n        car = new iceBoxDecorator(car);\n        //  在原来的基础上装上车载冰箱\n        console.log(car.getPrice());\n        \n通过上面的代码,我们的车就由原来的车框架,给它装上了车载冰箱和车灯,同时又没有修改原来车这个类的代码而拓展了它的功能。实现方式就是定义一个父类Car,提供一些原型方法,然后再定义子类来继承车这个类,并对父类的方法进行重写。\n","slug":"2015-07-15-js-design-mode-decorator","published":1,"updated":"2016-11-09T14:00:55.000Z","_id":"civ7fseeo000mt95f23426zvn","comments":1,"photos":[],"link":"","content":"<p>js装饰者模式可以把一个对象(类/函数)透明地包装在另外一个对象上,完成对被装饰者添加一些新功能的作用。</p>\n<p>装饰者模式的特点:</p>\n<ul>\n<li>不修改原对象的原本结构来进行功能添加;</li>\n<li>装饰对象和原对象具有相同的接口，可以使客户以与原对象相同的方式使用装饰对象;</li>\n<li>装饰对象中包含原对象的引用，即装饰对象为真正的原对象在此包装的对象。</li>\n</ul>\n<p>先看个小例子:</p>\n<pre><code>    function getDate(){\n    var date = new Date();\n    return date.toString();\n}\nfunction toUpperCaseDecorator(fn){\n    return (function(f){\n        return f.apply(this,arguments).toUpperCase();\n    })(fn);\n}\nconsole.log(getDate());\n//  Thu Jun 25 2015 23:05:04 GMT+0800 (CST)\nconsole.log(toUpperCaseDecorator(getDate));\n//  THU JUN 25 2015 23:05:04 GMT+0800 (CST)\n</code></pre><p>在上面的例子中,getDate作为一个被装饰者(完成获取当前时间的字符串形式),toUpperCaseDecorator作为一个装饰者,在原来的基础上把原来的小写字母改成了大小,在这里就相当于添加了一个新功能。</p>\n<p>下面我们就还是拿汽车来模拟一个具体的场景:</p>\n<p>需求:现在要造一辆车,既然是车嘛,肯定有很多的零部件,这里就拿车载冰箱和车灯来说吧;比如我的车主结构20000元,车载冰箱10000元,车灯10000元,那我肯定在组装的时候就把价格给它加上去,来看具体的代码。</p>\n<pre><code>var CarInterface = new commonUtil.Interface(&quot;CarInterface&quot;,[&quot;getPrice&quot;,&quot;assenble&quot;]);\n//  定义\nfunction Car(car){\n    this.car = car;\n    //  为了让子类继承(让子类多一个父类的引用)\n    commonUtil.Interface.ensureImplement(this,CarInterface);\n    //  检测接口\n}\ncommonUtil.wrap(Car.prototype,{\n    &quot;constructor&quot;:Car,\n    &quot;getPrice&quot;:function(){\n        return 200000;\n    },\n    &quot;assenble&quot;:function(){\n        console.log(&quot;组装汽车&quot;);\n    }\n});\n//  新需求:加上light,icebox\nfunction lightDecorator(car){\n    //  参数car代表原始对象\n    lightDecorator.superClass.constructor.call(this,car);\n    //  构造方法继承\n    //  this.car = car;\n    //  为了让子类继承(让子类多一个父类的引用)\n    //  commonUtil.ensureImplement(this,CarInterface);\n    //  检测接口\n}\ncommonUtil.extend(lightDecorator,Car);\n//  继承\ncommonUtil.wrap(lightDecorator.prototype,{\n    &quot;constructor&quot;:lightDecorator,\n    &quot;getPrice&quot;:function(){\n        return this.car.getPrice() + 10000;\n    },\n    &quot;assenble&quot;:function(){\n        console.log(&quot;组装车灯&quot;);\n    }\n});\n//  重写父类的方法会影响继承过来的方法\nfunction iceBoxDecorator(car){\n    //  参数car代表原始对象\n    iceBoxDecorator.superClass.constructor.call(this,car);\n    //  构造方法继承\n    //  this.car = car;\n    //  为了让子类继承(让子类多一个父类的引用)\n    //  commonUtil.ensureImplement(this,CarInterface);\n    //  检测接口\n}\ncommonUtil.extend(iceBoxDecorator,Car);\n//  继承\ncommonUtil.wrap(iceBoxDecorator.prototype,{\n    &quot;constructor&quot;:iceBoxDecorator,\n    &quot;getPrice&quot;:function(){\n        return this.car.getPrice() + 20000;\n    },\n    &quot;assenble&quot;:function(){\n        console.log(&quot;组装冰箱&quot;);\n    }\n});\nvar car = new Car();\nconsole.log(car.getPrice());\ncar.assenble();\ncar = new lightDecorator(car);\n//  在原来的基础上装上车灯\nconsole.log(car.getPrice());\ncar = new iceBoxDecorator(car);\n//  在原来的基础上装上车载冰箱\nconsole.log(car.getPrice());\n</code></pre><p>通过上面的代码,我们的车就由原来的车框架,给它装上了车载冰箱和车灯,同时又没有修改原来车这个类的代码而拓展了它的功能。实现方式就是定义一个父类Car,提供一些原型方法,然后再定义子类来继承车这个类,并对父类的方法进行重写。</p>\n","excerpt":"","more":"<p>js装饰者模式可以把一个对象(类/函数)透明地包装在另外一个对象上,完成对被装饰者添加一些新功能的作用。</p>\n<p>装饰者模式的特点:</p>\n<ul>\n<li>不修改原对象的原本结构来进行功能添加;</li>\n<li>装饰对象和原对象具有相同的接口，可以使客户以与原对象相同的方式使用装饰对象;</li>\n<li>装饰对象中包含原对象的引用，即装饰对象为真正的原对象在此包装的对象。</li>\n</ul>\n<p>先看个小例子:</p>\n<pre><code>    function getDate(){\n    var date = new Date();\n    return date.toString();\n}\nfunction toUpperCaseDecorator(fn){\n    return (function(f){\n        return f.apply(this,arguments).toUpperCase();\n    })(fn);\n}\nconsole.log(getDate());\n//  Thu Jun 25 2015 23:05:04 GMT+0800 (CST)\nconsole.log(toUpperCaseDecorator(getDate));\n//  THU JUN 25 2015 23:05:04 GMT+0800 (CST)\n</code></pre><p>在上面的例子中,getDate作为一个被装饰者(完成获取当前时间的字符串形式),toUpperCaseDecorator作为一个装饰者,在原来的基础上把原来的小写字母改成了大小,在这里就相当于添加了一个新功能。</p>\n<p>下面我们就还是拿汽车来模拟一个具体的场景:</p>\n<p>需求:现在要造一辆车,既然是车嘛,肯定有很多的零部件,这里就拿车载冰箱和车灯来说吧;比如我的车主结构20000元,车载冰箱10000元,车灯10000元,那我肯定在组装的时候就把价格给它加上去,来看具体的代码。</p>\n<pre><code>var CarInterface = new commonUtil.Interface(&quot;CarInterface&quot;,[&quot;getPrice&quot;,&quot;assenble&quot;]);\n//  定义\nfunction Car(car){\n    this.car = car;\n    //  为了让子类继承(让子类多一个父类的引用)\n    commonUtil.Interface.ensureImplement(this,CarInterface);\n    //  检测接口\n}\ncommonUtil.wrap(Car.prototype,{\n    &quot;constructor&quot;:Car,\n    &quot;getPrice&quot;:function(){\n        return 200000;\n    },\n    &quot;assenble&quot;:function(){\n        console.log(&quot;组装汽车&quot;);\n    }\n});\n//  新需求:加上light,icebox\nfunction lightDecorator(car){\n    //  参数car代表原始对象\n    lightDecorator.superClass.constructor.call(this,car);\n    //  构造方法继承\n    //  this.car = car;\n    //  为了让子类继承(让子类多一个父类的引用)\n    //  commonUtil.ensureImplement(this,CarInterface);\n    //  检测接口\n}\ncommonUtil.extend(lightDecorator,Car);\n//  继承\ncommonUtil.wrap(lightDecorator.prototype,{\n    &quot;constructor&quot;:lightDecorator,\n    &quot;getPrice&quot;:function(){\n        return this.car.getPrice() + 10000;\n    },\n    &quot;assenble&quot;:function(){\n        console.log(&quot;组装车灯&quot;);\n    }\n});\n//  重写父类的方法会影响继承过来的方法\nfunction iceBoxDecorator(car){\n    //  参数car代表原始对象\n    iceBoxDecorator.superClass.constructor.call(this,car);\n    //  构造方法继承\n    //  this.car = car;\n    //  为了让子类继承(让子类多一个父类的引用)\n    //  commonUtil.ensureImplement(this,CarInterface);\n    //  检测接口\n}\ncommonUtil.extend(iceBoxDecorator,Car);\n//  继承\ncommonUtil.wrap(iceBoxDecorator.prototype,{\n    &quot;constructor&quot;:iceBoxDecorator,\n    &quot;getPrice&quot;:function(){\n        return this.car.getPrice() + 20000;\n    },\n    &quot;assenble&quot;:function(){\n        console.log(&quot;组装冰箱&quot;);\n    }\n});\nvar car = new Car();\nconsole.log(car.getPrice());\ncar.assenble();\ncar = new lightDecorator(car);\n//  在原来的基础上装上车灯\nconsole.log(car.getPrice());\ncar = new iceBoxDecorator(car);\n//  在原来的基础上装上车载冰箱\nconsole.log(car.getPrice());\n</code></pre><p>通过上面的代码,我们的车就由原来的车框架,给它装上了车载冰箱和车灯,同时又没有修改原来车这个类的代码而拓展了它的功能。实现方式就是定义一个父类Car,提供一些原型方法,然后再定义子类来继承车这个类,并对父类的方法进行重写。</p>\n"},{"layout":"post","title":"javascript闭包","date":"2015-07-17T16:00:00.000Z","_content":"\n本文讨论的javascript不包含ES6标准。\n\njavascript在作用域和其他大多数语言不同, 没有局部变量的的概念,一个变量的作用范围就是它所在的函数,且没有块级作用域的概念。\n\n我们可以通过下面的代码理解下上面的话:\n\n    var variable1 = 1;\n\n    function A() {\n        console.log(variable1);\n        \n        if(true) {\n            var variable2 = \"variable2\";\n        }\n        \n        console.log(variable2);\n    }\n    \n    A();\n    //  最终打印出1和variable2这个字符串\n\n\n可能类似的代码放到其他语言中,我们在if外面访问variable2时,就会报错,但在javascript中不会。\n\n刚才说\"一个变量的作用范围就是它所在的函数\",可以通过下面的代码验证下:\n\n    function A() {\n        var variable1 = \"variable1\";\n    }\n    \n    A();\n    \n    console.log(variable1);\n    //  Uncaught ReferenceError: variable1 is not defined\n\n此时在函数外部就无法访问函数内定义的变量。\n\n但是如果不用var关键字的话,情况就不一样了\n\n    function A() {\n        variable1 = \"variable1\";\n    }\n    \n    A();\n    \n    console.log(variable1);\n    //  最终打印出variable1这个字符串\n\n因为不用var的话,就相当于声明了一个全局变量。\n\n但是有时候,我们就是想读取函数内部变量,该怎么做呢?可以像下面这样:\n\n\n    function A() {\n        \n        var variable1 = \"variable1\";\n        \n        return function() {\n            console.log(variable1);\n        };\n    \n    }\n    \n    A()();\n    \n这边调用了两对圆括号,第一对是取得A返回的匿名函数,第二对是执行该匿名函数。\n\n上面就是一个典型的闭包例子,用阮一峰大神的话说\"闭包就是能够读取其他函数内部变量的函数\"。\n\n在实际开发中,我们会在很多地方用到闭包,就是用到两个比较重要的作用:\n\n- 使某些变量常驻内存,且不与函数外部变量冲突\n- 子函数访问父函数的内容\n\n在很多著名类库/框架源码中,可能经常会看到类似的代码:\n\n    (function(root, undefined) {\n        \n        var var1 = xxx;\n        var var2 = yyy;\n        //  ...\n        \n        function zzz() {\n            //  ...\n        }\n        \n        root.zzz = zzz;\n        \n    })(window);\n\n就充分利用了第一条特性。\n\n第二条就是我们在前面的代码中有例子,就不做过多阐述。\n\n我们都知道javascript中没有类的概念,我们只能通过函数类模拟类,通过原型来实现继承,但是有时候有些成员属性是不能继承的或者不希望被外部直接访问到, 所以需要一些私有成员属性。\n\n下面我们模拟一个类,里面有私有成员属性:\n    \n    //  实现一个\"人\"类\n    function Person(name, age) {\n        \n        //  模拟私有成员属性\n        var _salary;\n        var _wife;\n        \n        //  getter/setter\n        this.salaryGetter = function() {\n            return _salary;\n        };\n        \n        this.salarySetter = function(salary) {\n            _salary = salary;\n        };\n        \n        this.wifeGetter = function() {\n            return _wife;\n        };\n        \n        this.wifeSetter = function(wife) {\n            _wife = wife;\n        };\n        \n        this.name = name;\n        this.age = age;\n        \n    }\n    \n    Person.prototype = {\n        \n        constructor: Person,\n        \n        eat: function() {\n            console.log(\"吃饭\");\n        },\n        \n        sleep: function() {\n            console.log(\"睡觉\");\n        }\n        \n        //  ...\n    \n    };\n    \n    function SubPerson(name, age) {\n        \n        //  构造器继承\n        Person.call(this,name,age);\n        \n    }\n    \n    SubPerson.prototype = new Person();\n    \n    \n    SubPerson.prototype.constructor = SubPerson;\n    \n    //  overwrite methods\n    \n    var person = new SubPerson(\"小宋\", 23);\n\n    console.log(person);\n    \n上面我们就完成了一个简单的继承和私有成员属性的模拟。\n\n关于闭包的应用例子还有很多,比如我们用js绑定事件的时候:\n\n\n    var listNodes = document.querySelectorAll(\"li\");\n    //  假设网页中有5个li元素\n    \n\n    for(var i = 0, len = listNodes.length; i < len; i ++) {\n        listNodes[i].onclick = function() {\n            //  do something\n            console.log(i);\n        }\n    }\n\n此时无论我们点击哪个元素,最后都会打印出5来,因为我们点击的时候循环已经结束,i的值变成了5,我们可以用闭包来解决这个问题:\n    \n    \n\n    var listNodes = document.querySelectorAll(\"li\");\n    //  假设网页中有5个li元素\n\n    for(var i = 0, len = listNodes.length; i < len; i ++) {\n        listNodes[i].onclick = (function(index){\n            return function() {\n                //  do something\n                console.log(index);\n            };\n        })(i);\n    }\n\n用上面的方法,我们就可以正确的打印出i的值。\n","source":"_posts/2015-07-18-javascript-closure.md","raw":"---\nlayout: post\ntitle: javascript闭包\ndate: 2015-07-18\ncategories: [javascript, 闭包]\n---\n\n本文讨论的javascript不包含ES6标准。\n\njavascript在作用域和其他大多数语言不同, 没有局部变量的的概念,一个变量的作用范围就是它所在的函数,且没有块级作用域的概念。\n\n我们可以通过下面的代码理解下上面的话:\n\n    var variable1 = 1;\n\n    function A() {\n        console.log(variable1);\n        \n        if(true) {\n            var variable2 = \"variable2\";\n        }\n        \n        console.log(variable2);\n    }\n    \n    A();\n    //  最终打印出1和variable2这个字符串\n\n\n可能类似的代码放到其他语言中,我们在if外面访问variable2时,就会报错,但在javascript中不会。\n\n刚才说\"一个变量的作用范围就是它所在的函数\",可以通过下面的代码验证下:\n\n    function A() {\n        var variable1 = \"variable1\";\n    }\n    \n    A();\n    \n    console.log(variable1);\n    //  Uncaught ReferenceError: variable1 is not defined\n\n此时在函数外部就无法访问函数内定义的变量。\n\n但是如果不用var关键字的话,情况就不一样了\n\n    function A() {\n        variable1 = \"variable1\";\n    }\n    \n    A();\n    \n    console.log(variable1);\n    //  最终打印出variable1这个字符串\n\n因为不用var的话,就相当于声明了一个全局变量。\n\n但是有时候,我们就是想读取函数内部变量,该怎么做呢?可以像下面这样:\n\n\n    function A() {\n        \n        var variable1 = \"variable1\";\n        \n        return function() {\n            console.log(variable1);\n        };\n    \n    }\n    \n    A()();\n    \n这边调用了两对圆括号,第一对是取得A返回的匿名函数,第二对是执行该匿名函数。\n\n上面就是一个典型的闭包例子,用阮一峰大神的话说\"闭包就是能够读取其他函数内部变量的函数\"。\n\n在实际开发中,我们会在很多地方用到闭包,就是用到两个比较重要的作用:\n\n- 使某些变量常驻内存,且不与函数外部变量冲突\n- 子函数访问父函数的内容\n\n在很多著名类库/框架源码中,可能经常会看到类似的代码:\n\n    (function(root, undefined) {\n        \n        var var1 = xxx;\n        var var2 = yyy;\n        //  ...\n        \n        function zzz() {\n            //  ...\n        }\n        \n        root.zzz = zzz;\n        \n    })(window);\n\n就充分利用了第一条特性。\n\n第二条就是我们在前面的代码中有例子,就不做过多阐述。\n\n我们都知道javascript中没有类的概念,我们只能通过函数类模拟类,通过原型来实现继承,但是有时候有些成员属性是不能继承的或者不希望被外部直接访问到, 所以需要一些私有成员属性。\n\n下面我们模拟一个类,里面有私有成员属性:\n    \n    //  实现一个\"人\"类\n    function Person(name, age) {\n        \n        //  模拟私有成员属性\n        var _salary;\n        var _wife;\n        \n        //  getter/setter\n        this.salaryGetter = function() {\n            return _salary;\n        };\n        \n        this.salarySetter = function(salary) {\n            _salary = salary;\n        };\n        \n        this.wifeGetter = function() {\n            return _wife;\n        };\n        \n        this.wifeSetter = function(wife) {\n            _wife = wife;\n        };\n        \n        this.name = name;\n        this.age = age;\n        \n    }\n    \n    Person.prototype = {\n        \n        constructor: Person,\n        \n        eat: function() {\n            console.log(\"吃饭\");\n        },\n        \n        sleep: function() {\n            console.log(\"睡觉\");\n        }\n        \n        //  ...\n    \n    };\n    \n    function SubPerson(name, age) {\n        \n        //  构造器继承\n        Person.call(this,name,age);\n        \n    }\n    \n    SubPerson.prototype = new Person();\n    \n    \n    SubPerson.prototype.constructor = SubPerson;\n    \n    //  overwrite methods\n    \n    var person = new SubPerson(\"小宋\", 23);\n\n    console.log(person);\n    \n上面我们就完成了一个简单的继承和私有成员属性的模拟。\n\n关于闭包的应用例子还有很多,比如我们用js绑定事件的时候:\n\n\n    var listNodes = document.querySelectorAll(\"li\");\n    //  假设网页中有5个li元素\n    \n\n    for(var i = 0, len = listNodes.length; i < len; i ++) {\n        listNodes[i].onclick = function() {\n            //  do something\n            console.log(i);\n        }\n    }\n\n此时无论我们点击哪个元素,最后都会打印出5来,因为我们点击的时候循环已经结束,i的值变成了5,我们可以用闭包来解决这个问题:\n    \n    \n\n    var listNodes = document.querySelectorAll(\"li\");\n    //  假设网页中有5个li元素\n\n    for(var i = 0, len = listNodes.length; i < len; i ++) {\n        listNodes[i].onclick = (function(index){\n            return function() {\n                //  do something\n                console.log(index);\n            };\n        })(i);\n    }\n\n用上面的方法,我们就可以正确的打印出i的值。\n","slug":"2015-07-18-javascript-closure","published":1,"updated":"2016-11-09T14:01:04.000Z","_id":"civ7fseeq000ot95f2enhdc8q","comments":1,"photos":[],"link":"","content":"<p>本文讨论的javascript不包含ES6标准。</p>\n<p>javascript在作用域和其他大多数语言不同, 没有局部变量的的概念,一个变量的作用范围就是它所在的函数,且没有块级作用域的概念。</p>\n<p>我们可以通过下面的代码理解下上面的话:</p>\n<pre><code>var variable1 = 1;\n\nfunction A() {\n    console.log(variable1);\n\n    if(true) {\n        var variable2 = &quot;variable2&quot;;\n    }\n\n    console.log(variable2);\n}\n\nA();\n//  最终打印出1和variable2这个字符串\n</code></pre><p>可能类似的代码放到其他语言中,我们在if外面访问variable2时,就会报错,但在javascript中不会。</p>\n<p>刚才说”一个变量的作用范围就是它所在的函数”,可以通过下面的代码验证下:</p>\n<pre><code>function A() {\n    var variable1 = &quot;variable1&quot;;\n}\n\nA();\n\nconsole.log(variable1);\n//  Uncaught ReferenceError: variable1 is not defined\n</code></pre><p>此时在函数外部就无法访问函数内定义的变量。</p>\n<p>但是如果不用var关键字的话,情况就不一样了</p>\n<pre><code>function A() {\n    variable1 = &quot;variable1&quot;;\n}\n\nA();\n\nconsole.log(variable1);\n//  最终打印出variable1这个字符串\n</code></pre><p>因为不用var的话,就相当于声明了一个全局变量。</p>\n<p>但是有时候,我们就是想读取函数内部变量,该怎么做呢?可以像下面这样:</p>\n<pre><code>function A() {\n\n    var variable1 = &quot;variable1&quot;;\n\n    return function() {\n        console.log(variable1);\n    };\n\n}\n\nA()();\n</code></pre><p>这边调用了两对圆括号,第一对是取得A返回的匿名函数,第二对是执行该匿名函数。</p>\n<p>上面就是一个典型的闭包例子,用阮一峰大神的话说”闭包就是能够读取其他函数内部变量的函数”。</p>\n<p>在实际开发中,我们会在很多地方用到闭包,就是用到两个比较重要的作用:</p>\n<ul>\n<li>使某些变量常驻内存,且不与函数外部变量冲突</li>\n<li>子函数访问父函数的内容</li>\n</ul>\n<p>在很多著名类库/框架源码中,可能经常会看到类似的代码:</p>\n<pre><code>(function(root, undefined) {\n\n    var var1 = xxx;\n    var var2 = yyy;\n    //  ...\n\n    function zzz() {\n        //  ...\n    }\n\n    root.zzz = zzz;\n\n})(window);\n</code></pre><p>就充分利用了第一条特性。</p>\n<p>第二条就是我们在前面的代码中有例子,就不做过多阐述。</p>\n<p>我们都知道javascript中没有类的概念,我们只能通过函数类模拟类,通过原型来实现继承,但是有时候有些成员属性是不能继承的或者不希望被外部直接访问到, 所以需要一些私有成员属性。</p>\n<p>下面我们模拟一个类,里面有私有成员属性:</p>\n<pre><code>//  实现一个&quot;人&quot;类\nfunction Person(name, age) {\n\n    //  模拟私有成员属性\n    var _salary;\n    var _wife;\n\n    //  getter/setter\n    this.salaryGetter = function() {\n        return _salary;\n    };\n\n    this.salarySetter = function(salary) {\n        _salary = salary;\n    };\n\n    this.wifeGetter = function() {\n        return _wife;\n    };\n\n    this.wifeSetter = function(wife) {\n        _wife = wife;\n    };\n\n    this.name = name;\n    this.age = age;\n\n}\n\nPerson.prototype = {\n\n    constructor: Person,\n\n    eat: function() {\n        console.log(&quot;吃饭&quot;);\n    },\n\n    sleep: function() {\n        console.log(&quot;睡觉&quot;);\n    }\n\n    //  ...\n\n};\n\nfunction SubPerson(name, age) {\n\n    //  构造器继承\n    Person.call(this,name,age);\n\n}\n\nSubPerson.prototype = new Person();\n\n\nSubPerson.prototype.constructor = SubPerson;\n\n//  overwrite methods\n\nvar person = new SubPerson(&quot;小宋&quot;, 23);\n\nconsole.log(person);\n</code></pre><p>上面我们就完成了一个简单的继承和私有成员属性的模拟。</p>\n<p>关于闭包的应用例子还有很多,比如我们用js绑定事件的时候:</p>\n<pre><code>var listNodes = document.querySelectorAll(&quot;li&quot;);\n//  假设网页中有5个li元素\n\n\nfor(var i = 0, len = listNodes.length; i &lt; len; i ++) {\n    listNodes[i].onclick = function() {\n        //  do something\n        console.log(i);\n    }\n}\n</code></pre><p>此时无论我们点击哪个元素,最后都会打印出5来,因为我们点击的时候循环已经结束,i的值变成了5,我们可以用闭包来解决这个问题:</p>\n<pre><code>var listNodes = document.querySelectorAll(&quot;li&quot;);\n//  假设网页中有5个li元素\n\nfor(var i = 0, len = listNodes.length; i &lt; len; i ++) {\n    listNodes[i].onclick = (function(index){\n        return function() {\n            //  do something\n            console.log(index);\n        };\n    })(i);\n}\n</code></pre><p>用上面的方法,我们就可以正确的打印出i的值。</p>\n","excerpt":"","more":"<p>本文讨论的javascript不包含ES6标准。</p>\n<p>javascript在作用域和其他大多数语言不同, 没有局部变量的的概念,一个变量的作用范围就是它所在的函数,且没有块级作用域的概念。</p>\n<p>我们可以通过下面的代码理解下上面的话:</p>\n<pre><code>var variable1 = 1;\n\nfunction A() {\n    console.log(variable1);\n\n    if(true) {\n        var variable2 = &quot;variable2&quot;;\n    }\n\n    console.log(variable2);\n}\n\nA();\n//  最终打印出1和variable2这个字符串\n</code></pre><p>可能类似的代码放到其他语言中,我们在if外面访问variable2时,就会报错,但在javascript中不会。</p>\n<p>刚才说”一个变量的作用范围就是它所在的函数”,可以通过下面的代码验证下:</p>\n<pre><code>function A() {\n    var variable1 = &quot;variable1&quot;;\n}\n\nA();\n\nconsole.log(variable1);\n//  Uncaught ReferenceError: variable1 is not defined\n</code></pre><p>此时在函数外部就无法访问函数内定义的变量。</p>\n<p>但是如果不用var关键字的话,情况就不一样了</p>\n<pre><code>function A() {\n    variable1 = &quot;variable1&quot;;\n}\n\nA();\n\nconsole.log(variable1);\n//  最终打印出variable1这个字符串\n</code></pre><p>因为不用var的话,就相当于声明了一个全局变量。</p>\n<p>但是有时候,我们就是想读取函数内部变量,该怎么做呢?可以像下面这样:</p>\n<pre><code>function A() {\n\n    var variable1 = &quot;variable1&quot;;\n\n    return function() {\n        console.log(variable1);\n    };\n\n}\n\nA()();\n</code></pre><p>这边调用了两对圆括号,第一对是取得A返回的匿名函数,第二对是执行该匿名函数。</p>\n<p>上面就是一个典型的闭包例子,用阮一峰大神的话说”闭包就是能够读取其他函数内部变量的函数”。</p>\n<p>在实际开发中,我们会在很多地方用到闭包,就是用到两个比较重要的作用:</p>\n<ul>\n<li>使某些变量常驻内存,且不与函数外部变量冲突</li>\n<li>子函数访问父函数的内容</li>\n</ul>\n<p>在很多著名类库/框架源码中,可能经常会看到类似的代码:</p>\n<pre><code>(function(root, undefined) {\n\n    var var1 = xxx;\n    var var2 = yyy;\n    //  ...\n\n    function zzz() {\n        //  ...\n    }\n\n    root.zzz = zzz;\n\n})(window);\n</code></pre><p>就充分利用了第一条特性。</p>\n<p>第二条就是我们在前面的代码中有例子,就不做过多阐述。</p>\n<p>我们都知道javascript中没有类的概念,我们只能通过函数类模拟类,通过原型来实现继承,但是有时候有些成员属性是不能继承的或者不希望被外部直接访问到, 所以需要一些私有成员属性。</p>\n<p>下面我们模拟一个类,里面有私有成员属性:</p>\n<pre><code>//  实现一个&quot;人&quot;类\nfunction Person(name, age) {\n\n    //  模拟私有成员属性\n    var _salary;\n    var _wife;\n\n    //  getter/setter\n    this.salaryGetter = function() {\n        return _salary;\n    };\n\n    this.salarySetter = function(salary) {\n        _salary = salary;\n    };\n\n    this.wifeGetter = function() {\n        return _wife;\n    };\n\n    this.wifeSetter = function(wife) {\n        _wife = wife;\n    };\n\n    this.name = name;\n    this.age = age;\n\n}\n\nPerson.prototype = {\n\n    constructor: Person,\n\n    eat: function() {\n        console.log(&quot;吃饭&quot;);\n    },\n\n    sleep: function() {\n        console.log(&quot;睡觉&quot;);\n    }\n\n    //  ...\n\n};\n\nfunction SubPerson(name, age) {\n\n    //  构造器继承\n    Person.call(this,name,age);\n\n}\n\nSubPerson.prototype = new Person();\n\n\nSubPerson.prototype.constructor = SubPerson;\n\n//  overwrite methods\n\nvar person = new SubPerson(&quot;小宋&quot;, 23);\n\nconsole.log(person);\n</code></pre><p>上面我们就完成了一个简单的继承和私有成员属性的模拟。</p>\n<p>关于闭包的应用例子还有很多,比如我们用js绑定事件的时候:</p>\n<pre><code>var listNodes = document.querySelectorAll(&quot;li&quot;);\n//  假设网页中有5个li元素\n\n\nfor(var i = 0, len = listNodes.length; i &lt; len; i ++) {\n    listNodes[i].onclick = function() {\n        //  do something\n        console.log(i);\n    }\n}\n</code></pre><p>此时无论我们点击哪个元素,最后都会打印出5来,因为我们点击的时候循环已经结束,i的值变成了5,我们可以用闭包来解决这个问题:</p>\n<pre><code>var listNodes = document.querySelectorAll(&quot;li&quot;);\n//  假设网页中有5个li元素\n\nfor(var i = 0, len = listNodes.length; i &lt; len; i ++) {\n    listNodes[i].onclick = (function(index){\n        return function() {\n            //  do something\n            console.log(index);\n        };\n    })(i);\n}\n</code></pre><p>用上面的方法,我们就可以正确的打印出i的值。</p>\n"},{"layout":"post","title":"javascript变量提升","date":"2015-07-19T16:00:00.000Z","_content":"\n在日常开发中有时候可能会遇到下面的情况:\n\n    var var1 = 1;\n    function fn() {\n        console.log(var1);\n        var var1 = 2;\n        console.log(var1);\n    }\n    \n    fn();   \n    //  undefined\n    //  2\n\n第一次遇到的人可能会觉得很奇怪(因为外面定义了同名变量,所以第一次应该打印出1),为什么会有这种情况出现呢？我们把代码改成下面的样子就方便理解了:\n\n\n    var var1 = 1;\n    function fn() {\n        var var1;\n        //  如果不给变量赋初值,它的值就是undefined\n        console.log(var1);\n        var1 = 2;\n        console.log(var1);\n    }\n\n这就是javascript中的变量提升。\nMDN上的解释是\"变量提升是JavaScript将声明移至作用域scope (全局域或者当前函数作用域) 顶部的行为\"。\n\n除了变量,函数也存在变量提升的情况,但是如果用函数直接量法定义一个函数,会报类型异常:\n\n\n    function fn() {\n        fnInner();\n        \n        var fnInner = function() {\n            console.log(\"inner fn\");\n        }\n    }\n    \n    fn();\n    //  类型异常(undefined is not a function)\n\n就像刚才说的,fnInner会被放到函数体的第一行,但是没有赋初值,所以就成了undefined。\n\n但是如果用正常函数声明的方法就可以被正确调用,就像下面的样子:\n\n\n    function fn() {\n        fnInner();\n        \n        function fnInner() {\n            console.log(\"inner fn\");\n        }\n    }\n    \n    fn();\n    \n甚至有次在angularjs源码中(1.x)看到下面的使用方式:\n\n    function x() {\n        //  do something\n        return {\n            attr1: fn1(),\n            attr2: fn2()\n            //  ...\n        };\n        \n        function fn1() {\n            //  do something\n            return {\n                //  ...\n            };\n        }\n\n        function fn2() {\n            //  do something\n            return {\n                //  ...\n            };\n        }\n    }\n\n当时一看觉得很诧异,主要是一般return以后不能再写代码了,但是又仔细一想,是变量提升的作用。\n\n即使变量提升给我们带来了很大的便利(函数可以在被调用之后声明),但是我们也应该养成变量先定义后使用的习惯,一是提升代码的可读性(不至于在函数体内这里定义一个变量那里定义一个变量的),二是不至于出现一些意想不到的错误或异常。\n\n在ES6中,如果我们用let来定义变量,但是在它定义之前使用,就会报错(使用typeof也会异常),可能ES6也强制我们养成\"先定义后调用\"的习惯吧。\n\n","source":"_posts/2015-07-20-javascript-variable-promotion.md","raw":"---\nlayout: post\ntitle: javascript变量提升\ndate: 2015-07-20\ncategories: [javascript, 变量提升]\n---\n\n在日常开发中有时候可能会遇到下面的情况:\n\n    var var1 = 1;\n    function fn() {\n        console.log(var1);\n        var var1 = 2;\n        console.log(var1);\n    }\n    \n    fn();   \n    //  undefined\n    //  2\n\n第一次遇到的人可能会觉得很奇怪(因为外面定义了同名变量,所以第一次应该打印出1),为什么会有这种情况出现呢？我们把代码改成下面的样子就方便理解了:\n\n\n    var var1 = 1;\n    function fn() {\n        var var1;\n        //  如果不给变量赋初值,它的值就是undefined\n        console.log(var1);\n        var1 = 2;\n        console.log(var1);\n    }\n\n这就是javascript中的变量提升。\nMDN上的解释是\"变量提升是JavaScript将声明移至作用域scope (全局域或者当前函数作用域) 顶部的行为\"。\n\n除了变量,函数也存在变量提升的情况,但是如果用函数直接量法定义一个函数,会报类型异常:\n\n\n    function fn() {\n        fnInner();\n        \n        var fnInner = function() {\n            console.log(\"inner fn\");\n        }\n    }\n    \n    fn();\n    //  类型异常(undefined is not a function)\n\n就像刚才说的,fnInner会被放到函数体的第一行,但是没有赋初值,所以就成了undefined。\n\n但是如果用正常函数声明的方法就可以被正确调用,就像下面的样子:\n\n\n    function fn() {\n        fnInner();\n        \n        function fnInner() {\n            console.log(\"inner fn\");\n        }\n    }\n    \n    fn();\n    \n甚至有次在angularjs源码中(1.x)看到下面的使用方式:\n\n    function x() {\n        //  do something\n        return {\n            attr1: fn1(),\n            attr2: fn2()\n            //  ...\n        };\n        \n        function fn1() {\n            //  do something\n            return {\n                //  ...\n            };\n        }\n\n        function fn2() {\n            //  do something\n            return {\n                //  ...\n            };\n        }\n    }\n\n当时一看觉得很诧异,主要是一般return以后不能再写代码了,但是又仔细一想,是变量提升的作用。\n\n即使变量提升给我们带来了很大的便利(函数可以在被调用之后声明),但是我们也应该养成变量先定义后使用的习惯,一是提升代码的可读性(不至于在函数体内这里定义一个变量那里定义一个变量的),二是不至于出现一些意想不到的错误或异常。\n\n在ES6中,如果我们用let来定义变量,但是在它定义之前使用,就会报错(使用typeof也会异常),可能ES6也强制我们养成\"先定义后调用\"的习惯吧。\n\n","slug":"2015-07-20-javascript-variable-promotion","published":1,"updated":"2016-11-09T14:01:14.000Z","_id":"civ7fseeu000qt95fa01hlx0o","comments":1,"photos":[],"link":"","content":"<p>在日常开发中有时候可能会遇到下面的情况:</p>\n<pre><code>var var1 = 1;\nfunction fn() {\n    console.log(var1);\n    var var1 = 2;\n    console.log(var1);\n}\n\nfn();   \n//  undefined\n//  2\n</code></pre><p>第一次遇到的人可能会觉得很奇怪(因为外面定义了同名变量,所以第一次应该打印出1),为什么会有这种情况出现呢？我们把代码改成下面的样子就方便理解了:</p>\n<pre><code>var var1 = 1;\nfunction fn() {\n    var var1;\n    //  如果不给变量赋初值,它的值就是undefined\n    console.log(var1);\n    var1 = 2;\n    console.log(var1);\n}\n</code></pre><p>这就是javascript中的变量提升。<br>MDN上的解释是”变量提升是JavaScript将声明移至作用域scope (全局域或者当前函数作用域) 顶部的行为”。</p>\n<p>除了变量,函数也存在变量提升的情况,但是如果用函数直接量法定义一个函数,会报类型异常:</p>\n<pre><code>function fn() {\n    fnInner();\n\n    var fnInner = function() {\n        console.log(&quot;inner fn&quot;);\n    }\n}\n\nfn();\n//  类型异常(undefined is not a function)\n</code></pre><p>就像刚才说的,fnInner会被放到函数体的第一行,但是没有赋初值,所以就成了undefined。</p>\n<p>但是如果用正常函数声明的方法就可以被正确调用,就像下面的样子:</p>\n<pre><code>function fn() {\n    fnInner();\n\n    function fnInner() {\n        console.log(&quot;inner fn&quot;);\n    }\n}\n\nfn();\n</code></pre><p>甚至有次在angularjs源码中(1.x)看到下面的使用方式:</p>\n<pre><code>function x() {\n    //  do something\n    return {\n        attr1: fn1(),\n        attr2: fn2()\n        //  ...\n    };\n\n    function fn1() {\n        //  do something\n        return {\n            //  ...\n        };\n    }\n\n    function fn2() {\n        //  do something\n        return {\n            //  ...\n        };\n    }\n}\n</code></pre><p>当时一看觉得很诧异,主要是一般return以后不能再写代码了,但是又仔细一想,是变量提升的作用。</p>\n<p>即使变量提升给我们带来了很大的便利(函数可以在被调用之后声明),但是我们也应该养成变量先定义后使用的习惯,一是提升代码的可读性(不至于在函数体内这里定义一个变量那里定义一个变量的),二是不至于出现一些意想不到的错误或异常。</p>\n<p>在ES6中,如果我们用let来定义变量,但是在它定义之前使用,就会报错(使用typeof也会异常),可能ES6也强制我们养成”先定义后调用”的习惯吧。</p>\n","excerpt":"","more":"<p>在日常开发中有时候可能会遇到下面的情况:</p>\n<pre><code>var var1 = 1;\nfunction fn() {\n    console.log(var1);\n    var var1 = 2;\n    console.log(var1);\n}\n\nfn();   \n//  undefined\n//  2\n</code></pre><p>第一次遇到的人可能会觉得很奇怪(因为外面定义了同名变量,所以第一次应该打印出1),为什么会有这种情况出现呢？我们把代码改成下面的样子就方便理解了:</p>\n<pre><code>var var1 = 1;\nfunction fn() {\n    var var1;\n    //  如果不给变量赋初值,它的值就是undefined\n    console.log(var1);\n    var1 = 2;\n    console.log(var1);\n}\n</code></pre><p>这就是javascript中的变量提升。<br>MDN上的解释是”变量提升是JavaScript将声明移至作用域scope (全局域或者当前函数作用域) 顶部的行为”。</p>\n<p>除了变量,函数也存在变量提升的情况,但是如果用函数直接量法定义一个函数,会报类型异常:</p>\n<pre><code>function fn() {\n    fnInner();\n\n    var fnInner = function() {\n        console.log(&quot;inner fn&quot;);\n    }\n}\n\nfn();\n//  类型异常(undefined is not a function)\n</code></pre><p>就像刚才说的,fnInner会被放到函数体的第一行,但是没有赋初值,所以就成了undefined。</p>\n<p>但是如果用正常函数声明的方法就可以被正确调用,就像下面的样子:</p>\n<pre><code>function fn() {\n    fnInner();\n\n    function fnInner() {\n        console.log(&quot;inner fn&quot;);\n    }\n}\n\nfn();\n</code></pre><p>甚至有次在angularjs源码中(1.x)看到下面的使用方式:</p>\n<pre><code>function x() {\n    //  do something\n    return {\n        attr1: fn1(),\n        attr2: fn2()\n        //  ...\n    };\n\n    function fn1() {\n        //  do something\n        return {\n            //  ...\n        };\n    }\n\n    function fn2() {\n        //  do something\n        return {\n            //  ...\n        };\n    }\n}\n</code></pre><p>当时一看觉得很诧异,主要是一般return以后不能再写代码了,但是又仔细一想,是变量提升的作用。</p>\n<p>即使变量提升给我们带来了很大的便利(函数可以在被调用之后声明),但是我们也应该养成变量先定义后使用的习惯,一是提升代码的可读性(不至于在函数体内这里定义一个变量那里定义一个变量的),二是不至于出现一些意想不到的错误或异常。</p>\n<p>在ES6中,如果我们用let来定义变量,但是在它定义之前使用,就会报错(使用typeof也会异常),可能ES6也强制我们养成”先定义后调用”的习惯吧。</p>\n"},{"layout":"post","title":"NodeJs中redis窜库插入","date":"2015-08-19T16:00:00.000Z","_content":"\n最近在用NodeJs+redis搭建一个类似漂流瓶的服务器,有个需求如下:根据漂流瓶的类型来将数据用hash的方式插入到数据库中,这边类型主要根据性别(male/female)来区分,当类型为male时插入到0号数据库,female时插入到1号数据库。\n\n先贴代码:\n\n    var redis = require('redis'),\n        client = redis.createClient();\n    \n    /**\n     * 扔一个漂流瓶,随机分配一个id当存入redis的建,然后根据不同的类型存放到不同的数据库\n     * @param  {[type]}   bottle   [description]\n     * @param  {Function} callback [description]\n     * @return {[type]}            [description]\n     */\n    exports.throw = function (bottle, callback) {\n        bottle.time = bottle.time || Date.now();\n        var bottleId = Math.random().toString(16),\n        //\t为每个瓶子随机生成一个id\n    \n            type = {\n                'male': 0,\n                'female': 1\n            };\n        //\t根据不同类型将不同漂流瓶保存到不同的数据库\n        \n        console.log('现在应该选择' + type[bottle.type] + '号数据库进行插入');\n        \n        client.SELECT(type[bottle.type], function () {\n            client.HMSET(bottleId, bottle, function (err, res) {\n                //\t以hash类型保存漂流瓶对象\n    \n                if (err) {\n                    return callback({\n                        'code': 0,\n                        'msg': '过会再试吧!'\n                    });\n                }\n                //\t保存出错\n    \n                callback({\n                    'code': 1,\n                    'msg': res\n                });\n                //\t保存成功\n    \n                client.EXPIRE(bottleId, 86400);\n                //\t设置过期时间,每个漂流瓶的生成时间为1天\n            });\n        });\n    };\n\n这是原来的实现方法,然后路由是这样实现的:\n\n    //\t扔一个漂流瓶\n    //\tpost ?owner=xxx&type=xxx&content=xxx[&time=xxx]modules\n    app.post('/',function(req,res){\n    \tif(!req.body.owner || !req.body.type || !req.body.content){\n    \t\tif(req.body.type && (['male','female'].indexOf(req.body.type) == -1)){\n    \t\t\treturn res.json({\n    \t\t\t\t'code':0,\n    \t\t\t\t'msg':'类型错误!'\n    \t\t\t});\n    \t\t\treturn res.json({\n    \t\t\t\t'code':0,\n    \t\t\t\t'msg':'信息不完整!'\n    \t\t\t});\n    \t\t}\n    \t}\n    \tredis.throw(req.body,function(result){\n    \t\tres.json(result);\n    \t});\n    });\n    \n再写了几条测试数据:\n\n    var request = require('request');\n    //  Nodejs的request模块,用来模拟请求\n    \n    for(var i = 1;i <= 5;i ++){\n    \t(function(i){\n    \t\trequest.post({\n    \t\t\t'url':'http://127.0.0.1:3000/',\n    \t\t\t'json':{\n    \t\t\t\t'owner':'bottle' + i,\n    \t\t\t\t'type':'male',\n    \t\t\t\t'content':'content' + i\n    \t\t\t}\n    \t\t});\n    \t})(i);\n    }\n    //\t循环5条male数据\n    \n    for(var j = 6;j <= 10;j ++){\n    \t(function(j){\n    \t\trequest.post({\n    \t\t\t'url':'http://127.0.0.1:3000/',\n    \t\t\t'json':{\n    \t\t\t\t'owner':'bottle' + j,\n    \t\t\t\t'type':'female',\n    \t\t\t\t'content':'content' + j\n    \t\t\t}\n    \t\t});\n    \t})(j);\n    }\n    //\t循环5条female数据\n    \n模拟请求,发现根据类型取要插入的数据库选择对了,但是到最后都插入到1号库里去了,很奇怪的一个问题。\n\n![](/imgs/Node-redis-1.png)\n\n![](/imgs/Node-redis-2.png)\n\n后来在网上找帖子,看到开源中国上有一篇关于窜库插入的,发现是由于没有维护好redis对象之间关系导致的这个问题,于是就把代码改成了下面的实现方式:\n\n    var redis = require('redis'),\n        client = redis.createClient(),\n        client1 = redis.createClient();\n    //\tredis.createClient(port,host,opt)\n    \n    /**\n     * 扔一个漂流瓶,随机分配一个id当存入redis的建,然后根据不同的类型存放到不同的数据库\n     * @param  {[type]}   bottle   [description]\n     * @param  {Function} callback [description]\n     * @return {[type]}            [description]\n     */\n    exports.throw = function (bottle, callback) {\n        bottle.time = bottle.time || Date.now();\n        var curClient = null,\n            bottleId = Math.random().toString(16),\n        //\t为每个瓶子随机生成一个id\n    \n            type = {\n                'male': 0,\n                'female': 1\n            };\n        //\t根据不同类型将不同漂流瓶保存到不同的数据库\n    \n        if(type[bottle.type] == 0){\n            curClient = client;\n        }else{\n            curClient = client1;\n        }\n        \n        console.log('现在应该选择' + type[bottle.type] + '号数据库进行插入');\n    \n        curClient.SELECT(type[bottle.type], function () {\n            curClient.HMSET(bottleId, bottle, function (err, res) {\n                //\t以hash类型保存漂流瓶对象\n    \n                if (err) {\n                    return callback({\n                        'code': 0,\n                        'msg': '过会再试吧!'\n                    });\n                }\n                //\t保存出错\n    \n                callback({\n                    'code': 1,\n                    'msg': res\n                });\n                //\t保存成功\n    \n                curClient.EXPIRE(bottleId, 86400);\n                //\t设置过期时间,每个漂流瓶的生成时间为1天\n            });\n        });\n    };\n\n用两个redis对象,根据具体的类型判断取得那个对象,再测试就解决了这个问题。\n\n![](/imgs/Node-redis-3.png)\n\n![](/imgs/Node-redis-4.png)\n","source":"_posts/2015-08-20-Node-redis-across-database-insert.md","raw":"---\nlayout: post\ntitle: NodeJs中redis窜库插入\ndate: 2015-08-20\ncategories: [NodeJs]\n---\n\n最近在用NodeJs+redis搭建一个类似漂流瓶的服务器,有个需求如下:根据漂流瓶的类型来将数据用hash的方式插入到数据库中,这边类型主要根据性别(male/female)来区分,当类型为male时插入到0号数据库,female时插入到1号数据库。\n\n先贴代码:\n\n    var redis = require('redis'),\n        client = redis.createClient();\n    \n    /**\n     * 扔一个漂流瓶,随机分配一个id当存入redis的建,然后根据不同的类型存放到不同的数据库\n     * @param  {[type]}   bottle   [description]\n     * @param  {Function} callback [description]\n     * @return {[type]}            [description]\n     */\n    exports.throw = function (bottle, callback) {\n        bottle.time = bottle.time || Date.now();\n        var bottleId = Math.random().toString(16),\n        //\t为每个瓶子随机生成一个id\n    \n            type = {\n                'male': 0,\n                'female': 1\n            };\n        //\t根据不同类型将不同漂流瓶保存到不同的数据库\n        \n        console.log('现在应该选择' + type[bottle.type] + '号数据库进行插入');\n        \n        client.SELECT(type[bottle.type], function () {\n            client.HMSET(bottleId, bottle, function (err, res) {\n                //\t以hash类型保存漂流瓶对象\n    \n                if (err) {\n                    return callback({\n                        'code': 0,\n                        'msg': '过会再试吧!'\n                    });\n                }\n                //\t保存出错\n    \n                callback({\n                    'code': 1,\n                    'msg': res\n                });\n                //\t保存成功\n    \n                client.EXPIRE(bottleId, 86400);\n                //\t设置过期时间,每个漂流瓶的生成时间为1天\n            });\n        });\n    };\n\n这是原来的实现方法,然后路由是这样实现的:\n\n    //\t扔一个漂流瓶\n    //\tpost ?owner=xxx&type=xxx&content=xxx[&time=xxx]modules\n    app.post('/',function(req,res){\n    \tif(!req.body.owner || !req.body.type || !req.body.content){\n    \t\tif(req.body.type && (['male','female'].indexOf(req.body.type) == -1)){\n    \t\t\treturn res.json({\n    \t\t\t\t'code':0,\n    \t\t\t\t'msg':'类型错误!'\n    \t\t\t});\n    \t\t\treturn res.json({\n    \t\t\t\t'code':0,\n    \t\t\t\t'msg':'信息不完整!'\n    \t\t\t});\n    \t\t}\n    \t}\n    \tredis.throw(req.body,function(result){\n    \t\tres.json(result);\n    \t});\n    });\n    \n再写了几条测试数据:\n\n    var request = require('request');\n    //  Nodejs的request模块,用来模拟请求\n    \n    for(var i = 1;i <= 5;i ++){\n    \t(function(i){\n    \t\trequest.post({\n    \t\t\t'url':'http://127.0.0.1:3000/',\n    \t\t\t'json':{\n    \t\t\t\t'owner':'bottle' + i,\n    \t\t\t\t'type':'male',\n    \t\t\t\t'content':'content' + i\n    \t\t\t}\n    \t\t});\n    \t})(i);\n    }\n    //\t循环5条male数据\n    \n    for(var j = 6;j <= 10;j ++){\n    \t(function(j){\n    \t\trequest.post({\n    \t\t\t'url':'http://127.0.0.1:3000/',\n    \t\t\t'json':{\n    \t\t\t\t'owner':'bottle' + j,\n    \t\t\t\t'type':'female',\n    \t\t\t\t'content':'content' + j\n    \t\t\t}\n    \t\t});\n    \t})(j);\n    }\n    //\t循环5条female数据\n    \n模拟请求,发现根据类型取要插入的数据库选择对了,但是到最后都插入到1号库里去了,很奇怪的一个问题。\n\n![](/imgs/Node-redis-1.png)\n\n![](/imgs/Node-redis-2.png)\n\n后来在网上找帖子,看到开源中国上有一篇关于窜库插入的,发现是由于没有维护好redis对象之间关系导致的这个问题,于是就把代码改成了下面的实现方式:\n\n    var redis = require('redis'),\n        client = redis.createClient(),\n        client1 = redis.createClient();\n    //\tredis.createClient(port,host,opt)\n    \n    /**\n     * 扔一个漂流瓶,随机分配一个id当存入redis的建,然后根据不同的类型存放到不同的数据库\n     * @param  {[type]}   bottle   [description]\n     * @param  {Function} callback [description]\n     * @return {[type]}            [description]\n     */\n    exports.throw = function (bottle, callback) {\n        bottle.time = bottle.time || Date.now();\n        var curClient = null,\n            bottleId = Math.random().toString(16),\n        //\t为每个瓶子随机生成一个id\n    \n            type = {\n                'male': 0,\n                'female': 1\n            };\n        //\t根据不同类型将不同漂流瓶保存到不同的数据库\n    \n        if(type[bottle.type] == 0){\n            curClient = client;\n        }else{\n            curClient = client1;\n        }\n        \n        console.log('现在应该选择' + type[bottle.type] + '号数据库进行插入');\n    \n        curClient.SELECT(type[bottle.type], function () {\n            curClient.HMSET(bottleId, bottle, function (err, res) {\n                //\t以hash类型保存漂流瓶对象\n    \n                if (err) {\n                    return callback({\n                        'code': 0,\n                        'msg': '过会再试吧!'\n                    });\n                }\n                //\t保存出错\n    \n                callback({\n                    'code': 1,\n                    'msg': res\n                });\n                //\t保存成功\n    \n                curClient.EXPIRE(bottleId, 86400);\n                //\t设置过期时间,每个漂流瓶的生成时间为1天\n            });\n        });\n    };\n\n用两个redis对象,根据具体的类型判断取得那个对象,再测试就解决了这个问题。\n\n![](/imgs/Node-redis-3.png)\n\n![](/imgs/Node-redis-4.png)\n","slug":"2015-08-20-Node-redis-across-database-insert","published":1,"updated":"2016-11-09T14:01:20.000Z","_id":"civ7fseew000st95f1fzy7rwz","comments":1,"photos":[],"link":"","content":"<p>最近在用NodeJs+redis搭建一个类似漂流瓶的服务器,有个需求如下:根据漂流瓶的类型来将数据用hash的方式插入到数据库中,这边类型主要根据性别(male/female)来区分,当类型为male时插入到0号数据库,female时插入到1号数据库。</p>\n<p>先贴代码:</p>\n<pre><code>var redis = require(&apos;redis&apos;),\n    client = redis.createClient();\n\n/**\n * 扔一个漂流瓶,随机分配一个id当存入redis的建,然后根据不同的类型存放到不同的数据库\n * @param  {[type]}   bottle   [description]\n * @param  {Function} callback [description]\n * @return {[type]}            [description]\n */\nexports.throw = function (bottle, callback) {\n    bottle.time = bottle.time || Date.now();\n    var bottleId = Math.random().toString(16),\n    //    为每个瓶子随机生成一个id\n\n        type = {\n            &apos;male&apos;: 0,\n            &apos;female&apos;: 1\n        };\n    //    根据不同类型将不同漂流瓶保存到不同的数据库\n\n    console.log(&apos;现在应该选择&apos; + type[bottle.type] + &apos;号数据库进行插入&apos;);\n\n    client.SELECT(type[bottle.type], function () {\n        client.HMSET(bottleId, bottle, function (err, res) {\n            //    以hash类型保存漂流瓶对象\n\n            if (err) {\n                return callback({\n                    &apos;code&apos;: 0,\n                    &apos;msg&apos;: &apos;过会再试吧!&apos;\n                });\n            }\n            //    保存出错\n\n            callback({\n                &apos;code&apos;: 1,\n                &apos;msg&apos;: res\n            });\n            //    保存成功\n\n            client.EXPIRE(bottleId, 86400);\n            //    设置过期时间,每个漂流瓶的生成时间为1天\n        });\n    });\n};\n</code></pre><p>这是原来的实现方法,然后路由是这样实现的:</p>\n<pre><code>//    扔一个漂流瓶\n//    post ?owner=xxx&amp;type=xxx&amp;content=xxx[&amp;time=xxx]modules\napp.post(&apos;/&apos;,function(req,res){\n    if(!req.body.owner || !req.body.type || !req.body.content){\n        if(req.body.type &amp;&amp; ([&apos;male&apos;,&apos;female&apos;].indexOf(req.body.type) == -1)){\n            return res.json({\n                &apos;code&apos;:0,\n                &apos;msg&apos;:&apos;类型错误!&apos;\n            });\n            return res.json({\n                &apos;code&apos;:0,\n                &apos;msg&apos;:&apos;信息不完整!&apos;\n            });\n        }\n    }\n    redis.throw(req.body,function(result){\n        res.json(result);\n    });\n});\n</code></pre><p>再写了几条测试数据:</p>\n<pre><code>var request = require(&apos;request&apos;);\n//  Nodejs的request模块,用来模拟请求\n\nfor(var i = 1;i &lt;= 5;i ++){\n    (function(i){\n        request.post({\n            &apos;url&apos;:&apos;http://127.0.0.1:3000/&apos;,\n            &apos;json&apos;:{\n                &apos;owner&apos;:&apos;bottle&apos; + i,\n                &apos;type&apos;:&apos;male&apos;,\n                &apos;content&apos;:&apos;content&apos; + i\n            }\n        });\n    })(i);\n}\n//    循环5条male数据\n\nfor(var j = 6;j &lt;= 10;j ++){\n    (function(j){\n        request.post({\n            &apos;url&apos;:&apos;http://127.0.0.1:3000/&apos;,\n            &apos;json&apos;:{\n                &apos;owner&apos;:&apos;bottle&apos; + j,\n                &apos;type&apos;:&apos;female&apos;,\n                &apos;content&apos;:&apos;content&apos; + j\n            }\n        });\n    })(j);\n}\n//    循环5条female数据\n</code></pre><p>模拟请求,发现根据类型取要插入的数据库选择对了,但是到最后都插入到1号库里去了,很奇怪的一个问题。</p>\n<p><img src=\"/imgs/Node-redis-1.png\" alt=\"\"></p>\n<p><img src=\"/imgs/Node-redis-2.png\" alt=\"\"></p>\n<p>后来在网上找帖子,看到开源中国上有一篇关于窜库插入的,发现是由于没有维护好redis对象之间关系导致的这个问题,于是就把代码改成了下面的实现方式:</p>\n<pre><code>var redis = require(&apos;redis&apos;),\n    client = redis.createClient(),\n    client1 = redis.createClient();\n//    redis.createClient(port,host,opt)\n\n/**\n * 扔一个漂流瓶,随机分配一个id当存入redis的建,然后根据不同的类型存放到不同的数据库\n * @param  {[type]}   bottle   [description]\n * @param  {Function} callback [description]\n * @return {[type]}            [description]\n */\nexports.throw = function (bottle, callback) {\n    bottle.time = bottle.time || Date.now();\n    var curClient = null,\n        bottleId = Math.random().toString(16),\n    //    为每个瓶子随机生成一个id\n\n        type = {\n            &apos;male&apos;: 0,\n            &apos;female&apos;: 1\n        };\n    //    根据不同类型将不同漂流瓶保存到不同的数据库\n\n    if(type[bottle.type] == 0){\n        curClient = client;\n    }else{\n        curClient = client1;\n    }\n\n    console.log(&apos;现在应该选择&apos; + type[bottle.type] + &apos;号数据库进行插入&apos;);\n\n    curClient.SELECT(type[bottle.type], function () {\n        curClient.HMSET(bottleId, bottle, function (err, res) {\n            //    以hash类型保存漂流瓶对象\n\n            if (err) {\n                return callback({\n                    &apos;code&apos;: 0,\n                    &apos;msg&apos;: &apos;过会再试吧!&apos;\n                });\n            }\n            //    保存出错\n\n            callback({\n                &apos;code&apos;: 1,\n                &apos;msg&apos;: res\n            });\n            //    保存成功\n\n            curClient.EXPIRE(bottleId, 86400);\n            //    设置过期时间,每个漂流瓶的生成时间为1天\n        });\n    });\n};\n</code></pre><p>用两个redis对象,根据具体的类型判断取得那个对象,再测试就解决了这个问题。</p>\n<p><img src=\"/imgs/Node-redis-3.png\" alt=\"\"></p>\n<p><img src=\"/imgs/Node-redis-4.png\" alt=\"\"></p>\n","excerpt":"","more":"<p>最近在用NodeJs+redis搭建一个类似漂流瓶的服务器,有个需求如下:根据漂流瓶的类型来将数据用hash的方式插入到数据库中,这边类型主要根据性别(male/female)来区分,当类型为male时插入到0号数据库,female时插入到1号数据库。</p>\n<p>先贴代码:</p>\n<pre><code>var redis = require(&apos;redis&apos;),\n    client = redis.createClient();\n\n/**\n * 扔一个漂流瓶,随机分配一个id当存入redis的建,然后根据不同的类型存放到不同的数据库\n * @param  {[type]}   bottle   [description]\n * @param  {Function} callback [description]\n * @return {[type]}            [description]\n */\nexports.throw = function (bottle, callback) {\n    bottle.time = bottle.time || Date.now();\n    var bottleId = Math.random().toString(16),\n    //    为每个瓶子随机生成一个id\n\n        type = {\n            &apos;male&apos;: 0,\n            &apos;female&apos;: 1\n        };\n    //    根据不同类型将不同漂流瓶保存到不同的数据库\n\n    console.log(&apos;现在应该选择&apos; + type[bottle.type] + &apos;号数据库进行插入&apos;);\n\n    client.SELECT(type[bottle.type], function () {\n        client.HMSET(bottleId, bottle, function (err, res) {\n            //    以hash类型保存漂流瓶对象\n\n            if (err) {\n                return callback({\n                    &apos;code&apos;: 0,\n                    &apos;msg&apos;: &apos;过会再试吧!&apos;\n                });\n            }\n            //    保存出错\n\n            callback({\n                &apos;code&apos;: 1,\n                &apos;msg&apos;: res\n            });\n            //    保存成功\n\n            client.EXPIRE(bottleId, 86400);\n            //    设置过期时间,每个漂流瓶的生成时间为1天\n        });\n    });\n};\n</code></pre><p>这是原来的实现方法,然后路由是这样实现的:</p>\n<pre><code>//    扔一个漂流瓶\n//    post ?owner=xxx&amp;type=xxx&amp;content=xxx[&amp;time=xxx]modules\napp.post(&apos;/&apos;,function(req,res){\n    if(!req.body.owner || !req.body.type || !req.body.content){\n        if(req.body.type &amp;&amp; ([&apos;male&apos;,&apos;female&apos;].indexOf(req.body.type) == -1)){\n            return res.json({\n                &apos;code&apos;:0,\n                &apos;msg&apos;:&apos;类型错误!&apos;\n            });\n            return res.json({\n                &apos;code&apos;:0,\n                &apos;msg&apos;:&apos;信息不完整!&apos;\n            });\n        }\n    }\n    redis.throw(req.body,function(result){\n        res.json(result);\n    });\n});\n</code></pre><p>再写了几条测试数据:</p>\n<pre><code>var request = require(&apos;request&apos;);\n//  Nodejs的request模块,用来模拟请求\n\nfor(var i = 1;i &lt;= 5;i ++){\n    (function(i){\n        request.post({\n            &apos;url&apos;:&apos;http://127.0.0.1:3000/&apos;,\n            &apos;json&apos;:{\n                &apos;owner&apos;:&apos;bottle&apos; + i,\n                &apos;type&apos;:&apos;male&apos;,\n                &apos;content&apos;:&apos;content&apos; + i\n            }\n        });\n    })(i);\n}\n//    循环5条male数据\n\nfor(var j = 6;j &lt;= 10;j ++){\n    (function(j){\n        request.post({\n            &apos;url&apos;:&apos;http://127.0.0.1:3000/&apos;,\n            &apos;json&apos;:{\n                &apos;owner&apos;:&apos;bottle&apos; + j,\n                &apos;type&apos;:&apos;female&apos;,\n                &apos;content&apos;:&apos;content&apos; + j\n            }\n        });\n    })(j);\n}\n//    循环5条female数据\n</code></pre><p>模拟请求,发现根据类型取要插入的数据库选择对了,但是到最后都插入到1号库里去了,很奇怪的一个问题。</p>\n<p><img src=\"/imgs/Node-redis-1.png\" alt=\"\"></p>\n<p><img src=\"/imgs/Node-redis-2.png\" alt=\"\"></p>\n<p>后来在网上找帖子,看到开源中国上有一篇关于窜库插入的,发现是由于没有维护好redis对象之间关系导致的这个问题,于是就把代码改成了下面的实现方式:</p>\n<pre><code>var redis = require(&apos;redis&apos;),\n    client = redis.createClient(),\n    client1 = redis.createClient();\n//    redis.createClient(port,host,opt)\n\n/**\n * 扔一个漂流瓶,随机分配一个id当存入redis的建,然后根据不同的类型存放到不同的数据库\n * @param  {[type]}   bottle   [description]\n * @param  {Function} callback [description]\n * @return {[type]}            [description]\n */\nexports.throw = function (bottle, callback) {\n    bottle.time = bottle.time || Date.now();\n    var curClient = null,\n        bottleId = Math.random().toString(16),\n    //    为每个瓶子随机生成一个id\n\n        type = {\n            &apos;male&apos;: 0,\n            &apos;female&apos;: 1\n        };\n    //    根据不同类型将不同漂流瓶保存到不同的数据库\n\n    if(type[bottle.type] == 0){\n        curClient = client;\n    }else{\n        curClient = client1;\n    }\n\n    console.log(&apos;现在应该选择&apos; + type[bottle.type] + &apos;号数据库进行插入&apos;);\n\n    curClient.SELECT(type[bottle.type], function () {\n        curClient.HMSET(bottleId, bottle, function (err, res) {\n            //    以hash类型保存漂流瓶对象\n\n            if (err) {\n                return callback({\n                    &apos;code&apos;: 0,\n                    &apos;msg&apos;: &apos;过会再试吧!&apos;\n                });\n            }\n            //    保存出错\n\n            callback({\n                &apos;code&apos;: 1,\n                &apos;msg&apos;: res\n            });\n            //    保存成功\n\n            curClient.EXPIRE(bottleId, 86400);\n            //    设置过期时间,每个漂流瓶的生成时间为1天\n        });\n    });\n};\n</code></pre><p>用两个redis对象,根据具体的类型判断取得那个对象,再测试就解决了这个问题。</p>\n<p><img src=\"/imgs/Node-redis-3.png\" alt=\"\"></p>\n<p><img src=\"/imgs/Node-redis-4.png\" alt=\"\"></p>\n"},{"layout":"post","title":"NodeJs处理excel返回json","date":"2015-11-16T16:00:00.000Z","_content":"\n快3个月没写博客了，感觉好生疏。\n\n由于最近在做一个乐队投票活动，每个乐队都有几个预览图片，但是运营上传图片的时候没有考虑顺序问题，后端也没做类似于拖拽排序的功能，为了快速改出来，乐队预览图的url格式是\"http://api.juhuaba.com/api/file/z2/图片id\",\n然后一想，前端可以根据指定的id的顺序来显示，然后运营那边就给了我一个excel表格，每个乐队的id和图片，然后，看了一眼excel表格，好几百条数据，感觉手动处理太烦，而且容易出错，所以就想搞个办法让程序来处理。\n\n先上一张excel的图\n\n![](/imgs/excel-to-json.png)\n\n然后开始从网上找办法，很多都是说用一个\"node-xlsx\"的插件，但是我试了下，可能是excel表格的问题吧，报了个很奇怪的错，就放弃了。后来去npm上找到一个\"xlsx-json\"的插件，试了下，确实可以取得表格里的数据做为一个数组，每一项都有，只不过如果是空单元格或者被合并的单元格都会显示null,所以还是得自己处理下。\n\n首先肯定是执行\"npm install xlsx-json\"啦   \n然后这个插件需要有个配置文件，暂且叫task.json吧，下面是task.json中的内容。\n\n\t[\n\t  {\n\t    \"input\": \"data.xlsx\",\n\t    \"sheet\": \"Sheet1\",\n\t    \"range\": \"A1:C240\",\n\t    \"raw\": true,\n\t    \"output\": \"data.json\"\n\t  }\n\t]\n\t//\t该数组接受多个对象，每个对象的基本格式是上面那种\n\t//\tinput代表是哪个文件\n\t//\tsheet代表一个工作簿\n\t//\trange代表要转换的一个区域\n\t//\trow代表逐行读取\n\t//\toutput代表输出到哪个文件\n\n下面是调用代码\n\n\tvar xlsx2json = require('xlsx-json');\n\txlsx2json(task, function(err, jsonArr) {\n\t    if (err) {\n\t        console.error(err);\n\t        return;\n\t    }\n\t});\n\n虽然配置了这些参数，但是读取出来的不如人意，就像下面这样：\n\n![](/imgs/excel-to-json2.png)\n\n然后就对转换出来数组的进行了处理，下面是完整代码，前台浏览器访问http://localhost:3000,直接返回json给前台\n\n    var xlsx2json = require('xlsx-json'),   //  加载xlsx-json模块\n        task = require('./task.json'),      //  配置文件\n        express = require(\"express\"),\n        app = express(),\n        jsonData,                           //  临时变量,存储转转出来的数据\n        tmpObj = {},                        //  对象,循环时用\n        lastTmp = {},                       //  对象,循环用,存储每个乐队的完整对象\n        result = [];                        //  由完整乐队对象构成的数组\n    xlsx2json(task, function (err, jsonArr) {\n        if (err) {\n            console.error(err);\n            return;\n        }\n        jsonData = jsonArr[0];\n        //  返回值为[[],[],[],[]]格式,所以拿第一个\n    });\n    \n    for (var i = 1, len = jsonData.length; i < len; i++) {\n        var str = jsonData[i].join(\"-\");\n        jsonData[i] = str;\n    }\n    //  对转出来的数组进行遍历(从第二项,第一项是[\"name\",\"id\",\"pics\"],所以不需要转换),有的前面两项是null的数组就被转换成\"--第三项\"了\n    \n    for (var j = 1, lenj = jsonData.length; j < lenj + 1; j++) {\n        //  同样从第二项开始遍历,这边多循环一次由于最后一项的原因(当然也可以不多循环,直接在for外面再做个push就好)\n    \n        if (j == lenj) {\n            result.push(lastTmp);\n        }\n        //  到最后一项时,放到数组里面(此时最后一项已经没有了)\n    \n        if (jsonData[j] && !jsonData[j].match(/\\-\\-/g)) {\n            //  该项存在且不是前面两项为null的情况\n    \n            if (lastTmp.hasOwnProperty(\"id\")) {\n                result.push(lastTmp);\n            }\n            //  在\"第二轮\"循环时,把一个完整的乐队对象放到数组\n    \n            tmpObj = {};\n            var spl = jsonData[j].split(\"-\");\n            tmpObj = {\n                \"id\": spl[1],\n                \"image\": [\n                    spl[2]\n                ]\n            };\n            //  给tmpObj指定id和image,其中image为数组\n    \n        } else if (jsonData[j] && jsonData[j].match(/\\-\\-/g).length) {\n            //  该项存在且前面两项为null的情况,就取最后一项\n    \n            var tmpStr = jsonData[j].replace(\"--\", \"\");\n            if (tmpStr) {\n                tmpObj.image.push(jsonData[j].replace(\"--\", \"\"));\n            }\n        }\n    \n        lastTmp = tmpObj;\n        //  把每次循环得到的乐队对象做存储\n    }\n    \n    app.get(\"/\", function (req, res) {\n        //  配置路由,请求http://localhost:3000时,输出转换好的数据\n        res.send(200, {\n            \"data\": result\n        });\n    });\n    \n    app.listen(3000, function () {\n        console.log(\"success!\");\n    });\n\n最终返回的结果如下图所示:    \n![](/imgs/excel-to-json3.png)","source":"_posts/2015-11-17-Node-deal-excel.md","raw":"---\nlayout: post\ntitle: NodeJs处理excel返回json\ndate: 2015-11-17\ncategories: [NodeJs]\n---\n\n快3个月没写博客了，感觉好生疏。\n\n由于最近在做一个乐队投票活动，每个乐队都有几个预览图片，但是运营上传图片的时候没有考虑顺序问题，后端也没做类似于拖拽排序的功能，为了快速改出来，乐队预览图的url格式是\"http://api.juhuaba.com/api/file/z2/图片id\",\n然后一想，前端可以根据指定的id的顺序来显示，然后运营那边就给了我一个excel表格，每个乐队的id和图片，然后，看了一眼excel表格，好几百条数据，感觉手动处理太烦，而且容易出错，所以就想搞个办法让程序来处理。\n\n先上一张excel的图\n\n![](/imgs/excel-to-json.png)\n\n然后开始从网上找办法，很多都是说用一个\"node-xlsx\"的插件，但是我试了下，可能是excel表格的问题吧，报了个很奇怪的错，就放弃了。后来去npm上找到一个\"xlsx-json\"的插件，试了下，确实可以取得表格里的数据做为一个数组，每一项都有，只不过如果是空单元格或者被合并的单元格都会显示null,所以还是得自己处理下。\n\n首先肯定是执行\"npm install xlsx-json\"啦   \n然后这个插件需要有个配置文件，暂且叫task.json吧，下面是task.json中的内容。\n\n\t[\n\t  {\n\t    \"input\": \"data.xlsx\",\n\t    \"sheet\": \"Sheet1\",\n\t    \"range\": \"A1:C240\",\n\t    \"raw\": true,\n\t    \"output\": \"data.json\"\n\t  }\n\t]\n\t//\t该数组接受多个对象，每个对象的基本格式是上面那种\n\t//\tinput代表是哪个文件\n\t//\tsheet代表一个工作簿\n\t//\trange代表要转换的一个区域\n\t//\trow代表逐行读取\n\t//\toutput代表输出到哪个文件\n\n下面是调用代码\n\n\tvar xlsx2json = require('xlsx-json');\n\txlsx2json(task, function(err, jsonArr) {\n\t    if (err) {\n\t        console.error(err);\n\t        return;\n\t    }\n\t});\n\n虽然配置了这些参数，但是读取出来的不如人意，就像下面这样：\n\n![](/imgs/excel-to-json2.png)\n\n然后就对转换出来数组的进行了处理，下面是完整代码，前台浏览器访问http://localhost:3000,直接返回json给前台\n\n    var xlsx2json = require('xlsx-json'),   //  加载xlsx-json模块\n        task = require('./task.json'),      //  配置文件\n        express = require(\"express\"),\n        app = express(),\n        jsonData,                           //  临时变量,存储转转出来的数据\n        tmpObj = {},                        //  对象,循环时用\n        lastTmp = {},                       //  对象,循环用,存储每个乐队的完整对象\n        result = [];                        //  由完整乐队对象构成的数组\n    xlsx2json(task, function (err, jsonArr) {\n        if (err) {\n            console.error(err);\n            return;\n        }\n        jsonData = jsonArr[0];\n        //  返回值为[[],[],[],[]]格式,所以拿第一个\n    });\n    \n    for (var i = 1, len = jsonData.length; i < len; i++) {\n        var str = jsonData[i].join(\"-\");\n        jsonData[i] = str;\n    }\n    //  对转出来的数组进行遍历(从第二项,第一项是[\"name\",\"id\",\"pics\"],所以不需要转换),有的前面两项是null的数组就被转换成\"--第三项\"了\n    \n    for (var j = 1, lenj = jsonData.length; j < lenj + 1; j++) {\n        //  同样从第二项开始遍历,这边多循环一次由于最后一项的原因(当然也可以不多循环,直接在for外面再做个push就好)\n    \n        if (j == lenj) {\n            result.push(lastTmp);\n        }\n        //  到最后一项时,放到数组里面(此时最后一项已经没有了)\n    \n        if (jsonData[j] && !jsonData[j].match(/\\-\\-/g)) {\n            //  该项存在且不是前面两项为null的情况\n    \n            if (lastTmp.hasOwnProperty(\"id\")) {\n                result.push(lastTmp);\n            }\n            //  在\"第二轮\"循环时,把一个完整的乐队对象放到数组\n    \n            tmpObj = {};\n            var spl = jsonData[j].split(\"-\");\n            tmpObj = {\n                \"id\": spl[1],\n                \"image\": [\n                    spl[2]\n                ]\n            };\n            //  给tmpObj指定id和image,其中image为数组\n    \n        } else if (jsonData[j] && jsonData[j].match(/\\-\\-/g).length) {\n            //  该项存在且前面两项为null的情况,就取最后一项\n    \n            var tmpStr = jsonData[j].replace(\"--\", \"\");\n            if (tmpStr) {\n                tmpObj.image.push(jsonData[j].replace(\"--\", \"\"));\n            }\n        }\n    \n        lastTmp = tmpObj;\n        //  把每次循环得到的乐队对象做存储\n    }\n    \n    app.get(\"/\", function (req, res) {\n        //  配置路由,请求http://localhost:3000时,输出转换好的数据\n        res.send(200, {\n            \"data\": result\n        });\n    });\n    \n    app.listen(3000, function () {\n        console.log(\"success!\");\n    });\n\n最终返回的结果如下图所示:    \n![](/imgs/excel-to-json3.png)","slug":"2015-11-17-Node-deal-excel","published":1,"updated":"2016-11-07T02:19:51.000Z","_id":"civ7fsef3000ut95far88il9c","comments":1,"photos":[],"link":"","content":"<p>快3个月没写博客了，感觉好生疏。</p>\n<p>由于最近在做一个乐队投票活动，每个乐队都有几个预览图片，但是运营上传图片的时候没有考虑顺序问题，后端也没做类似于拖拽排序的功能，为了快速改出来，乐队预览图的url格式是”<a href=\"http://api.juhuaba.com/api/file/z2/图片id\" target=\"_blank\" rel=\"external\">http://api.juhuaba.com/api/file/z2/图片id</a>“,<br>然后一想，前端可以根据指定的id的顺序来显示，然后运营那边就给了我一个excel表格，每个乐队的id和图片，然后，看了一眼excel表格，好几百条数据，感觉手动处理太烦，而且容易出错，所以就想搞个办法让程序来处理。</p>\n<p>先上一张excel的图</p>\n<p><img src=\"/imgs/excel-to-json.png\" alt=\"\"></p>\n<p>然后开始从网上找办法，很多都是说用一个”node-xlsx”的插件，但是我试了下，可能是excel表格的问题吧，报了个很奇怪的错，就放弃了。后来去npm上找到一个”xlsx-json”的插件，试了下，确实可以取得表格里的数据做为一个数组，每一项都有，只不过如果是空单元格或者被合并的单元格都会显示null,所以还是得自己处理下。</p>\n<p>首先肯定是执行”npm install xlsx-json”啦<br>然后这个插件需要有个配置文件，暂且叫task.json吧，下面是task.json中的内容。</p>\n<pre><code>[\n  {\n    &quot;input&quot;: &quot;data.xlsx&quot;,\n    &quot;sheet&quot;: &quot;Sheet1&quot;,\n    &quot;range&quot;: &quot;A1:C240&quot;,\n    &quot;raw&quot;: true,\n    &quot;output&quot;: &quot;data.json&quot;\n  }\n]\n//    该数组接受多个对象，每个对象的基本格式是上面那种\n//    input代表是哪个文件\n//    sheet代表一个工作簿\n//    range代表要转换的一个区域\n//    row代表逐行读取\n//    output代表输出到哪个文件\n</code></pre><p>下面是调用代码</p>\n<pre><code>var xlsx2json = require(&apos;xlsx-json&apos;);\nxlsx2json(task, function(err, jsonArr) {\n    if (err) {\n        console.error(err);\n        return;\n    }\n});\n</code></pre><p>虽然配置了这些参数，但是读取出来的不如人意，就像下面这样：</p>\n<p><img src=\"/imgs/excel-to-json2.png\" alt=\"\"></p>\n<p>然后就对转换出来数组的进行了处理，下面是完整代码，前台浏览器访问<a href=\"http://localhost:3000,直接返回json给前台\" target=\"_blank\" rel=\"external\">http://localhost:3000,直接返回json给前台</a></p>\n<pre><code>var xlsx2json = require(&apos;xlsx-json&apos;),   //  加载xlsx-json模块\n    task = require(&apos;./task.json&apos;),      //  配置文件\n    express = require(&quot;express&quot;),\n    app = express(),\n    jsonData,                           //  临时变量,存储转转出来的数据\n    tmpObj = {},                        //  对象,循环时用\n    lastTmp = {},                       //  对象,循环用,存储每个乐队的完整对象\n    result = [];                        //  由完整乐队对象构成的数组\nxlsx2json(task, function (err, jsonArr) {\n    if (err) {\n        console.error(err);\n        return;\n    }\n    jsonData = jsonArr[0];\n    //  返回值为[[],[],[],[]]格式,所以拿第一个\n});\n\nfor (var i = 1, len = jsonData.length; i &lt; len; i++) {\n    var str = jsonData[i].join(&quot;-&quot;);\n    jsonData[i] = str;\n}\n//  对转出来的数组进行遍历(从第二项,第一项是[&quot;name&quot;,&quot;id&quot;,&quot;pics&quot;],所以不需要转换),有的前面两项是null的数组就被转换成&quot;--第三项&quot;了\n\nfor (var j = 1, lenj = jsonData.length; j &lt; lenj + 1; j++) {\n    //  同样从第二项开始遍历,这边多循环一次由于最后一项的原因(当然也可以不多循环,直接在for外面再做个push就好)\n\n    if (j == lenj) {\n        result.push(lastTmp);\n    }\n    //  到最后一项时,放到数组里面(此时最后一项已经没有了)\n\n    if (jsonData[j] &amp;&amp; !jsonData[j].match(/\\-\\-/g)) {\n        //  该项存在且不是前面两项为null的情况\n\n        if (lastTmp.hasOwnProperty(&quot;id&quot;)) {\n            result.push(lastTmp);\n        }\n        //  在&quot;第二轮&quot;循环时,把一个完整的乐队对象放到数组\n\n        tmpObj = {};\n        var spl = jsonData[j].split(&quot;-&quot;);\n        tmpObj = {\n            &quot;id&quot;: spl[1],\n            &quot;image&quot;: [\n                spl[2]\n            ]\n        };\n        //  给tmpObj指定id和image,其中image为数组\n\n    } else if (jsonData[j] &amp;&amp; jsonData[j].match(/\\-\\-/g).length) {\n        //  该项存在且前面两项为null的情况,就取最后一项\n\n        var tmpStr = jsonData[j].replace(&quot;--&quot;, &quot;&quot;);\n        if (tmpStr) {\n            tmpObj.image.push(jsonData[j].replace(&quot;--&quot;, &quot;&quot;));\n        }\n    }\n\n    lastTmp = tmpObj;\n    //  把每次循环得到的乐队对象做存储\n}\n\napp.get(&quot;/&quot;, function (req, res) {\n    //  配置路由,请求http://localhost:3000时,输出转换好的数据\n    res.send(200, {\n        &quot;data&quot;: result\n    });\n});\n\napp.listen(3000, function () {\n    console.log(&quot;success!&quot;);\n});\n</code></pre><p>最终返回的结果如下图所示:<br><img src=\"/imgs/excel-to-json3.png\" alt=\"\"></p>\n","excerpt":"","more":"<p>快3个月没写博客了，感觉好生疏。</p>\n<p>由于最近在做一个乐队投票活动，每个乐队都有几个预览图片，但是运营上传图片的时候没有考虑顺序问题，后端也没做类似于拖拽排序的功能，为了快速改出来，乐队预览图的url格式是”<a href=\"http://api.juhuaba.com/api/file/z2/图片id\">http://api.juhuaba.com/api/file/z2/图片id</a>“,<br>然后一想，前端可以根据指定的id的顺序来显示，然后运营那边就给了我一个excel表格，每个乐队的id和图片，然后，看了一眼excel表格，好几百条数据，感觉手动处理太烦，而且容易出错，所以就想搞个办法让程序来处理。</p>\n<p>先上一张excel的图</p>\n<p><img src=\"/imgs/excel-to-json.png\" alt=\"\"></p>\n<p>然后开始从网上找办法，很多都是说用一个”node-xlsx”的插件，但是我试了下，可能是excel表格的问题吧，报了个很奇怪的错，就放弃了。后来去npm上找到一个”xlsx-json”的插件，试了下，确实可以取得表格里的数据做为一个数组，每一项都有，只不过如果是空单元格或者被合并的单元格都会显示null,所以还是得自己处理下。</p>\n<p>首先肯定是执行”npm install xlsx-json”啦<br>然后这个插件需要有个配置文件，暂且叫task.json吧，下面是task.json中的内容。</p>\n<pre><code>[\n  {\n    &quot;input&quot;: &quot;data.xlsx&quot;,\n    &quot;sheet&quot;: &quot;Sheet1&quot;,\n    &quot;range&quot;: &quot;A1:C240&quot;,\n    &quot;raw&quot;: true,\n    &quot;output&quot;: &quot;data.json&quot;\n  }\n]\n//    该数组接受多个对象，每个对象的基本格式是上面那种\n//    input代表是哪个文件\n//    sheet代表一个工作簿\n//    range代表要转换的一个区域\n//    row代表逐行读取\n//    output代表输出到哪个文件\n</code></pre><p>下面是调用代码</p>\n<pre><code>var xlsx2json = require(&apos;xlsx-json&apos;);\nxlsx2json(task, function(err, jsonArr) {\n    if (err) {\n        console.error(err);\n        return;\n    }\n});\n</code></pre><p>虽然配置了这些参数，但是读取出来的不如人意，就像下面这样：</p>\n<p><img src=\"/imgs/excel-to-json2.png\" alt=\"\"></p>\n<p>然后就对转换出来数组的进行了处理，下面是完整代码，前台浏览器访问<a href=\"http://localhost:3000,直接返回json给前台\">http://localhost:3000,直接返回json给前台</a></p>\n<pre><code>var xlsx2json = require(&apos;xlsx-json&apos;),   //  加载xlsx-json模块\n    task = require(&apos;./task.json&apos;),      //  配置文件\n    express = require(&quot;express&quot;),\n    app = express(),\n    jsonData,                           //  临时变量,存储转转出来的数据\n    tmpObj = {},                        //  对象,循环时用\n    lastTmp = {},                       //  对象,循环用,存储每个乐队的完整对象\n    result = [];                        //  由完整乐队对象构成的数组\nxlsx2json(task, function (err, jsonArr) {\n    if (err) {\n        console.error(err);\n        return;\n    }\n    jsonData = jsonArr[0];\n    //  返回值为[[],[],[],[]]格式,所以拿第一个\n});\n\nfor (var i = 1, len = jsonData.length; i &lt; len; i++) {\n    var str = jsonData[i].join(&quot;-&quot;);\n    jsonData[i] = str;\n}\n//  对转出来的数组进行遍历(从第二项,第一项是[&quot;name&quot;,&quot;id&quot;,&quot;pics&quot;],所以不需要转换),有的前面两项是null的数组就被转换成&quot;--第三项&quot;了\n\nfor (var j = 1, lenj = jsonData.length; j &lt; lenj + 1; j++) {\n    //  同样从第二项开始遍历,这边多循环一次由于最后一项的原因(当然也可以不多循环,直接在for外面再做个push就好)\n\n    if (j == lenj) {\n        result.push(lastTmp);\n    }\n    //  到最后一项时,放到数组里面(此时最后一项已经没有了)\n\n    if (jsonData[j] &amp;&amp; !jsonData[j].match(/\\-\\-/g)) {\n        //  该项存在且不是前面两项为null的情况\n\n        if (lastTmp.hasOwnProperty(&quot;id&quot;)) {\n            result.push(lastTmp);\n        }\n        //  在&quot;第二轮&quot;循环时,把一个完整的乐队对象放到数组\n\n        tmpObj = {};\n        var spl = jsonData[j].split(&quot;-&quot;);\n        tmpObj = {\n            &quot;id&quot;: spl[1],\n            &quot;image&quot;: [\n                spl[2]\n            ]\n        };\n        //  给tmpObj指定id和image,其中image为数组\n\n    } else if (jsonData[j] &amp;&amp; jsonData[j].match(/\\-\\-/g).length) {\n        //  该项存在且前面两项为null的情况,就取最后一项\n\n        var tmpStr = jsonData[j].replace(&quot;--&quot;, &quot;&quot;);\n        if (tmpStr) {\n            tmpObj.image.push(jsonData[j].replace(&quot;--&quot;, &quot;&quot;));\n        }\n    }\n\n    lastTmp = tmpObj;\n    //  把每次循环得到的乐队对象做存储\n}\n\napp.get(&quot;/&quot;, function (req, res) {\n    //  配置路由,请求http://localhost:3000时,输出转换好的数据\n    res.send(200, {\n        &quot;data&quot;: result\n    });\n});\n\napp.listen(3000, function () {\n    console.log(&quot;success!&quot;);\n});\n</code></pre><p>最终返回的结果如下图所示:<br><img src=\"/imgs/excel-to-json3.png\" alt=\"\"></p>\n"},{"layout":"post","title":"第一个React Native App","date":"2015-11-19T16:00:00.000Z","_content":"\n这几天在学习[React Native](http://www.reactnative.com/),觉得很屌,做了个\"Hello World\",拿出来和大家分享下\n\n先说环境搭建把,大致可分为下面几步:\n\n    1.首先必备一台Mac\n    2.然后在App store上下载最新的Xcode\n    3.Nodejs安装,可以去NodeJs官网下载安装包安装\n    4.Node也可采用homebrew安装,没有的自行百度,brew安装完成就可以在terminal中运行'brew install node',改命令执行完成就自动安装了node和npm包管理器\n    5.安装watchman,一个来自Facebook 的观察程序,终端命令:'brew install watchman'\n    6也可以有选择的安装flow\n    \n到这里环境大致安装完成,下面我们开始安装react-native命令行工具,执行'sudo npm install -g react-native-cli',输入密码等待安装完成,我们就可以在命令行用'react-native init ' + 项目名创建一个React Native项目,由于某些原因,初始化过程可能会比较慢,耐心等待几个,这里我创建一个项目,完成一个输入框,在输入完成,请求Github提供的api接口,过滤出符合搜索关键字的项目。\n\n1、首先,我在命令行运行'react-native init githubFinder',经过漫长等待,项目创建完成,到项目目录下,打开ios目录,打开githubFinder.xcodeproj,就可以在Xcode中打开ios版本的项目了,然后打开index.ios.js文件,编写相关逻辑。\n\n    \"use strict\";\n\n    var React = require(\"react-native\");\n    var baseURI = \"https://api.github.com/search/repositories?q=\";\n    //  请求参数的url前缀\n    \n    var {\n      AppRegistry,\n      Image,\n      ListView,\n      StyleSheet,\n      Text,\n      TextInput,\n      View,\n    } = React;\n    //  注入相关组件到React中\n    \n    var githubFinder = React.createClass({\n      /**\n        定义组件初始状态值,也就是一个对象\n      */\n      \"getInitialState\":function(){\n        return {\n          \"dataSource\":new ListView.DataSource({\n            \"rowHasChanged\":(r1,r2) => r1 !== r2\n          })\n        };\n      },\n    \n      /**\n        render方法,根据不同的情况渲染页面\n      */\n      \"render\":function(){\n        var len = this.state.dataSource.getRowCount();\n        //  取得当前结果集的长度并且暂存\n    \n        var content = len === 0 ?\n        <Text style={styles.blanktext}>\n          please enter some thing to search...\n        </Text\n        //  如果长度为0,content一段提示文字\n        :\n        <ListView\n          ref=\"listview\"\n          dataSource={this.state.dataSource}\n          renderRow={this.renderRow}\n          automaticallyAdjustContentInsets = {false}\n          keyboardDismissMode=\"on-drag\"\n          keyboardShouldPersisiTaps={true}\n          showVerticalIndicatpr={false}\n           />;\n       //  否则返回一个LisView组件,content会根据数据来渲染结果列表\n    \n           return (\n             <View style={styles.container}>\n                <TextInput\n                  autoCapitalize=\"none\"\n                  autoCorrect={false}\n                  placeholder=\"enter your keywords\"\n                  onEndEditing={this.onSearchChange}\n                  style={styles.searchBarInput}\n                />\n            //  在刚才的content上面加入一个输入框框组件,在输入过程中,就调用\"onSearchChange\"方法\n    \n                {content}\n            //  渲染刚才存储的content\n             </View>\n           );\n      },\n    \n      /**\n        在输入过程中调用\n      */\n      \"onSearchChange\":function(evevt:Object){\n        var queryTerm = evevt.nativeEvent.text.toLowerCase();\n        //  取得输入的内容\n    \n        var queryUrl = baseURI + encodeURIComponent(queryTerm);\n        //  拼接查询地址\n    \n        fetch(queryUrl)\n          .then((response) => response.json())\n          .then((responseData) => {\n            if(responseData.items){\n              this.setState({\n                \"dataSource\":this.state.dataSource.cloneWithRows(responseData.items)\n              });\n              //  把ajax结果中的items放到dataSource中\n            }\n          })\n          .done();\n          //    调用fetch方法,进行ajax请求,处理结果集\n    \n          });\n      },\n    \n      /**\n        渲染行数据\n        读取每一项下的相关数据\n      */\n      \"renderRow\":function(repo:Object){\n        return (\n            <View>\n                <View style={styles.row}>\n                    <Image\n                        source={{uri:repo.owner.avatar_url}}\n                        style={styles.profpic}\n                    />\n                    <View style={styles.textcontainer}>\n                        <Text style={styles.title}>{repo.name}</Text>\n                        <Text style={styles.subtitle}>{repo.owner.login}</Text>\n                    </View>\n                </View>\n                <View style={styles.cellBorder} />\n            </View>\n        );\n      }\n    });\n    \n    /**\n      样式相关规则\n    */\n    var styles = StyleSheet.create({\n        \"container\":{\n            \"flex\":1,\n            \"backgroundColor\":\"#fff\"\n        },\n        \"searchBarInput\":{\n            \"marginTop\":30,\n            \"padding\":5,\n            \"fontSize\":15,\n            \"height\":30,\n            \"backgroundColor\":\"#eaeaea\"\n        },\n        \"row\":{\n            \"alignItems\":\"center\",\n            \"backgroundColor\":\"#fff\",\n            \"flexDirection\":\"row\",\n            \"padding\":5\n        },\n        \"cellBorder\":{\n            \"backgroundColor\":\"rgba(0,0,0,0.1)\",\n            \"height\":1,\n            \"padding\":5\n        },\n        \"profpic\":{\n            \"width\":50,\n            \"height\":50\n        },\n        \"title\":{\n            \"fontSize\":20,\n            \"marginBottom\":8,\n            \"fontWeight\":\"bold\"\n        },\n        \"textcontainer\":{\n            \"paddingLeft\":10\n        },\n        \"blanktext\":{\n            \"padding\":10,\n            \"fontSize\":20\n        }\n    });\n    \n    AppRegistry.registerComponent(\"githubFinder\",()=>githubFinder);\n    //  通过AppRegistry.registerComponent来注册一个组件\n\n然后在Xcode中选择设备设备后运行,如下图所示:\n\n选择设备并且运行:\n\n![](/imgs/react-native-app-1-1.png)\n\n没有输入搜索关键字的:\n\n![](/imgs/react-native-app-1-2.png)\n\n输入完搜索关键字并且搜索完成:\n\n![](/imgs/react-native-app-1-3.png)\n\n最后分享一个调试技巧:网上很多地方说用一个叫\"react devtools\"的chrome插件来调试程序,但是chrome应用商店在不翻墙的情况下是上不了的,我们也可以在safri上进行调试,选择develop -> simulator下面的一些选择就可以进行调试。\n","source":"_posts/2015-11-20-my-first-react-demo.md","raw":"---\nlayout: post\ntitle: 第一个React Native App\ndate: 2015-11-20\ncategories: [React]\n---\n\n这几天在学习[React Native](http://www.reactnative.com/),觉得很屌,做了个\"Hello World\",拿出来和大家分享下\n\n先说环境搭建把,大致可分为下面几步:\n\n    1.首先必备一台Mac\n    2.然后在App store上下载最新的Xcode\n    3.Nodejs安装,可以去NodeJs官网下载安装包安装\n    4.Node也可采用homebrew安装,没有的自行百度,brew安装完成就可以在terminal中运行'brew install node',改命令执行完成就自动安装了node和npm包管理器\n    5.安装watchman,一个来自Facebook 的观察程序,终端命令:'brew install watchman'\n    6也可以有选择的安装flow\n    \n到这里环境大致安装完成,下面我们开始安装react-native命令行工具,执行'sudo npm install -g react-native-cli',输入密码等待安装完成,我们就可以在命令行用'react-native init ' + 项目名创建一个React Native项目,由于某些原因,初始化过程可能会比较慢,耐心等待几个,这里我创建一个项目,完成一个输入框,在输入完成,请求Github提供的api接口,过滤出符合搜索关键字的项目。\n\n1、首先,我在命令行运行'react-native init githubFinder',经过漫长等待,项目创建完成,到项目目录下,打开ios目录,打开githubFinder.xcodeproj,就可以在Xcode中打开ios版本的项目了,然后打开index.ios.js文件,编写相关逻辑。\n\n    \"use strict\";\n\n    var React = require(\"react-native\");\n    var baseURI = \"https://api.github.com/search/repositories?q=\";\n    //  请求参数的url前缀\n    \n    var {\n      AppRegistry,\n      Image,\n      ListView,\n      StyleSheet,\n      Text,\n      TextInput,\n      View,\n    } = React;\n    //  注入相关组件到React中\n    \n    var githubFinder = React.createClass({\n      /**\n        定义组件初始状态值,也就是一个对象\n      */\n      \"getInitialState\":function(){\n        return {\n          \"dataSource\":new ListView.DataSource({\n            \"rowHasChanged\":(r1,r2) => r1 !== r2\n          })\n        };\n      },\n    \n      /**\n        render方法,根据不同的情况渲染页面\n      */\n      \"render\":function(){\n        var len = this.state.dataSource.getRowCount();\n        //  取得当前结果集的长度并且暂存\n    \n        var content = len === 0 ?\n        <Text style={styles.blanktext}>\n          please enter some thing to search...\n        </Text\n        //  如果长度为0,content一段提示文字\n        :\n        <ListView\n          ref=\"listview\"\n          dataSource={this.state.dataSource}\n          renderRow={this.renderRow}\n          automaticallyAdjustContentInsets = {false}\n          keyboardDismissMode=\"on-drag\"\n          keyboardShouldPersisiTaps={true}\n          showVerticalIndicatpr={false}\n           />;\n       //  否则返回一个LisView组件,content会根据数据来渲染结果列表\n    \n           return (\n             <View style={styles.container}>\n                <TextInput\n                  autoCapitalize=\"none\"\n                  autoCorrect={false}\n                  placeholder=\"enter your keywords\"\n                  onEndEditing={this.onSearchChange}\n                  style={styles.searchBarInput}\n                />\n            //  在刚才的content上面加入一个输入框框组件,在输入过程中,就调用\"onSearchChange\"方法\n    \n                {content}\n            //  渲染刚才存储的content\n             </View>\n           );\n      },\n    \n      /**\n        在输入过程中调用\n      */\n      \"onSearchChange\":function(evevt:Object){\n        var queryTerm = evevt.nativeEvent.text.toLowerCase();\n        //  取得输入的内容\n    \n        var queryUrl = baseURI + encodeURIComponent(queryTerm);\n        //  拼接查询地址\n    \n        fetch(queryUrl)\n          .then((response) => response.json())\n          .then((responseData) => {\n            if(responseData.items){\n              this.setState({\n                \"dataSource\":this.state.dataSource.cloneWithRows(responseData.items)\n              });\n              //  把ajax结果中的items放到dataSource中\n            }\n          })\n          .done();\n          //    调用fetch方法,进行ajax请求,处理结果集\n    \n          });\n      },\n    \n      /**\n        渲染行数据\n        读取每一项下的相关数据\n      */\n      \"renderRow\":function(repo:Object){\n        return (\n            <View>\n                <View style={styles.row}>\n                    <Image\n                        source={{uri:repo.owner.avatar_url}}\n                        style={styles.profpic}\n                    />\n                    <View style={styles.textcontainer}>\n                        <Text style={styles.title}>{repo.name}</Text>\n                        <Text style={styles.subtitle}>{repo.owner.login}</Text>\n                    </View>\n                </View>\n                <View style={styles.cellBorder} />\n            </View>\n        );\n      }\n    });\n    \n    /**\n      样式相关规则\n    */\n    var styles = StyleSheet.create({\n        \"container\":{\n            \"flex\":1,\n            \"backgroundColor\":\"#fff\"\n        },\n        \"searchBarInput\":{\n            \"marginTop\":30,\n            \"padding\":5,\n            \"fontSize\":15,\n            \"height\":30,\n            \"backgroundColor\":\"#eaeaea\"\n        },\n        \"row\":{\n            \"alignItems\":\"center\",\n            \"backgroundColor\":\"#fff\",\n            \"flexDirection\":\"row\",\n            \"padding\":5\n        },\n        \"cellBorder\":{\n            \"backgroundColor\":\"rgba(0,0,0,0.1)\",\n            \"height\":1,\n            \"padding\":5\n        },\n        \"profpic\":{\n            \"width\":50,\n            \"height\":50\n        },\n        \"title\":{\n            \"fontSize\":20,\n            \"marginBottom\":8,\n            \"fontWeight\":\"bold\"\n        },\n        \"textcontainer\":{\n            \"paddingLeft\":10\n        },\n        \"blanktext\":{\n            \"padding\":10,\n            \"fontSize\":20\n        }\n    });\n    \n    AppRegistry.registerComponent(\"githubFinder\",()=>githubFinder);\n    //  通过AppRegistry.registerComponent来注册一个组件\n\n然后在Xcode中选择设备设备后运行,如下图所示:\n\n选择设备并且运行:\n\n![](/imgs/react-native-app-1-1.png)\n\n没有输入搜索关键字的:\n\n![](/imgs/react-native-app-1-2.png)\n\n输入完搜索关键字并且搜索完成:\n\n![](/imgs/react-native-app-1-3.png)\n\n最后分享一个调试技巧:网上很多地方说用一个叫\"react devtools\"的chrome插件来调试程序,但是chrome应用商店在不翻墙的情况下是上不了的,我们也可以在safri上进行调试,选择develop -> simulator下面的一些选择就可以进行调试。\n","slug":"2015-11-20-my-first-react-demo","published":1,"updated":"2016-11-09T14:01:28.000Z","_id":"civ7fsef5000xt95fdivc681e","comments":1,"photos":[],"link":"","content":"<p>这几天在学习<a href=\"http://www.reactnative.com/\" target=\"_blank\" rel=\"external\">React Native</a>,觉得很屌,做了个”Hello World”,拿出来和大家分享下</p>\n<p>先说环境搭建把,大致可分为下面几步:</p>\n<pre><code>1.首先必备一台Mac\n2.然后在App store上下载最新的Xcode\n3.Nodejs安装,可以去NodeJs官网下载安装包安装\n4.Node也可采用homebrew安装,没有的自行百度,brew安装完成就可以在terminal中运行&apos;brew install node&apos;,改命令执行完成就自动安装了node和npm包管理器\n5.安装watchman,一个来自Facebook 的观察程序,终端命令:&apos;brew install watchman&apos;\n6也可以有选择的安装flow\n</code></pre><p>到这里环境大致安装完成,下面我们开始安装react-native命令行工具,执行’sudo npm install -g react-native-cli’,输入密码等待安装完成,我们就可以在命令行用’react-native init ‘ + 项目名创建一个React Native项目,由于某些原因,初始化过程可能会比较慢,耐心等待几个,这里我创建一个项目,完成一个输入框,在输入完成,请求Github提供的api接口,过滤出符合搜索关键字的项目。</p>\n<p>1、首先,我在命令行运行’react-native init githubFinder’,经过漫长等待,项目创建完成,到项目目录下,打开ios目录,打开githubFinder.xcodeproj,就可以在Xcode中打开ios版本的项目了,然后打开index.ios.js文件,编写相关逻辑。</p>\n<pre><code>&quot;use strict&quot;;\n\nvar React = require(&quot;react-native&quot;);\nvar baseURI = &quot;https://api.github.com/search/repositories?q=&quot;;\n//  请求参数的url前缀\n\nvar {\n  AppRegistry,\n  Image,\n  ListView,\n  StyleSheet,\n  Text,\n  TextInput,\n  View,\n} = React;\n//  注入相关组件到React中\n\nvar githubFinder = React.createClass({\n  /**\n    定义组件初始状态值,也就是一个对象\n  */\n  &quot;getInitialState&quot;:function(){\n    return {\n      &quot;dataSource&quot;:new ListView.DataSource({\n        &quot;rowHasChanged&quot;:(r1,r2) =&gt; r1 !== r2\n      })\n    };\n  },\n\n  /**\n    render方法,根据不同的情况渲染页面\n  */\n  &quot;render&quot;:function(){\n    var len = this.state.dataSource.getRowCount();\n    //  取得当前结果集的长度并且暂存\n\n    var content = len === 0 ?\n    &lt;Text style={styles.blanktext}&gt;\n      please enter some thing to search...\n    &lt;/Text\n    //  如果长度为0,content一段提示文字\n    :\n    &lt;ListView\n      ref=&quot;listview&quot;\n      dataSource={this.state.dataSource}\n      renderRow={this.renderRow}\n      automaticallyAdjustContentInsets = {false}\n      keyboardDismissMode=&quot;on-drag&quot;\n      keyboardShouldPersisiTaps={true}\n      showVerticalIndicatpr={false}\n       /&gt;;\n   //  否则返回一个LisView组件,content会根据数据来渲染结果列表\n\n       return (\n         &lt;View style={styles.container}&gt;\n            &lt;TextInput\n              autoCapitalize=&quot;none&quot;\n              autoCorrect={false}\n              placeholder=&quot;enter your keywords&quot;\n              onEndEditing={this.onSearchChange}\n              style={styles.searchBarInput}\n            /&gt;\n        //  在刚才的content上面加入一个输入框框组件,在输入过程中,就调用&quot;onSearchChange&quot;方法\n\n            {content}\n        //  渲染刚才存储的content\n         &lt;/View&gt;\n       );\n  },\n\n  /**\n    在输入过程中调用\n  */\n  &quot;onSearchChange&quot;:function(evevt:Object){\n    var queryTerm = evevt.nativeEvent.text.toLowerCase();\n    //  取得输入的内容\n\n    var queryUrl = baseURI + encodeURIComponent(queryTerm);\n    //  拼接查询地址\n\n    fetch(queryUrl)\n      .then((response) =&gt; response.json())\n      .then((responseData) =&gt; {\n        if(responseData.items){\n          this.setState({\n            &quot;dataSource&quot;:this.state.dataSource.cloneWithRows(responseData.items)\n          });\n          //  把ajax结果中的items放到dataSource中\n        }\n      })\n      .done();\n      //    调用fetch方法,进行ajax请求,处理结果集\n\n      });\n  },\n\n  /**\n    渲染行数据\n    读取每一项下的相关数据\n  */\n  &quot;renderRow&quot;:function(repo:Object){\n    return (\n        &lt;View&gt;\n            &lt;View style={styles.row}&gt;\n                &lt;Image\n                    source={{uri:repo.owner.avatar_url}}\n                    style={styles.profpic}\n                /&gt;\n                &lt;View style={styles.textcontainer}&gt;\n                    &lt;Text style={styles.title}&gt;{repo.name}&lt;/Text&gt;\n                    &lt;Text style={styles.subtitle}&gt;{repo.owner.login}&lt;/Text&gt;\n                &lt;/View&gt;\n            &lt;/View&gt;\n            &lt;View style={styles.cellBorder} /&gt;\n        &lt;/View&gt;\n    );\n  }\n});\n\n/**\n  样式相关规则\n*/\nvar styles = StyleSheet.create({\n    &quot;container&quot;:{\n        &quot;flex&quot;:1,\n        &quot;backgroundColor&quot;:&quot;#fff&quot;\n    },\n    &quot;searchBarInput&quot;:{\n        &quot;marginTop&quot;:30,\n        &quot;padding&quot;:5,\n        &quot;fontSize&quot;:15,\n        &quot;height&quot;:30,\n        &quot;backgroundColor&quot;:&quot;#eaeaea&quot;\n    },\n    &quot;row&quot;:{\n        &quot;alignItems&quot;:&quot;center&quot;,\n        &quot;backgroundColor&quot;:&quot;#fff&quot;,\n        &quot;flexDirection&quot;:&quot;row&quot;,\n        &quot;padding&quot;:5\n    },\n    &quot;cellBorder&quot;:{\n        &quot;backgroundColor&quot;:&quot;rgba(0,0,0,0.1)&quot;,\n        &quot;height&quot;:1,\n        &quot;padding&quot;:5\n    },\n    &quot;profpic&quot;:{\n        &quot;width&quot;:50,\n        &quot;height&quot;:50\n    },\n    &quot;title&quot;:{\n        &quot;fontSize&quot;:20,\n        &quot;marginBottom&quot;:8,\n        &quot;fontWeight&quot;:&quot;bold&quot;\n    },\n    &quot;textcontainer&quot;:{\n        &quot;paddingLeft&quot;:10\n    },\n    &quot;blanktext&quot;:{\n        &quot;padding&quot;:10,\n        &quot;fontSize&quot;:20\n    }\n});\n\nAppRegistry.registerComponent(&quot;githubFinder&quot;,()=&gt;githubFinder);\n//  通过AppRegistry.registerComponent来注册一个组件\n</code></pre><p>然后在Xcode中选择设备设备后运行,如下图所示:</p>\n<p>选择设备并且运行:</p>\n<p><img src=\"/imgs/react-native-app-1-1.png\" alt=\"\"></p>\n<p>没有输入搜索关键字的:</p>\n<p><img src=\"/imgs/react-native-app-1-2.png\" alt=\"\"></p>\n<p>输入完搜索关键字并且搜索完成:</p>\n<p><img src=\"/imgs/react-native-app-1-3.png\" alt=\"\"></p>\n<p>最后分享一个调试技巧:网上很多地方说用一个叫”react devtools”的chrome插件来调试程序,但是chrome应用商店在不翻墙的情况下是上不了的,我们也可以在safri上进行调试,选择develop -&gt; simulator下面的一些选择就可以进行调试。</p>\n","excerpt":"","more":"<p>这几天在学习<a href=\"http://www.reactnative.com/\">React Native</a>,觉得很屌,做了个”Hello World”,拿出来和大家分享下</p>\n<p>先说环境搭建把,大致可分为下面几步:</p>\n<pre><code>1.首先必备一台Mac\n2.然后在App store上下载最新的Xcode\n3.Nodejs安装,可以去NodeJs官网下载安装包安装\n4.Node也可采用homebrew安装,没有的自行百度,brew安装完成就可以在terminal中运行&apos;brew install node&apos;,改命令执行完成就自动安装了node和npm包管理器\n5.安装watchman,一个来自Facebook 的观察程序,终端命令:&apos;brew install watchman&apos;\n6也可以有选择的安装flow\n</code></pre><p>到这里环境大致安装完成,下面我们开始安装react-native命令行工具,执行’sudo npm install -g react-native-cli’,输入密码等待安装完成,我们就可以在命令行用’react-native init ‘ + 项目名创建一个React Native项目,由于某些原因,初始化过程可能会比较慢,耐心等待几个,这里我创建一个项目,完成一个输入框,在输入完成,请求Github提供的api接口,过滤出符合搜索关键字的项目。</p>\n<p>1、首先,我在命令行运行’react-native init githubFinder’,经过漫长等待,项目创建完成,到项目目录下,打开ios目录,打开githubFinder.xcodeproj,就可以在Xcode中打开ios版本的项目了,然后打开index.ios.js文件,编写相关逻辑。</p>\n<pre><code>&quot;use strict&quot;;\n\nvar React = require(&quot;react-native&quot;);\nvar baseURI = &quot;https://api.github.com/search/repositories?q=&quot;;\n//  请求参数的url前缀\n\nvar {\n  AppRegistry,\n  Image,\n  ListView,\n  StyleSheet,\n  Text,\n  TextInput,\n  View,\n} = React;\n//  注入相关组件到React中\n\nvar githubFinder = React.createClass({\n  /**\n    定义组件初始状态值,也就是一个对象\n  */\n  &quot;getInitialState&quot;:function(){\n    return {\n      &quot;dataSource&quot;:new ListView.DataSource({\n        &quot;rowHasChanged&quot;:(r1,r2) =&gt; r1 !== r2\n      })\n    };\n  },\n\n  /**\n    render方法,根据不同的情况渲染页面\n  */\n  &quot;render&quot;:function(){\n    var len = this.state.dataSource.getRowCount();\n    //  取得当前结果集的长度并且暂存\n\n    var content = len === 0 ?\n    &lt;Text style={styles.blanktext}&gt;\n      please enter some thing to search...\n    &lt;/Text\n    //  如果长度为0,content一段提示文字\n    :\n    &lt;ListView\n      ref=&quot;listview&quot;\n      dataSource={this.state.dataSource}\n      renderRow={this.renderRow}\n      automaticallyAdjustContentInsets = {false}\n      keyboardDismissMode=&quot;on-drag&quot;\n      keyboardShouldPersisiTaps={true}\n      showVerticalIndicatpr={false}\n       /&gt;;\n   //  否则返回一个LisView组件,content会根据数据来渲染结果列表\n\n       return (\n         &lt;View style={styles.container}&gt;\n            &lt;TextInput\n              autoCapitalize=&quot;none&quot;\n              autoCorrect={false}\n              placeholder=&quot;enter your keywords&quot;\n              onEndEditing={this.onSearchChange}\n              style={styles.searchBarInput}\n            /&gt;\n        //  在刚才的content上面加入一个输入框框组件,在输入过程中,就调用&quot;onSearchChange&quot;方法\n\n            {content}\n        //  渲染刚才存储的content\n         &lt;/View&gt;\n       );\n  },\n\n  /**\n    在输入过程中调用\n  */\n  &quot;onSearchChange&quot;:function(evevt:Object){\n    var queryTerm = evevt.nativeEvent.text.toLowerCase();\n    //  取得输入的内容\n\n    var queryUrl = baseURI + encodeURIComponent(queryTerm);\n    //  拼接查询地址\n\n    fetch(queryUrl)\n      .then((response) =&gt; response.json())\n      .then((responseData) =&gt; {\n        if(responseData.items){\n          this.setState({\n            &quot;dataSource&quot;:this.state.dataSource.cloneWithRows(responseData.items)\n          });\n          //  把ajax结果中的items放到dataSource中\n        }\n      })\n      .done();\n      //    调用fetch方法,进行ajax请求,处理结果集\n\n      });\n  },\n\n  /**\n    渲染行数据\n    读取每一项下的相关数据\n  */\n  &quot;renderRow&quot;:function(repo:Object){\n    return (\n        &lt;View&gt;\n            &lt;View style={styles.row}&gt;\n                &lt;Image\n                    source={{uri:repo.owner.avatar_url}}\n                    style={styles.profpic}\n                /&gt;\n                &lt;View style={styles.textcontainer}&gt;\n                    &lt;Text style={styles.title}&gt;{repo.name}&lt;/Text&gt;\n                    &lt;Text style={styles.subtitle}&gt;{repo.owner.login}&lt;/Text&gt;\n                &lt;/View&gt;\n            &lt;/View&gt;\n            &lt;View style={styles.cellBorder} /&gt;\n        &lt;/View&gt;\n    );\n  }\n});\n\n/**\n  样式相关规则\n*/\nvar styles = StyleSheet.create({\n    &quot;container&quot;:{\n        &quot;flex&quot;:1,\n        &quot;backgroundColor&quot;:&quot;#fff&quot;\n    },\n    &quot;searchBarInput&quot;:{\n        &quot;marginTop&quot;:30,\n        &quot;padding&quot;:5,\n        &quot;fontSize&quot;:15,\n        &quot;height&quot;:30,\n        &quot;backgroundColor&quot;:&quot;#eaeaea&quot;\n    },\n    &quot;row&quot;:{\n        &quot;alignItems&quot;:&quot;center&quot;,\n        &quot;backgroundColor&quot;:&quot;#fff&quot;,\n        &quot;flexDirection&quot;:&quot;row&quot;,\n        &quot;padding&quot;:5\n    },\n    &quot;cellBorder&quot;:{\n        &quot;backgroundColor&quot;:&quot;rgba(0,0,0,0.1)&quot;,\n        &quot;height&quot;:1,\n        &quot;padding&quot;:5\n    },\n    &quot;profpic&quot;:{\n        &quot;width&quot;:50,\n        &quot;height&quot;:50\n    },\n    &quot;title&quot;:{\n        &quot;fontSize&quot;:20,\n        &quot;marginBottom&quot;:8,\n        &quot;fontWeight&quot;:&quot;bold&quot;\n    },\n    &quot;textcontainer&quot;:{\n        &quot;paddingLeft&quot;:10\n    },\n    &quot;blanktext&quot;:{\n        &quot;padding&quot;:10,\n        &quot;fontSize&quot;:20\n    }\n});\n\nAppRegistry.registerComponent(&quot;githubFinder&quot;,()=&gt;githubFinder);\n//  通过AppRegistry.registerComponent来注册一个组件\n</code></pre><p>然后在Xcode中选择设备设备后运行,如下图所示:</p>\n<p>选择设备并且运行:</p>\n<p><img src=\"/imgs/react-native-app-1-1.png\" alt=\"\"></p>\n<p>没有输入搜索关键字的:</p>\n<p><img src=\"/imgs/react-native-app-1-2.png\" alt=\"\"></p>\n<p>输入完搜索关键字并且搜索完成:</p>\n<p><img src=\"/imgs/react-native-app-1-3.png\" alt=\"\"></p>\n<p>最后分享一个调试技巧:网上很多地方说用一个叫”react devtools”的chrome插件来调试程序,但是chrome应用商店在不翻墙的情况下是上不了的,我们也可以在safri上进行调试,选择develop -&gt; simulator下面的一些选择就可以进行调试。</p>\n"},{"layout":"post","title":"React组件生命周期","date":"2015-11-30T16:00:00.000Z","_content":"\n在React的组件生命周期中，随着该组件的props活着state发生改变，对应的DOM也随着变换，一个组件对于特定的输入，它将返回一致的输出。\n\n在React中，对于每个组件都提供了相应的钩子去响应：\n- 创建时(实例化)\n- 存在期(活动期)\n- 销毁期\n \n\n---\n\n#### 实例化\n\n在React的一个组件被实例化时，将依次调用以下一些方法\n \n    getDefaultProps:\n对于某个组件类，该方法只会被调用一次。对于那些没有被父组件指定props属性的组件来说，该方法返回默认的props\n\n    getInitialState\n对于该组件的每个实例来说，该方法有且只能被调用一次，在这里，我们可以对每个组件的状态进行初始化，和getDefaultProps不同的是，getInitialState在每次被实例化时都会被调用(个人感觉这一点感觉和js面向对象中的构造方法和原型类似，getDefaultProps相当于一个原型，getInitialState相当于构造方法，然后所有实例都享有同一个原型)，由于getDefaultProps在该方法之前被调用，所以此时我们已经可以访问到this.props了\n    \n    componentWillMount\n该方法在首次完成渲染之前被渲染，在这个方法里面，我们可以修改组件的一些state，需要注意的是，这是该组件完成实例化之前的最后一次修改\n    \n    render\n渲染虚拟DOM，对应一个组件来说，render方法是唯一一个必须实现的，并且遵循以下特殊的几个规则：\n\n1. 只能通过this.props和this.state来访问数据\n2. 可以返回null，boolean值或者任何形式的组件\n3. 只能出现一个顶级组件(不能返回多个一级标签并列)\n\n    \n    componentDidMount\n组件被实例化完成(render执行成功)后调用，可以在该方法中用this.getDOMNode()来访问到该组件，在这个方法中，比如我们要运行我们自定义的一个jQuery插件时，就可以直接写在里面，但是如果React运行在服务端，该方法将不会被调用\n    \n    \n#### 活动期\n\n随着组件的一些状态(比如鼠标点击、键盘输入等)发生改变，将依次调用以下一些方法\n\n    componentWillReciveProps\n在任意时刻，组件的props都可以通过父辈组件来修改，此时将调用该方法，我们可以在该方法对组件的state进行更新\n    \n    showComponentUpdate\n当props或者state发生改变，我们可以在该方法中进行比较修改前和修改后的数据，返回一个boolean值，React会根据这个来判断是否需要重新进行渲染\n    \n    componentWillUpdate\n和上一阶段的componentWillMount类似，只不过该方法是在重新进行渲染之前被调用\n    \n    render\n重新渲染虚拟DOM\n    \n    componentDidUpdate\n也和componentDidMount类似，只不过是在完成重新渲染之后被调用\n    \n#### 销毁期\n    \n最后该组件被使用完成，下面的方法将会给这个组件提供自身清理的机会\n    \n    componentWillUnmount\n比如我们在该组件中设置了一个定时器，添加了某些事件绑定等等，该方法就负责把定时器清除，移除事件监听的\n\n以上就是React中一个组件的生命周期\n\n---\n\n#### 反模式:把计算后的值赋值给state\n\n在getInitialState方法中，我们可以访问到this.props，通过this.props来创建state就是一种反模式。\n比如:在组件中,把当前事件转换成字符串格式，就只能在渲染时进行\n反模式的写法是不恰当的\n\n反模式中的写法:\n    \n    ...\n    getDefault:function(){\n        return {\n            \"date\":new Date()\n        };\n    },\n    getInitialState:function(){\n        return {\n            \"day\":this.props.getDay()\n        };\n    },\n    render:function(){\n        return <div>Day:{this.state.day}</div>\n    }\n    ...\n    \n正常模式的写法\n    \n    ...\n    getDefault:function(){\n        return {\n            \"date\":new Date()\n        };\n    },\n    render:function(){\n        var day = this.props.date.getDay()；\n        return <div>Day:{day}</div>\n    }\n    ...\n    \n好了，博客写完了，收工，睡觉！<img src=\"emoji/smile\" width=\"18\"/>","source":"_posts/2015-12-01-react-component-life-time.md","raw":"---\nlayout: post\ntitle: React组件生命周期\ndate: 2015-12-01\ncategories: [React]\n---\n\n在React的组件生命周期中，随着该组件的props活着state发生改变，对应的DOM也随着变换，一个组件对于特定的输入，它将返回一致的输出。\n\n在React中，对于每个组件都提供了相应的钩子去响应：\n- 创建时(实例化)\n- 存在期(活动期)\n- 销毁期\n \n\n---\n\n#### 实例化\n\n在React的一个组件被实例化时，将依次调用以下一些方法\n \n    getDefaultProps:\n对于某个组件类，该方法只会被调用一次。对于那些没有被父组件指定props属性的组件来说，该方法返回默认的props\n\n    getInitialState\n对于该组件的每个实例来说，该方法有且只能被调用一次，在这里，我们可以对每个组件的状态进行初始化，和getDefaultProps不同的是，getInitialState在每次被实例化时都会被调用(个人感觉这一点感觉和js面向对象中的构造方法和原型类似，getDefaultProps相当于一个原型，getInitialState相当于构造方法，然后所有实例都享有同一个原型)，由于getDefaultProps在该方法之前被调用，所以此时我们已经可以访问到this.props了\n    \n    componentWillMount\n该方法在首次完成渲染之前被渲染，在这个方法里面，我们可以修改组件的一些state，需要注意的是，这是该组件完成实例化之前的最后一次修改\n    \n    render\n渲染虚拟DOM，对应一个组件来说，render方法是唯一一个必须实现的，并且遵循以下特殊的几个规则：\n\n1. 只能通过this.props和this.state来访问数据\n2. 可以返回null，boolean值或者任何形式的组件\n3. 只能出现一个顶级组件(不能返回多个一级标签并列)\n\n    \n    componentDidMount\n组件被实例化完成(render执行成功)后调用，可以在该方法中用this.getDOMNode()来访问到该组件，在这个方法中，比如我们要运行我们自定义的一个jQuery插件时，就可以直接写在里面，但是如果React运行在服务端，该方法将不会被调用\n    \n    \n#### 活动期\n\n随着组件的一些状态(比如鼠标点击、键盘输入等)发生改变，将依次调用以下一些方法\n\n    componentWillReciveProps\n在任意时刻，组件的props都可以通过父辈组件来修改，此时将调用该方法，我们可以在该方法对组件的state进行更新\n    \n    showComponentUpdate\n当props或者state发生改变，我们可以在该方法中进行比较修改前和修改后的数据，返回一个boolean值，React会根据这个来判断是否需要重新进行渲染\n    \n    componentWillUpdate\n和上一阶段的componentWillMount类似，只不过该方法是在重新进行渲染之前被调用\n    \n    render\n重新渲染虚拟DOM\n    \n    componentDidUpdate\n也和componentDidMount类似，只不过是在完成重新渲染之后被调用\n    \n#### 销毁期\n    \n最后该组件被使用完成，下面的方法将会给这个组件提供自身清理的机会\n    \n    componentWillUnmount\n比如我们在该组件中设置了一个定时器，添加了某些事件绑定等等，该方法就负责把定时器清除，移除事件监听的\n\n以上就是React中一个组件的生命周期\n\n---\n\n#### 反模式:把计算后的值赋值给state\n\n在getInitialState方法中，我们可以访问到this.props，通过this.props来创建state就是一种反模式。\n比如:在组件中,把当前事件转换成字符串格式，就只能在渲染时进行\n反模式的写法是不恰当的\n\n反模式中的写法:\n    \n    ...\n    getDefault:function(){\n        return {\n            \"date\":new Date()\n        };\n    },\n    getInitialState:function(){\n        return {\n            \"day\":this.props.getDay()\n        };\n    },\n    render:function(){\n        return <div>Day:{this.state.day}</div>\n    }\n    ...\n    \n正常模式的写法\n    \n    ...\n    getDefault:function(){\n        return {\n            \"date\":new Date()\n        };\n    },\n    render:function(){\n        var day = this.props.date.getDay()；\n        return <div>Day:{day}</div>\n    }\n    ...\n    \n好了，博客写完了，收工，睡觉！<img src=\"emoji/smile\" width=\"18\"/>","slug":"2015-12-01-react-component-life-time","published":1,"updated":"2016-09-27T04:11:34.000Z","comments":1,"photos":[],"link":"","_id":"civ7fsef7000zt95f1yhc8uls","content":"<p>在React的组件生命周期中，随着该组件的props活着state发生改变，对应的DOM也随着变换，一个组件对于特定的输入，它将返回一致的输出。</p>\n<p>在React中，对于每个组件都提供了相应的钩子去响应：</p>\n<ul>\n<li>创建时(实例化)</li>\n<li>存在期(活动期)</li>\n<li>销毁期</li>\n</ul>\n<hr>\n<h4 id=\"实例化\"><a href=\"#实例化\" class=\"headerlink\" title=\"实例化\"></a>实例化</h4><p>在React的一个组件被实例化时，将依次调用以下一些方法</p>\n<pre><code>getDefaultProps:\n</code></pre><p>对于某个组件类，该方法只会被调用一次。对于那些没有被父组件指定props属性的组件来说，该方法返回默认的props</p>\n<pre><code>getInitialState\n</code></pre><p>对于该组件的每个实例来说，该方法有且只能被调用一次，在这里，我们可以对每个组件的状态进行初始化，和getDefaultProps不同的是，getInitialState在每次被实例化时都会被调用(个人感觉这一点感觉和js面向对象中的构造方法和原型类似，getDefaultProps相当于一个原型，getInitialState相当于构造方法，然后所有实例都享有同一个原型)，由于getDefaultProps在该方法之前被调用，所以此时我们已经可以访问到this.props了</p>\n<pre><code>componentWillMount\n</code></pre><p>该方法在首次完成渲染之前被渲染，在这个方法里面，我们可以修改组件的一些state，需要注意的是，这是该组件完成实例化之前的最后一次修改</p>\n<pre><code>render\n</code></pre><p>渲染虚拟DOM，对应一个组件来说，render方法是唯一一个必须实现的，并且遵循以下特殊的几个规则：</p>\n<ol>\n<li>只能通过this.props和this.state来访问数据</li>\n<li>可以返回null，boolean值或者任何形式的组件</li>\n<li>只能出现一个顶级组件(不能返回多个一级标签并列)</li>\n</ol>\n<pre><code>componentDidMount\n</code></pre><p>组件被实例化完成(render执行成功)后调用，可以在该方法中用this.getDOMNode()来访问到该组件，在这个方法中，比如我们要运行我们自定义的一个jQuery插件时，就可以直接写在里面，但是如果React运行在服务端，该方法将不会被调用</p>\n<h4 id=\"活动期\"><a href=\"#活动期\" class=\"headerlink\" title=\"活动期\"></a>活动期</h4><p>随着组件的一些状态(比如鼠标点击、键盘输入等)发生改变，将依次调用以下一些方法</p>\n<pre><code>componentWillReciveProps\n</code></pre><p>在任意时刻，组件的props都可以通过父辈组件来修改，此时将调用该方法，我们可以在该方法对组件的state进行更新</p>\n<pre><code>showComponentUpdate\n</code></pre><p>当props或者state发生改变，我们可以在该方法中进行比较修改前和修改后的数据，返回一个boolean值，React会根据这个来判断是否需要重新进行渲染</p>\n<pre><code>componentWillUpdate\n</code></pre><p>和上一阶段的componentWillMount类似，只不过该方法是在重新进行渲染之前被调用</p>\n<pre><code>render\n</code></pre><p>重新渲染虚拟DOM</p>\n<pre><code>componentDidUpdate\n</code></pre><p>也和componentDidMount类似，只不过是在完成重新渲染之后被调用</p>\n<h4 id=\"销毁期\"><a href=\"#销毁期\" class=\"headerlink\" title=\"销毁期\"></a>销毁期</h4><p>最后该组件被使用完成，下面的方法将会给这个组件提供自身清理的机会</p>\n<pre><code>componentWillUnmount\n</code></pre><p>比如我们在该组件中设置了一个定时器，添加了某些事件绑定等等，该方法就负责把定时器清除，移除事件监听的</p>\n<p>以上就是React中一个组件的生命周期</p>\n<hr>\n<h4 id=\"反模式-把计算后的值赋值给state\"><a href=\"#反模式-把计算后的值赋值给state\" class=\"headerlink\" title=\"反模式:把计算后的值赋值给state\"></a>反模式:把计算后的值赋值给state</h4><p>在getInitialState方法中，我们可以访问到this.props，通过this.props来创建state就是一种反模式。<br>比如:在组件中,把当前事件转换成字符串格式，就只能在渲染时进行<br>反模式的写法是不恰当的</p>\n<p>反模式中的写法:</p>\n<pre><code>...\ngetDefault:function(){\n    return {\n        &quot;date&quot;:new Date()\n    };\n},\ngetInitialState:function(){\n    return {\n        &quot;day&quot;:this.props.getDay()\n    };\n},\nrender:function(){\n    return &lt;div&gt;Day:{this.state.day}&lt;/div&gt;\n}\n...\n</code></pre><p>正常模式的写法</p>\n<pre><code>...\ngetDefault:function(){\n    return {\n        &quot;date&quot;:new Date()\n    };\n},\nrender:function(){\n    var day = this.props.date.getDay()；\n    return &lt;div&gt;Day:{day}&lt;/div&gt;\n}\n...\n</code></pre><p>好了，博客写完了，收工，睡觉！<img src=\"emoji/smile\" width=\"18\"></p>\n","excerpt":"","more":"<p>在React的组件生命周期中，随着该组件的props活着state发生改变，对应的DOM也随着变换，一个组件对于特定的输入，它将返回一致的输出。</p>\n<p>在React中，对于每个组件都提供了相应的钩子去响应：</p>\n<ul>\n<li>创建时(实例化)</li>\n<li>存在期(活动期)</li>\n<li>销毁期</li>\n</ul>\n<hr>\n<h4 id=\"实例化\"><a href=\"#实例化\" class=\"headerlink\" title=\"实例化\"></a>实例化</h4><p>在React的一个组件被实例化时，将依次调用以下一些方法</p>\n<pre><code>getDefaultProps:\n</code></pre><p>对于某个组件类，该方法只会被调用一次。对于那些没有被父组件指定props属性的组件来说，该方法返回默认的props</p>\n<pre><code>getInitialState\n</code></pre><p>对于该组件的每个实例来说，该方法有且只能被调用一次，在这里，我们可以对每个组件的状态进行初始化，和getDefaultProps不同的是，getInitialState在每次被实例化时都会被调用(个人感觉这一点感觉和js面向对象中的构造方法和原型类似，getDefaultProps相当于一个原型，getInitialState相当于构造方法，然后所有实例都享有同一个原型)，由于getDefaultProps在该方法之前被调用，所以此时我们已经可以访问到this.props了</p>\n<pre><code>componentWillMount\n</code></pre><p>该方法在首次完成渲染之前被渲染，在这个方法里面，我们可以修改组件的一些state，需要注意的是，这是该组件完成实例化之前的最后一次修改</p>\n<pre><code>render\n</code></pre><p>渲染虚拟DOM，对应一个组件来说，render方法是唯一一个必须实现的，并且遵循以下特殊的几个规则：</p>\n<ol>\n<li>只能通过this.props和this.state来访问数据</li>\n<li>可以返回null，boolean值或者任何形式的组件</li>\n<li>只能出现一个顶级组件(不能返回多个一级标签并列)</li>\n</ol>\n<pre><code>componentDidMount\n</code></pre><p>组件被实例化完成(render执行成功)后调用，可以在该方法中用this.getDOMNode()来访问到该组件，在这个方法中，比如我们要运行我们自定义的一个jQuery插件时，就可以直接写在里面，但是如果React运行在服务端，该方法将不会被调用</p>\n<h4 id=\"活动期\"><a href=\"#活动期\" class=\"headerlink\" title=\"活动期\"></a>活动期</h4><p>随着组件的一些状态(比如鼠标点击、键盘输入等)发生改变，将依次调用以下一些方法</p>\n<pre><code>componentWillReciveProps\n</code></pre><p>在任意时刻，组件的props都可以通过父辈组件来修改，此时将调用该方法，我们可以在该方法对组件的state进行更新</p>\n<pre><code>showComponentUpdate\n</code></pre><p>当props或者state发生改变，我们可以在该方法中进行比较修改前和修改后的数据，返回一个boolean值，React会根据这个来判断是否需要重新进行渲染</p>\n<pre><code>componentWillUpdate\n</code></pre><p>和上一阶段的componentWillMount类似，只不过该方法是在重新进行渲染之前被调用</p>\n<pre><code>render\n</code></pre><p>重新渲染虚拟DOM</p>\n<pre><code>componentDidUpdate\n</code></pre><p>也和componentDidMount类似，只不过是在完成重新渲染之后被调用</p>\n<h4 id=\"销毁期\"><a href=\"#销毁期\" class=\"headerlink\" title=\"销毁期\"></a>销毁期</h4><p>最后该组件被使用完成，下面的方法将会给这个组件提供自身清理的机会</p>\n<pre><code>componentWillUnmount\n</code></pre><p>比如我们在该组件中设置了一个定时器，添加了某些事件绑定等等，该方法就负责把定时器清除，移除事件监听的</p>\n<p>以上就是React中一个组件的生命周期</p>\n<hr>\n<h4 id=\"反模式-把计算后的值赋值给state\"><a href=\"#反模式-把计算后的值赋值给state\" class=\"headerlink\" title=\"反模式:把计算后的值赋值给state\"></a>反模式:把计算后的值赋值给state</h4><p>在getInitialState方法中，我们可以访问到this.props，通过this.props来创建state就是一种反模式。<br>比如:在组件中,把当前事件转换成字符串格式，就只能在渲染时进行<br>反模式的写法是不恰当的</p>\n<p>反模式中的写法:</p>\n<pre><code>...\ngetDefault:function(){\n    return {\n        &quot;date&quot;:new Date()\n    };\n},\ngetInitialState:function(){\n    return {\n        &quot;day&quot;:this.props.getDay()\n    };\n},\nrender:function(){\n    return &lt;div&gt;Day:{this.state.day}&lt;/div&gt;\n}\n...\n</code></pre><p>正常模式的写法</p>\n<pre><code>...\ngetDefault:function(){\n    return {\n        &quot;date&quot;:new Date()\n    };\n},\nrender:function(){\n    var day = this.props.date.getDay()；\n    return &lt;div&gt;Day:{day}&lt;/div&gt;\n}\n...\n</code></pre><p>好了，博客写完了，收工，睡觉！<img src=\"emoji/smile\" width=\"18\"/></p>\n"},{"layout":"post","title":"React中的数据流","date":"2015-12-01T16:00:00.000Z","_content":"\n昨天学习完组件的生命周期，今天学习学习React中的数据流。\n\n在React中，数据流是单向的(由父节点传递到子节点)，因此组件变得简单且易于把握，它们只需要从父节点中获取props来渲染即可，某个组件顶层的props发生改变，React会递归遍历整个组件树，并且重新渲染使用这个属性的组件。\n\n在React组件内部，还具有自己的状态，但是只能在组件内部进行修改。\n\n#### React中的props:\n\nprops就是properties的缩写，接收任意类型的数据。\n\n设置组件的props有两种方法:\n\n1. 可以在挂载组件的时候设置\n    \n        var surveys = [\n            {\n                \"title\":\"some value\"\n            }\n        ];\n        <ListSurveys surveys={surveys} />\n\n2.  或者调用组件实例的setProps方法\n        \n        var surveys = [\n            {\n                \"title\":\"some value\"\n            }\n        ];\n        var listSurveys = React.render(<ListSurveys/>,document.body);\n        listSurveys.setProps({\"surveys\":surveys});\n\n需要注意的是，只能在子组件或者组件树外面调用setProps方法，但是不能用this.setProps，如果非要这样，可以用state来代替。\n\n可以通过this.props来访问props，但是不能修改，组件不能对自己的props进行修改。\n\nJSX中props的几种使用\n\n1. 把props设置成字符串\n        \n        <a href=\"/a/b\"></a>\n\n2. 用JSX中的展开语法({...obj})把props设置成一个对象\n    \n        var aComponent = React.createClass({\n            render:function(){\n                var props = {\n                        \"a\":\"foo\",\n                        \"b\":\"bar\"\n                };\n                return (\n                    <aComponent {...props} />\n                );\n            }\n        });\n\n3. 绑定事件\n\n        var aComponent = React.createClass({\n            handleClick:function(){\n                ...\n            },\n            render:function(){\n                return (\n                    <button onClick={this.handleClick}>啦啦啦</button>\n                );\n            }\n        });\n\n我们给button添加了一个onClick属性,值为handleClick，当该按钮被点击，将执行handleClick方法。\n\nPropTypes:\n\nReact中提供一个验证props的方式(通过在组件中定义一组对象)\n\n        var aCOmponent = React.createClass({\n            PropTypes:{\n                survey:React.PropTypes.shape({\n                    id:React.PropTypes.number.isRequired\n                }).isRequired,\n                onClick:React.ProTypes.func\n            },\n            ...\n        });\n        \n在组件初始化时，如果指定的props和指定的类型不匹配，控制台会打出一个警告，如果不是必传的prop，可以不用isRequired，尽管这个不是必须的，但是有了它，我们将更能清楚的知道该组件对props的数据格式/必填性等要求。\n\ngetDefaultProps方法:\n\n我们可以调用这个方法给某个组件添加props的默认值，但是这只能对非必填属性，需要注意的是，该方法在React.createClass(声明组件)的时候就被调用了，返回值将被缓存起来。\n\n        var aCOmponent = React.createClass({\n            getDefaultProps:function(){\n                return {\n                    survey:[]\n                };\n            },\n            ...\n        });\n\n#### React中的state\n\n每个组件都有自己的state，state和props的区别在与state只能存在于组件内部(前面说props可以在组件外部通过实例方法进行修改，但是不能在在组件内部用this.setProps来修改，对应state来说，只能通过this.setState来进行修改)\n\nstate可以用来确定一个元素视图的状态，比如我们在下面自定义一个dropDown组件:\n\n    var dropDown = React.createClass({\n        getInitialState:function(){\n            return {\n                showOptions:false\n            };\n        },\n        render:function(){\n            var options = \"\";\n            if(this.state.showOptions){\n                options = <ul className=\"option-item\">\n                    <li>option-1</li>\n                    <li>option-2</li>\n                    <li>option-3</li>\n                    <li>option-4</li>\n                </ul>;\n            }\n            return (\n                <div className=\"dropDown\">\n                    <label onClick={this.handleClick}>select an option</label>\n                    {options}\n                </div>\n            );\n        },\n        handleClick:function(){\n            this.setState({\n                showOptions:true\n            });\n        }\n    });\n    \n在本例中，state被用来判断是否显示下拉框中的可选项。\n\n在React中，state可以用this.setState来进行修改，也可以通过getInitialState方法提供一些默认值，只要setState被调用，render方法也会被调用，如果render的返回值有变化，DOM也会被更新，我们看到的当然也有变化。\n\n和props类似，我们只能通过this.state来访问state，但是决不能通过这种方式对state进行修改。\n\n\n---\n\n好了，上面就是关于props和state的一个学习，下面我们介绍下props和state中应该放些什么东西\n\nprops:数据源、计算后的结果、等等\n\nstate:组件渲染时的必要数据(boolean值[控制显示隐藏等]、输入框值、等等)\n\n同时，不要想着把props的值赋值给state\n","source":"_posts/2015-12-02-react-data-flow.md","raw":"---\nlayout: post\ntitle: React中的数据流\ndate: 2015-12-02\ncategories: [React]\n---\n\n昨天学习完组件的生命周期，今天学习学习React中的数据流。\n\n在React中，数据流是单向的(由父节点传递到子节点)，因此组件变得简单且易于把握，它们只需要从父节点中获取props来渲染即可，某个组件顶层的props发生改变，React会递归遍历整个组件树，并且重新渲染使用这个属性的组件。\n\n在React组件内部，还具有自己的状态，但是只能在组件内部进行修改。\n\n#### React中的props:\n\nprops就是properties的缩写，接收任意类型的数据。\n\n设置组件的props有两种方法:\n\n1. 可以在挂载组件的时候设置\n    \n        var surveys = [\n            {\n                \"title\":\"some value\"\n            }\n        ];\n        <ListSurveys surveys={surveys} />\n\n2.  或者调用组件实例的setProps方法\n        \n        var surveys = [\n            {\n                \"title\":\"some value\"\n            }\n        ];\n        var listSurveys = React.render(<ListSurveys/>,document.body);\n        listSurveys.setProps({\"surveys\":surveys});\n\n需要注意的是，只能在子组件或者组件树外面调用setProps方法，但是不能用this.setProps，如果非要这样，可以用state来代替。\n\n可以通过this.props来访问props，但是不能修改，组件不能对自己的props进行修改。\n\nJSX中props的几种使用\n\n1. 把props设置成字符串\n        \n        <a href=\"/a/b\"></a>\n\n2. 用JSX中的展开语法({...obj})把props设置成一个对象\n    \n        var aComponent = React.createClass({\n            render:function(){\n                var props = {\n                        \"a\":\"foo\",\n                        \"b\":\"bar\"\n                };\n                return (\n                    <aComponent {...props} />\n                );\n            }\n        });\n\n3. 绑定事件\n\n        var aComponent = React.createClass({\n            handleClick:function(){\n                ...\n            },\n            render:function(){\n                return (\n                    <button onClick={this.handleClick}>啦啦啦</button>\n                );\n            }\n        });\n\n我们给button添加了一个onClick属性,值为handleClick，当该按钮被点击，将执行handleClick方法。\n\nPropTypes:\n\nReact中提供一个验证props的方式(通过在组件中定义一组对象)\n\n        var aCOmponent = React.createClass({\n            PropTypes:{\n                survey:React.PropTypes.shape({\n                    id:React.PropTypes.number.isRequired\n                }).isRequired,\n                onClick:React.ProTypes.func\n            },\n            ...\n        });\n        \n在组件初始化时，如果指定的props和指定的类型不匹配，控制台会打出一个警告，如果不是必传的prop，可以不用isRequired，尽管这个不是必须的，但是有了它，我们将更能清楚的知道该组件对props的数据格式/必填性等要求。\n\ngetDefaultProps方法:\n\n我们可以调用这个方法给某个组件添加props的默认值，但是这只能对非必填属性，需要注意的是，该方法在React.createClass(声明组件)的时候就被调用了，返回值将被缓存起来。\n\n        var aCOmponent = React.createClass({\n            getDefaultProps:function(){\n                return {\n                    survey:[]\n                };\n            },\n            ...\n        });\n\n#### React中的state\n\n每个组件都有自己的state，state和props的区别在与state只能存在于组件内部(前面说props可以在组件外部通过实例方法进行修改，但是不能在在组件内部用this.setProps来修改，对应state来说，只能通过this.setState来进行修改)\n\nstate可以用来确定一个元素视图的状态，比如我们在下面自定义一个dropDown组件:\n\n    var dropDown = React.createClass({\n        getInitialState:function(){\n            return {\n                showOptions:false\n            };\n        },\n        render:function(){\n            var options = \"\";\n            if(this.state.showOptions){\n                options = <ul className=\"option-item\">\n                    <li>option-1</li>\n                    <li>option-2</li>\n                    <li>option-3</li>\n                    <li>option-4</li>\n                </ul>;\n            }\n            return (\n                <div className=\"dropDown\">\n                    <label onClick={this.handleClick}>select an option</label>\n                    {options}\n                </div>\n            );\n        },\n        handleClick:function(){\n            this.setState({\n                showOptions:true\n            });\n        }\n    });\n    \n在本例中，state被用来判断是否显示下拉框中的可选项。\n\n在React中，state可以用this.setState来进行修改，也可以通过getInitialState方法提供一些默认值，只要setState被调用，render方法也会被调用，如果render的返回值有变化，DOM也会被更新，我们看到的当然也有变化。\n\n和props类似，我们只能通过this.state来访问state，但是决不能通过这种方式对state进行修改。\n\n\n---\n\n好了，上面就是关于props和state的一个学习，下面我们介绍下props和state中应该放些什么东西\n\nprops:数据源、计算后的结果、等等\n\nstate:组件渲染时的必要数据(boolean值[控制显示隐藏等]、输入框值、等等)\n\n同时，不要想着把props的值赋值给state\n","slug":"2015-12-02-react-data-flow","published":1,"updated":"2016-09-27T04:11:41.000Z","comments":1,"photos":[],"link":"","_id":"civ7fsef80011t95fe231tn1q","content":"<p>昨天学习完组件的生命周期，今天学习学习React中的数据流。</p>\n<p>在React中，数据流是单向的(由父节点传递到子节点)，因此组件变得简单且易于把握，它们只需要从父节点中获取props来渲染即可，某个组件顶层的props发生改变，React会递归遍历整个组件树，并且重新渲染使用这个属性的组件。</p>\n<p>在React组件内部，还具有自己的状态，但是只能在组件内部进行修改。</p>\n<h4 id=\"React中的props\"><a href=\"#React中的props\" class=\"headerlink\" title=\"React中的props:\"></a>React中的props:</h4><p>props就是properties的缩写，接收任意类型的数据。</p>\n<p>设置组件的props有两种方法:</p>\n<ol>\n<li><p>可以在挂载组件的时候设置</p>\n<pre><code>var surveys = [\n    {\n        &quot;title&quot;:&quot;some value&quot;\n    }\n];\n&lt;ListSurveys surveys={surveys} /&gt;\n</code></pre></li>\n<li><p>或者调用组件实例的setProps方法</p>\n<pre><code>var surveys = [\n    {\n        &quot;title&quot;:&quot;some value&quot;\n    }\n];\nvar listSurveys = React.render(&lt;ListSurveys/&gt;,document.body);\nlistSurveys.setProps({&quot;surveys&quot;:surveys});\n</code></pre></li>\n</ol>\n<p>需要注意的是，只能在子组件或者组件树外面调用setProps方法，但是不能用this.setProps，如果非要这样，可以用state来代替。</p>\n<p>可以通过this.props来访问props，但是不能修改，组件不能对自己的props进行修改。</p>\n<p>JSX中props的几种使用</p>\n<ol>\n<li><p>把props设置成字符串</p>\n<pre><code>&lt;a href=&quot;/a/b&quot;&gt;&lt;/a&gt;\n</code></pre></li>\n<li><p>用JSX中的展开语法({…obj})把props设置成一个对象</p>\n<pre><code>var aComponent = React.createClass({\n    render:function(){\n        var props = {\n                &quot;a&quot;:&quot;foo&quot;,\n                &quot;b&quot;:&quot;bar&quot;\n        };\n        return (\n            &lt;aComponent {...props} /&gt;\n        );\n    }\n});\n</code></pre></li>\n<li><p>绑定事件</p>\n<pre><code>var aComponent = React.createClass({\n    handleClick:function(){\n        ...\n    },\n    render:function(){\n        return (\n            &lt;button onClick={this.handleClick}&gt;啦啦啦&lt;/button&gt;\n        );\n    }\n});\n</code></pre></li>\n</ol>\n<p>我们给button添加了一个onClick属性,值为handleClick，当该按钮被点击，将执行handleClick方法。</p>\n<p>PropTypes:</p>\n<p>React中提供一个验证props的方式(通过在组件中定义一组对象)</p>\n<pre><code>var aCOmponent = React.createClass({\n    PropTypes:{\n        survey:React.PropTypes.shape({\n            id:React.PropTypes.number.isRequired\n        }).isRequired,\n        onClick:React.ProTypes.func\n    },\n    ...\n});\n</code></pre><p>在组件初始化时，如果指定的props和指定的类型不匹配，控制台会打出一个警告，如果不是必传的prop，可以不用isRequired，尽管这个不是必须的，但是有了它，我们将更能清楚的知道该组件对props的数据格式/必填性等要求。</p>\n<p>getDefaultProps方法:</p>\n<p>我们可以调用这个方法给某个组件添加props的默认值，但是这只能对非必填属性，需要注意的是，该方法在React.createClass(声明组件)的时候就被调用了，返回值将被缓存起来。</p>\n<pre><code>var aCOmponent = React.createClass({\n    getDefaultProps:function(){\n        return {\n            survey:[]\n        };\n    },\n    ...\n});\n</code></pre><h4 id=\"React中的state\"><a href=\"#React中的state\" class=\"headerlink\" title=\"React中的state\"></a>React中的state</h4><p>每个组件都有自己的state，state和props的区别在与state只能存在于组件内部(前面说props可以在组件外部通过实例方法进行修改，但是不能在在组件内部用this.setProps来修改，对应state来说，只能通过this.setState来进行修改)</p>\n<p>state可以用来确定一个元素视图的状态，比如我们在下面自定义一个dropDown组件:</p>\n<pre><code>var dropDown = React.createClass({\n    getInitialState:function(){\n        return {\n            showOptions:false\n        };\n    },\n    render:function(){\n        var options = &quot;&quot;;\n        if(this.state.showOptions){\n            options = &lt;ul className=&quot;option-item&quot;&gt;\n                &lt;li&gt;option-1&lt;/li&gt;\n                &lt;li&gt;option-2&lt;/li&gt;\n                &lt;li&gt;option-3&lt;/li&gt;\n                &lt;li&gt;option-4&lt;/li&gt;\n            &lt;/ul&gt;;\n        }\n        return (\n            &lt;div className=&quot;dropDown&quot;&gt;\n                &lt;label onClick={this.handleClick}&gt;select an option&lt;/label&gt;\n                {options}\n            &lt;/div&gt;\n        );\n    },\n    handleClick:function(){\n        this.setState({\n            showOptions:true\n        });\n    }\n});\n</code></pre><p>在本例中，state被用来判断是否显示下拉框中的可选项。</p>\n<p>在React中，state可以用this.setState来进行修改，也可以通过getInitialState方法提供一些默认值，只要setState被调用，render方法也会被调用，如果render的返回值有变化，DOM也会被更新，我们看到的当然也有变化。</p>\n<p>和props类似，我们只能通过this.state来访问state，但是决不能通过这种方式对state进行修改。</p>\n<hr>\n<p>好了，上面就是关于props和state的一个学习，下面我们介绍下props和state中应该放些什么东西</p>\n<p>props:数据源、计算后的结果、等等</p>\n<p>state:组件渲染时的必要数据(boolean值[控制显示隐藏等]、输入框值、等等)</p>\n<p>同时，不要想着把props的值赋值给state</p>\n","excerpt":"","more":"<p>昨天学习完组件的生命周期，今天学习学习React中的数据流。</p>\n<p>在React中，数据流是单向的(由父节点传递到子节点)，因此组件变得简单且易于把握，它们只需要从父节点中获取props来渲染即可，某个组件顶层的props发生改变，React会递归遍历整个组件树，并且重新渲染使用这个属性的组件。</p>\n<p>在React组件内部，还具有自己的状态，但是只能在组件内部进行修改。</p>\n<h4 id=\"React中的props\"><a href=\"#React中的props\" class=\"headerlink\" title=\"React中的props:\"></a>React中的props:</h4><p>props就是properties的缩写，接收任意类型的数据。</p>\n<p>设置组件的props有两种方法:</p>\n<ol>\n<li><p>可以在挂载组件的时候设置</p>\n<pre><code>var surveys = [\n    {\n        &quot;title&quot;:&quot;some value&quot;\n    }\n];\n&lt;ListSurveys surveys={surveys} /&gt;\n</code></pre></li>\n<li><p>或者调用组件实例的setProps方法</p>\n<pre><code>var surveys = [\n    {\n        &quot;title&quot;:&quot;some value&quot;\n    }\n];\nvar listSurveys = React.render(&lt;ListSurveys/&gt;,document.body);\nlistSurveys.setProps({&quot;surveys&quot;:surveys});\n</code></pre></li>\n</ol>\n<p>需要注意的是，只能在子组件或者组件树外面调用setProps方法，但是不能用this.setProps，如果非要这样，可以用state来代替。</p>\n<p>可以通过this.props来访问props，但是不能修改，组件不能对自己的props进行修改。</p>\n<p>JSX中props的几种使用</p>\n<ol>\n<li><p>把props设置成字符串</p>\n<pre><code>&lt;a href=&quot;/a/b&quot;&gt;&lt;/a&gt;\n</code></pre></li>\n<li><p>用JSX中的展开语法({…obj})把props设置成一个对象</p>\n<pre><code>var aComponent = React.createClass({\n    render:function(){\n        var props = {\n                &quot;a&quot;:&quot;foo&quot;,\n                &quot;b&quot;:&quot;bar&quot;\n        };\n        return (\n            &lt;aComponent {...props} /&gt;\n        );\n    }\n});\n</code></pre></li>\n<li><p>绑定事件</p>\n<pre><code>var aComponent = React.createClass({\n    handleClick:function(){\n        ...\n    },\n    render:function(){\n        return (\n            &lt;button onClick={this.handleClick}&gt;啦啦啦&lt;/button&gt;\n        );\n    }\n});\n</code></pre></li>\n</ol>\n<p>我们给button添加了一个onClick属性,值为handleClick，当该按钮被点击，将执行handleClick方法。</p>\n<p>PropTypes:</p>\n<p>React中提供一个验证props的方式(通过在组件中定义一组对象)</p>\n<pre><code>var aCOmponent = React.createClass({\n    PropTypes:{\n        survey:React.PropTypes.shape({\n            id:React.PropTypes.number.isRequired\n        }).isRequired,\n        onClick:React.ProTypes.func\n    },\n    ...\n});\n</code></pre><p>在组件初始化时，如果指定的props和指定的类型不匹配，控制台会打出一个警告，如果不是必传的prop，可以不用isRequired，尽管这个不是必须的，但是有了它，我们将更能清楚的知道该组件对props的数据格式/必填性等要求。</p>\n<p>getDefaultProps方法:</p>\n<p>我们可以调用这个方法给某个组件添加props的默认值，但是这只能对非必填属性，需要注意的是，该方法在React.createClass(声明组件)的时候就被调用了，返回值将被缓存起来。</p>\n<pre><code>var aCOmponent = React.createClass({\n    getDefaultProps:function(){\n        return {\n            survey:[]\n        };\n    },\n    ...\n});\n</code></pre><h4 id=\"React中的state\"><a href=\"#React中的state\" class=\"headerlink\" title=\"React中的state\"></a>React中的state</h4><p>每个组件都有自己的state，state和props的区别在与state只能存在于组件内部(前面说props可以在组件外部通过实例方法进行修改，但是不能在在组件内部用this.setProps来修改，对应state来说，只能通过this.setState来进行修改)</p>\n<p>state可以用来确定一个元素视图的状态，比如我们在下面自定义一个dropDown组件:</p>\n<pre><code>var dropDown = React.createClass({\n    getInitialState:function(){\n        return {\n            showOptions:false\n        };\n    },\n    render:function(){\n        var options = &quot;&quot;;\n        if(this.state.showOptions){\n            options = &lt;ul className=&quot;option-item&quot;&gt;\n                &lt;li&gt;option-1&lt;/li&gt;\n                &lt;li&gt;option-2&lt;/li&gt;\n                &lt;li&gt;option-3&lt;/li&gt;\n                &lt;li&gt;option-4&lt;/li&gt;\n            &lt;/ul&gt;;\n        }\n        return (\n            &lt;div className=&quot;dropDown&quot;&gt;\n                &lt;label onClick={this.handleClick}&gt;select an option&lt;/label&gt;\n                {options}\n            &lt;/div&gt;\n        );\n    },\n    handleClick:function(){\n        this.setState({\n            showOptions:true\n        });\n    }\n});\n</code></pre><p>在本例中，state被用来判断是否显示下拉框中的可选项。</p>\n<p>在React中，state可以用this.setState来进行修改，也可以通过getInitialState方法提供一些默认值，只要setState被调用，render方法也会被调用，如果render的返回值有变化，DOM也会被更新，我们看到的当然也有变化。</p>\n<p>和props类似，我们只能通过this.state来访问state，但是决不能通过这种方式对state进行修改。</p>\n<hr>\n<p>好了，上面就是关于props和state的一个学习，下面我们介绍下props和state中应该放些什么东西</p>\n<p>props:数据源、计算后的结果、等等</p>\n<p>state:组件渲染时的必要数据(boolean值[控制显示隐藏等]、输入框值、等等)</p>\n<p>同时，不要想着把props的值赋值给state</p>\n"},{"layout":"post","title":"React中的事件","date":"2015-12-02T16:00:00.000Z","_content":"\n对于用户界面来说，展示最多只占整体因素的一半，另一半则是用户输入，即通过javaScript来完成人机交互。\n\n在React中，通过将事件绑定到组件上到形式来对事件进行处理。在触发事件的同时，相关处理函数对组件对状态进行修改，再调用render方法重绘，达到响应用户输入的目的。\n\n#### 绑定事件处理器\n\nReact的事件本质上和原生的javaScript类似，比如MouseEvent用来处理用户鼠标点击，Change用来处理表单元素的变化等，所有事件在命名上和JavaScript规范一致，并且会在相同的情况下被触发。\n\nReact绑定事件的写法和在HTML上绑定事件的写法很像，比如我们下面将绑定一个click事件:\n\n    ...\n    handleClick:function(){\n        ...\n    },\n    render:function(){\n        return (\n            <button onClick={this.handleClick}>click</button>\n        );\n    },\n    ...\n    \n这样，我们就完成了一个click事件的绑定，当用户点击这个按钮，handleClick将被调用，完成一些逻辑。\n\n就拿刚才上面的代码举例,我们在handleClick中用this,此时发现this指向了window对象,所以如果要在里面读取state/prop就比较麻烦,这时可以通过ES5中的bind方法来修改this的指向,就像下面这样:\n\n    ...\n    handleClick: function(){\n        //  ...\n    },\n    render: function(){\n        return (\n            <button onClick={this.handleClick.bind(this, [....argus])}>click</button>\n        );\n    },\n    ...\n    \n后面还可以传入参数,还可以在getInitialState(或者ES6语法的constructor里)手动指定一个新属性,来达到修改this指向的目的:\n\n- ES5\n\n    \n    //  ...\n\n    var Comp = React.createClass({\n\n        getInitialState: function() {\n            this.handleClick = this._handleClick.bind(this);\n        },\n        \n        _handleClick: function() {\n            //  事件的处理逻辑\n        },\n        \n        render: function() {\n            return (\n                <button onClick={this.handleClick}>click</button>\n            );\n        }\n\n    });\n\n\n- ES6\n\n    \n    //  ...\n    \n    class Comp extends Component {\n    \n        constructor(props) {\n            super(props);\n            \n            this.handleClick = this._handleClick.bind(this);\n        }\n    \n        _handleClick() {\n            //  事件的处理逻辑\n        }\n        \n        render() {\n            const {handleClick} = this;\n            return  (\n                <button onClick={handleClick}>click</button>\n            );\n        }\n    }\n\n刚才是在JSX语法上绑定的事件，如果不用JSX，我们就需要换成下面的绑定方法:\n\n    React.DOM.button({\n        \"className\":\"btn-click\",\n        \"onClick\":this.handleClick\n    },\"click\");\n    \n    //  从React 0.12.x版本开始，推荐使用React.createElement的写法\n    \n此外，如果需要支持移动端触碰事件，建议加上下面的代码:\n\n    React.initializeTouchEvents(true);\n    \n#### 事件和状态\n\n如果想让一个组件随着用户的输入而改变，我们就要在事件处理函数中对这个组件的某些状态进行修改。\n\n比如我们下面讲完成一个类似于angularJs中双向数据绑定的效果。\n\n    var Component = React.createClass({\n      handleChange: function(ev) {\n        this.setState({\n            value:ev.target.value\n        });\n      },\n      render: function() {\n        var value = this.state.value;\n        return (\n          <div>\n            <input type=\"text\" onChange={this.handleChange} />\n            <span>{value}</span>\n          </div>\n        );\n      }\n    });\n    \n    ReactDOM.render(\n      <Component />,\n      document.getElementById(\"div\")\n    );\n    \n此时我们的输入会在两个地方显示，一个是在输入框里面，一个在输入框后面，且值都相同。\n\n#### 更新组件的状态\n\n更新状态完成之后组件会调用render方法进行重绘。\n\n在React中，有两种更新组件状态的方法，一种是调用this.setState，一种是调用this.replaceState，第一种只是重新设置组件的状态，第二种会把组件原来所以的状态清除，然后用一个全新的对象来替换组件当前的状态对象，这种用起来一定要小心，因为如果替换的对象少了一个属性值或者属性值类型不同而render方法就正好用到这个属性值，那render方法就不会往下继续走了，所以很少地方使用。大多情况还是使用第一种this.setState来修改组件的状态。\n\n","source":"_posts/2015-12-03-react-events.md","raw":"---\nlayout: post\ntitle: React中的事件\ndate: 2015-12-03\ncategories: [React]\n---\n\n对于用户界面来说，展示最多只占整体因素的一半，另一半则是用户输入，即通过javaScript来完成人机交互。\n\n在React中，通过将事件绑定到组件上到形式来对事件进行处理。在触发事件的同时，相关处理函数对组件对状态进行修改，再调用render方法重绘，达到响应用户输入的目的。\n\n#### 绑定事件处理器\n\nReact的事件本质上和原生的javaScript类似，比如MouseEvent用来处理用户鼠标点击，Change用来处理表单元素的变化等，所有事件在命名上和JavaScript规范一致，并且会在相同的情况下被触发。\n\nReact绑定事件的写法和在HTML上绑定事件的写法很像，比如我们下面将绑定一个click事件:\n\n    ...\n    handleClick:function(){\n        ...\n    },\n    render:function(){\n        return (\n            <button onClick={this.handleClick}>click</button>\n        );\n    },\n    ...\n    \n这样，我们就完成了一个click事件的绑定，当用户点击这个按钮，handleClick将被调用，完成一些逻辑。\n\n就拿刚才上面的代码举例,我们在handleClick中用this,此时发现this指向了window对象,所以如果要在里面读取state/prop就比较麻烦,这时可以通过ES5中的bind方法来修改this的指向,就像下面这样:\n\n    ...\n    handleClick: function(){\n        //  ...\n    },\n    render: function(){\n        return (\n            <button onClick={this.handleClick.bind(this, [....argus])}>click</button>\n        );\n    },\n    ...\n    \n后面还可以传入参数,还可以在getInitialState(或者ES6语法的constructor里)手动指定一个新属性,来达到修改this指向的目的:\n\n- ES5\n\n    \n    //  ...\n\n    var Comp = React.createClass({\n\n        getInitialState: function() {\n            this.handleClick = this._handleClick.bind(this);\n        },\n        \n        _handleClick: function() {\n            //  事件的处理逻辑\n        },\n        \n        render: function() {\n            return (\n                <button onClick={this.handleClick}>click</button>\n            );\n        }\n\n    });\n\n\n- ES6\n\n    \n    //  ...\n    \n    class Comp extends Component {\n    \n        constructor(props) {\n            super(props);\n            \n            this.handleClick = this._handleClick.bind(this);\n        }\n    \n        _handleClick() {\n            //  事件的处理逻辑\n        }\n        \n        render() {\n            const {handleClick} = this;\n            return  (\n                <button onClick={handleClick}>click</button>\n            );\n        }\n    }\n\n刚才是在JSX语法上绑定的事件，如果不用JSX，我们就需要换成下面的绑定方法:\n\n    React.DOM.button({\n        \"className\":\"btn-click\",\n        \"onClick\":this.handleClick\n    },\"click\");\n    \n    //  从React 0.12.x版本开始，推荐使用React.createElement的写法\n    \n此外，如果需要支持移动端触碰事件，建议加上下面的代码:\n\n    React.initializeTouchEvents(true);\n    \n#### 事件和状态\n\n如果想让一个组件随着用户的输入而改变，我们就要在事件处理函数中对这个组件的某些状态进行修改。\n\n比如我们下面讲完成一个类似于angularJs中双向数据绑定的效果。\n\n    var Component = React.createClass({\n      handleChange: function(ev) {\n        this.setState({\n            value:ev.target.value\n        });\n      },\n      render: function() {\n        var value = this.state.value;\n        return (\n          <div>\n            <input type=\"text\" onChange={this.handleChange} />\n            <span>{value}</span>\n          </div>\n        );\n      }\n    });\n    \n    ReactDOM.render(\n      <Component />,\n      document.getElementById(\"div\")\n    );\n    \n此时我们的输入会在两个地方显示，一个是在输入框里面，一个在输入框后面，且值都相同。\n\n#### 更新组件的状态\n\n更新状态完成之后组件会调用render方法进行重绘。\n\n在React中，有两种更新组件状态的方法，一种是调用this.setState，一种是调用this.replaceState，第一种只是重新设置组件的状态，第二种会把组件原来所以的状态清除，然后用一个全新的对象来替换组件当前的状态对象，这种用起来一定要小心，因为如果替换的对象少了一个属性值或者属性值类型不同而render方法就正好用到这个属性值，那render方法就不会往下继续走了，所以很少地方使用。大多情况还是使用第一种this.setState来修改组件的状态。\n\n","slug":"2015-12-03-react-events","published":1,"updated":"2016-09-27T04:11:49.000Z","comments":1,"photos":[],"link":"","_id":"civ7fsef90014t95fv1vu4vnf","content":"<p>对于用户界面来说，展示最多只占整体因素的一半，另一半则是用户输入，即通过javaScript来完成人机交互。</p>\n<p>在React中，通过将事件绑定到组件上到形式来对事件进行处理。在触发事件的同时，相关处理函数对组件对状态进行修改，再调用render方法重绘，达到响应用户输入的目的。</p>\n<h4 id=\"绑定事件处理器\"><a href=\"#绑定事件处理器\" class=\"headerlink\" title=\"绑定事件处理器\"></a>绑定事件处理器</h4><p>React的事件本质上和原生的javaScript类似，比如MouseEvent用来处理用户鼠标点击，Change用来处理表单元素的变化等，所有事件在命名上和JavaScript规范一致，并且会在相同的情况下被触发。</p>\n<p>React绑定事件的写法和在HTML上绑定事件的写法很像，比如我们下面将绑定一个click事件:</p>\n<pre><code>...\nhandleClick:function(){\n    ...\n},\nrender:function(){\n    return (\n        &lt;button onClick={this.handleClick}&gt;click&lt;/button&gt;\n    );\n},\n...\n</code></pre><p>这样，我们就完成了一个click事件的绑定，当用户点击这个按钮，handleClick将被调用，完成一些逻辑。</p>\n<p>就拿刚才上面的代码举例,我们在handleClick中用this,此时发现this指向了window对象,所以如果要在里面读取state/prop就比较麻烦,这时可以通过ES5中的bind方法来修改this的指向,就像下面这样:</p>\n<pre><code>...\nhandleClick: function(){\n    //  ...\n},\nrender: function(){\n    return (\n        &lt;button onClick={this.handleClick.bind(this, [....argus])}&gt;click&lt;/button&gt;\n    );\n},\n...\n</code></pre><p>后面还可以传入参数,还可以在getInitialState(或者ES6语法的constructor里)手动指定一个新属性,来达到修改this指向的目的:</p>\n<ul>\n<li>ES5</li>\n</ul>\n<pre><code>//  ...\n\nvar Comp = React.createClass({\n\n    getInitialState: function() {\n        this.handleClick = this._handleClick.bind(this);\n    },\n\n    _handleClick: function() {\n        //  事件的处理逻辑\n    },\n\n    render: function() {\n        return (\n            &lt;button onClick={this.handleClick}&gt;click&lt;/button&gt;\n        );\n    }\n\n});\n</code></pre><ul>\n<li>ES6</li>\n</ul>\n<pre><code>//  ...\n\nclass Comp extends Component {\n\n    constructor(props) {\n        super(props);\n\n        this.handleClick = this._handleClick.bind(this);\n    }\n\n    _handleClick() {\n        //  事件的处理逻辑\n    }\n\n    render() {\n        const {handleClick} = this;\n        return  (\n            &lt;button onClick={handleClick}&gt;click&lt;/button&gt;\n        );\n    }\n}\n</code></pre><p>刚才是在JSX语法上绑定的事件，如果不用JSX，我们就需要换成下面的绑定方法:</p>\n<pre><code>React.DOM.button({\n    &quot;className&quot;:&quot;btn-click&quot;,\n    &quot;onClick&quot;:this.handleClick\n},&quot;click&quot;);\n\n//  从React 0.12.x版本开始，推荐使用React.createElement的写法\n</code></pre><p>此外，如果需要支持移动端触碰事件，建议加上下面的代码:</p>\n<pre><code>React.initializeTouchEvents(true);\n</code></pre><h4 id=\"事件和状态\"><a href=\"#事件和状态\" class=\"headerlink\" title=\"事件和状态\"></a>事件和状态</h4><p>如果想让一个组件随着用户的输入而改变，我们就要在事件处理函数中对这个组件的某些状态进行修改。</p>\n<p>比如我们下面讲完成一个类似于angularJs中双向数据绑定的效果。</p>\n<pre><code>var Component = React.createClass({\n  handleChange: function(ev) {\n    this.setState({\n        value:ev.target.value\n    });\n  },\n  render: function() {\n    var value = this.state.value;\n    return (\n      &lt;div&gt;\n        &lt;input type=&quot;text&quot; onChange={this.handleChange} /&gt;\n        &lt;span&gt;{value}&lt;/span&gt;\n      &lt;/div&gt;\n    );\n  }\n});\n\nReactDOM.render(\n  &lt;Component /&gt;,\n  document.getElementById(&quot;div&quot;)\n);\n</code></pre><p>此时我们的输入会在两个地方显示，一个是在输入框里面，一个在输入框后面，且值都相同。</p>\n<h4 id=\"更新组件的状态\"><a href=\"#更新组件的状态\" class=\"headerlink\" title=\"更新组件的状态\"></a>更新组件的状态</h4><p>更新状态完成之后组件会调用render方法进行重绘。</p>\n<p>在React中，有两种更新组件状态的方法，一种是调用this.setState，一种是调用this.replaceState，第一种只是重新设置组件的状态，第二种会把组件原来所以的状态清除，然后用一个全新的对象来替换组件当前的状态对象，这种用起来一定要小心，因为如果替换的对象少了一个属性值或者属性值类型不同而render方法就正好用到这个属性值，那render方法就不会往下继续走了，所以很少地方使用。大多情况还是使用第一种this.setState来修改组件的状态。</p>\n","excerpt":"","more":"<p>对于用户界面来说，展示最多只占整体因素的一半，另一半则是用户输入，即通过javaScript来完成人机交互。</p>\n<p>在React中，通过将事件绑定到组件上到形式来对事件进行处理。在触发事件的同时，相关处理函数对组件对状态进行修改，再调用render方法重绘，达到响应用户输入的目的。</p>\n<h4 id=\"绑定事件处理器\"><a href=\"#绑定事件处理器\" class=\"headerlink\" title=\"绑定事件处理器\"></a>绑定事件处理器</h4><p>React的事件本质上和原生的javaScript类似，比如MouseEvent用来处理用户鼠标点击，Change用来处理表单元素的变化等，所有事件在命名上和JavaScript规范一致，并且会在相同的情况下被触发。</p>\n<p>React绑定事件的写法和在HTML上绑定事件的写法很像，比如我们下面将绑定一个click事件:</p>\n<pre><code>...\nhandleClick:function(){\n    ...\n},\nrender:function(){\n    return (\n        &lt;button onClick={this.handleClick}&gt;click&lt;/button&gt;\n    );\n},\n...\n</code></pre><p>这样，我们就完成了一个click事件的绑定，当用户点击这个按钮，handleClick将被调用，完成一些逻辑。</p>\n<p>就拿刚才上面的代码举例,我们在handleClick中用this,此时发现this指向了window对象,所以如果要在里面读取state/prop就比较麻烦,这时可以通过ES5中的bind方法来修改this的指向,就像下面这样:</p>\n<pre><code>...\nhandleClick: function(){\n    //  ...\n},\nrender: function(){\n    return (\n        &lt;button onClick={this.handleClick.bind(this, [....argus])}&gt;click&lt;/button&gt;\n    );\n},\n...\n</code></pre><p>后面还可以传入参数,还可以在getInitialState(或者ES6语法的constructor里)手动指定一个新属性,来达到修改this指向的目的:</p>\n<ul>\n<li>ES5</li>\n</ul>\n<pre><code>//  ...\n\nvar Comp = React.createClass({\n\n    getInitialState: function() {\n        this.handleClick = this._handleClick.bind(this);\n    },\n\n    _handleClick: function() {\n        //  事件的处理逻辑\n    },\n\n    render: function() {\n        return (\n            &lt;button onClick={this.handleClick}&gt;click&lt;/button&gt;\n        );\n    }\n\n});\n</code></pre><ul>\n<li>ES6</li>\n</ul>\n<pre><code>//  ...\n\nclass Comp extends Component {\n\n    constructor(props) {\n        super(props);\n\n        this.handleClick = this._handleClick.bind(this);\n    }\n\n    _handleClick() {\n        //  事件的处理逻辑\n    }\n\n    render() {\n        const {handleClick} = this;\n        return  (\n            &lt;button onClick={handleClick}&gt;click&lt;/button&gt;\n        );\n    }\n}\n</code></pre><p>刚才是在JSX语法上绑定的事件，如果不用JSX，我们就需要换成下面的绑定方法:</p>\n<pre><code>React.DOM.button({\n    &quot;className&quot;:&quot;btn-click&quot;,\n    &quot;onClick&quot;:this.handleClick\n},&quot;click&quot;);\n\n//  从React 0.12.x版本开始，推荐使用React.createElement的写法\n</code></pre><p>此外，如果需要支持移动端触碰事件，建议加上下面的代码:</p>\n<pre><code>React.initializeTouchEvents(true);\n</code></pre><h4 id=\"事件和状态\"><a href=\"#事件和状态\" class=\"headerlink\" title=\"事件和状态\"></a>事件和状态</h4><p>如果想让一个组件随着用户的输入而改变，我们就要在事件处理函数中对这个组件的某些状态进行修改。</p>\n<p>比如我们下面讲完成一个类似于angularJs中双向数据绑定的效果。</p>\n<pre><code>var Component = React.createClass({\n  handleChange: function(ev) {\n    this.setState({\n        value:ev.target.value\n    });\n  },\n  render: function() {\n    var value = this.state.value;\n    return (\n      &lt;div&gt;\n        &lt;input type=&quot;text&quot; onChange={this.handleChange} /&gt;\n        &lt;span&gt;{value}&lt;/span&gt;\n      &lt;/div&gt;\n    );\n  }\n});\n\nReactDOM.render(\n  &lt;Component /&gt;,\n  document.getElementById(&quot;div&quot;)\n);\n</code></pre><p>此时我们的输入会在两个地方显示，一个是在输入框里面，一个在输入框后面，且值都相同。</p>\n<h4 id=\"更新组件的状态\"><a href=\"#更新组件的状态\" class=\"headerlink\" title=\"更新组件的状态\"></a>更新组件的状态</h4><p>更新状态完成之后组件会调用render方法进行重绘。</p>\n<p>在React中，有两种更新组件状态的方法，一种是调用this.setState，一种是调用this.replaceState，第一种只是重新设置组件的状态，第二种会把组件原来所以的状态清除，然后用一个全新的对象来替换组件当前的状态对象，这种用起来一定要小心，因为如果替换的对象少了一个属性值或者属性值类型不同而render方法就正好用到这个属性值，那render方法就不会往下继续走了，所以很少地方使用。大多情况还是使用第一种this.setState来修改组件的状态。</p>\n"},{"layout":"post","title":"React组件的复合和mixin","date":"2015-12-03T16:00:00.000Z","_content":"\n在传统的HTML中，元素是构成页面的基础单元。但在React中，组件是构建页面的基础单元。我们可以把React中的组件理解成混入了javaScript表达能力的HTML元素。在React中，一个组件就相当于一个javaScript函数，它接收props和state作为参数，并且输入渲染好的DOM，组件的意义在于用来呈现和表达应用中的某一部分数据。\n\n#### 组件的复合\n\n我们都知道，在React中声明一个组件用React.createClass的方法，但是React并没有给我们提供一个叫React.extendClass的方法让我们来拓展或继承已经声明好的组件。我们可以通过组件复合的方法来构造一个新的组件。\n\n下面是一个组件复用的例子：\n\n我们现在要渲染一个选择题组件MultipeChoice，包含多个选项RadioInput。\n\n\n> ##### 选项组件\n\n先来组装HTML：\n\n    var RadioInput = React.createClass({\n        render:function(){\n            return (\n                <div className=\"redio\">\n                    <label>\n                        <input type=\"radio\" value=\"1\" />\n                        选项说明\n                    </label>\n                </div>\n            );\n        }\n    });\n    \n现在一个选项的HTML就组件完成了，但是现在内容和选项的值都是写死的，所以我们需要给这个组件添加一些属性，下面继续完善这个组件：\n\n    var RadioInput = React.createClass({\n        \n        //  propTypes给组件增加一个说明,标明每个prop属性的类型和是否必填\n        propTypes:{\n            id:React.PropTypes.string,\n            name:React.PropTypes.string.isRequired,\n            label:React.PropTypes.string.isRequired,\n            value:React.PropTypes.string.isRequired,\n            checkd:React.PropTypes.bool\n        },\n        \n        //  getDefauleProps可以给一些非必填属性指定默认值\n        getDefauleProps:function(){\n            return {\n                id:null,\n                checked:false\n            };\n        }\n    });\n    \n现在组件有了相应的props了，我们的组件需要随着时间而变化的数据，id对于每个实例来说相当重要，以及用户能随时更新的checked值，现在需要定义一些初始状态。\n\n    var RadioInput = React.createClass({\n        ...\n        getInitialState:function(){\n            var id = this.props.id || (new Date().getTime()).toString(32);\n            //  如果没传id,就拿当前时间戳生成一个\n            return {\n                id:id,\n                name:id,\n                checked:!!this.state.checked\n                //  强转成布尔值\n            };\n        },\n        \n        //  修改render方法,根据state和props重新组装HTML\n        render:function(){\n            return (\n                <div className=\"redio\">\n                    <label>\n                        <input type=\"radio\" \n                            id={this.state.id}\n                            name={this.state.name}\n                            value={this.props.value}\n                            checked={this.state.checked}\n                        />\n                        {this.props.label}\n                    </label>\n                </div>\n            );\n        }\n    });\n    \n到此，就算完成一个选项组件的构建。\n\n> ##### 父组件的构建及整合到父组件\n\n现在来构建父组件MultipeChoice\n\n    var MultipeChoice = React.createClass({\n        \n        //  指定一些数据类型和必须性\n        propTypes:{\n            value:React.PropTypes.string,\n            choices:React.PropTypes.array.isRequired,\n            onCompleted:React.PropTypes.func.isRequired\n        },\n        \n        getInitialState:function(){\n            return {\n                id:uniqueId(\"mutil-choice-\"),\n                value:this.props.value\n            };\n        },\n        \n        render:function(){\n            return (\n                <div className=\"form-group\">\n                    <label className=\"item-label\" htmlFor={this.state.id}>\n                        {this.props.label}\n                    </label>\n                    <div className=\"item-content\">\n                        <RadioInput ... />\n                        ...\n                        <RadioInput ... />\n                    </div>\n                </div>\n            );\n        }\n    });\n    \n我们假设一个RadioInput就是一个选项组件，为了生成他们，我们需要对选项列表进行映射，把每一项都转换成一个组件。\n\n    var MultipeChoice = React.createClass({\n        ...\n        \n        //  遍历属性中的choices数组,返回选项列表\n        renderChoices:function(){\n            return this.props.choices.map(function(item,index){\n                return RadioInput({\n                    id:\"choice-\" + index,\n                    name:this.state.id,\n                    label:choice,\n                    value:choice,\n                    checked:this.state.value === choice\n                });\n            }).bind(this);\n        },\n        \n        render:function(){\n            return (\n                <div className=\"form-group\">\n                    <label className=\"item-label\" htmlFor={this.state.id}>\n                        {this.props.label}\n                    </label>\n                    <div className=\"item-content\">\n                        {this.renderChoices()}\n                    </div>\n                </div>\n            );\n        }\n    });\n    \n现在使用这个组件就可以像下面这样：\n\n    <MultipeChoice choice={arrOfChoices} ... />\n    \n现在又有另外一个问题，就是父子组件之间怎么通信的一个问题，放在我们现在的例子来说，子组件状态变化以后父组件不知道。\n\n> ##### 父子组件之间的关系\n\n父子组件通信最简单的方式就是使用props，父组件通过props传递一个回调方法，子组件在需要时进行调用。\n\n现在我们继续改造...\n\n先来对父组件进行改造：\n\n    var MultipeChoice = React.createClass({\n        ...\n        \n        //  定义的handleChanged回调方法，供子组件状态变化后调用\n        handleChanged:function(value){\n            this.setState({\n                value:value\n            });\n            this.props.onCompleted(value);\n        },\n        \n        renderChoices:function(){\n            return this.props.choices.map(function(item,index){\n                return RadioInput({\n                    ...\n                    onChanged:this.handleChanged\n                });\n            }).bind(this);\n        },\n        \n        ...\n    });\n    \n再来对子组件进行改造：\n\n    var RadioInput = React.createClass({\n        ...\n        \n        propTypes:{\n            ...\n            onChanged:React.PropTypes.bool\n        },\n        \n        getInitialState:function(){\n            var id = this.props.id || (new Date().getTime()).toString(32);\n            //  如果没传id,就拿当前时间戳生成一个\n            return {\n                id:id,\n                name:id,\n                checked:!!this.state.checked\n                //  强转成布尔值\n            };\n        },\n        \n        handleChanged:function(ev){\n            var checked = ev.target.checked;\n            this.setState({\n                checked:checked\n            });\n            if(checked){\n                this.props.onChanged(this.props.value);\n            }\n        },\n        \n        //  修改render方法,根据state和props重新组装HTML\n        render:function(){\n            return (\n                <div className=\"redio\">\n                    <label htmlFor={this.state.id}>\n                        <input type=\"radio\" \n                        onChange={this.handleChanged}\n                        />\n                        {this.props.label}\n                    </label>\n                </div>\n            );\n        }\n    });\n    \n以上就是我们一个组件复合的例子。\n    \n#### mixin\n\nmixin允许我们定义可以在多个组件中公用的方法。\n\n> ##### 什么是mixin\n\n我们先来看一个来自React主页上的定时器组件的例子：\n\n    var Timer = React.createClass({\n        getInitialState:function(){\n            return {\n                secondElapsed:0\n            };\n        },\n        tick:function(){\n            this.setState({\n                secondElapsed:this.state.secondElapsed + 1\n            });\n        },\n        componentWillUnmount:function(){\n            clearInterval(this.interval);\n        },\n        componentDidMount:function(){\n            this.interval = setInterval(this.tick,1000);\n        },\n        render:function(){\n            return (\n                <div>\n                    second Elapsed:{this.state.secondElapsed}\n                </div>\n            );\n        }\n    });\n    \n上面的代码看起来还不错，但是如果我们有多个组件要用定时器时，这时候就体现出一个代码复用性的问题，这时候就到mixin大显神威的时候了。现在来改造一个像下面一样的定时器组件：\n\n    var IntervalMixin = function(interval){\n        return {\n            componentDidMount:function(){\n                this._interval = setInterval(this.onTick,interval);\n            },\n            componentWillUnmount:function(){\n                clearInterval(this._interval);\n            }\n        };\n    };\n    \n    var Timer = React.createClass({\n        mixins:[\n            IntervalMixin(1000)\n        ],\n        getInitialState:function(){\n            return {\n                secondElapsed:0\n            };\n        },\n        onTick:function(){\n            this.setState({\n                secondElapsed:this.state.secondElapsed + 1\n            });\n        },\n        render:function(){\n            return (\n                <div>\n                    second Elapsed:{this.state.secondElapsed}\n                </div>\n            );\n        }\n    });\n    \n把刚才的改进了，并且可以传入相关的时间间隔\n    \nmixin，可以理解成就是把一个 mixin 对象上的方法都混合到了另一个组件上，和 jQuery中$.extend 方法的作用相同。\n\nmixin和组件中有关生命周期的方法是不冲突的，反而会被合并，也就是说他们都会被执行。\n\n    var Component = React.createClass({\n        mixins:[\n            {\n                getInitialState:function(){\n                    return {a:1};\n                }\n            }\n        ],\n        getInitialState:function(){\n            return {b:2};\n        }\n    });\n\n就上上面的例子，我们在mixin中实现了一个getInitialState，同样在组件类中也实现了一个getInitialState，得到的初始state为{a:1,b:2}，如果组件类中的方法和mixin中的方法返回对象中有相同的键，React会给出一个警告。\n\n> ##### mixin的相关执行顺序和作用\n\n以组件中的生命周期方法为例，比如componentDidMount，会按照mixin数组中的顺序进行调用，并且最终调用组件类中的componentDisMount。\n\nmixin是解决代码复用性最强大的工具之一，它能让我们只专注组件自身的逻辑。","source":"_posts/2015-12-04-react-component-mixin.md","raw":"---\nlayout: post\ntitle: React组件的复合和mixin\ndate: 2015-12-04\ncategories: [React]\n---\n\n在传统的HTML中，元素是构成页面的基础单元。但在React中，组件是构建页面的基础单元。我们可以把React中的组件理解成混入了javaScript表达能力的HTML元素。在React中，一个组件就相当于一个javaScript函数，它接收props和state作为参数，并且输入渲染好的DOM，组件的意义在于用来呈现和表达应用中的某一部分数据。\n\n#### 组件的复合\n\n我们都知道，在React中声明一个组件用React.createClass的方法，但是React并没有给我们提供一个叫React.extendClass的方法让我们来拓展或继承已经声明好的组件。我们可以通过组件复合的方法来构造一个新的组件。\n\n下面是一个组件复用的例子：\n\n我们现在要渲染一个选择题组件MultipeChoice，包含多个选项RadioInput。\n\n\n> ##### 选项组件\n\n先来组装HTML：\n\n    var RadioInput = React.createClass({\n        render:function(){\n            return (\n                <div className=\"redio\">\n                    <label>\n                        <input type=\"radio\" value=\"1\" />\n                        选项说明\n                    </label>\n                </div>\n            );\n        }\n    });\n    \n现在一个选项的HTML就组件完成了，但是现在内容和选项的值都是写死的，所以我们需要给这个组件添加一些属性，下面继续完善这个组件：\n\n    var RadioInput = React.createClass({\n        \n        //  propTypes给组件增加一个说明,标明每个prop属性的类型和是否必填\n        propTypes:{\n            id:React.PropTypes.string,\n            name:React.PropTypes.string.isRequired,\n            label:React.PropTypes.string.isRequired,\n            value:React.PropTypes.string.isRequired,\n            checkd:React.PropTypes.bool\n        },\n        \n        //  getDefauleProps可以给一些非必填属性指定默认值\n        getDefauleProps:function(){\n            return {\n                id:null,\n                checked:false\n            };\n        }\n    });\n    \n现在组件有了相应的props了，我们的组件需要随着时间而变化的数据，id对于每个实例来说相当重要，以及用户能随时更新的checked值，现在需要定义一些初始状态。\n\n    var RadioInput = React.createClass({\n        ...\n        getInitialState:function(){\n            var id = this.props.id || (new Date().getTime()).toString(32);\n            //  如果没传id,就拿当前时间戳生成一个\n            return {\n                id:id,\n                name:id,\n                checked:!!this.state.checked\n                //  强转成布尔值\n            };\n        },\n        \n        //  修改render方法,根据state和props重新组装HTML\n        render:function(){\n            return (\n                <div className=\"redio\">\n                    <label>\n                        <input type=\"radio\" \n                            id={this.state.id}\n                            name={this.state.name}\n                            value={this.props.value}\n                            checked={this.state.checked}\n                        />\n                        {this.props.label}\n                    </label>\n                </div>\n            );\n        }\n    });\n    \n到此，就算完成一个选项组件的构建。\n\n> ##### 父组件的构建及整合到父组件\n\n现在来构建父组件MultipeChoice\n\n    var MultipeChoice = React.createClass({\n        \n        //  指定一些数据类型和必须性\n        propTypes:{\n            value:React.PropTypes.string,\n            choices:React.PropTypes.array.isRequired,\n            onCompleted:React.PropTypes.func.isRequired\n        },\n        \n        getInitialState:function(){\n            return {\n                id:uniqueId(\"mutil-choice-\"),\n                value:this.props.value\n            };\n        },\n        \n        render:function(){\n            return (\n                <div className=\"form-group\">\n                    <label className=\"item-label\" htmlFor={this.state.id}>\n                        {this.props.label}\n                    </label>\n                    <div className=\"item-content\">\n                        <RadioInput ... />\n                        ...\n                        <RadioInput ... />\n                    </div>\n                </div>\n            );\n        }\n    });\n    \n我们假设一个RadioInput就是一个选项组件，为了生成他们，我们需要对选项列表进行映射，把每一项都转换成一个组件。\n\n    var MultipeChoice = React.createClass({\n        ...\n        \n        //  遍历属性中的choices数组,返回选项列表\n        renderChoices:function(){\n            return this.props.choices.map(function(item,index){\n                return RadioInput({\n                    id:\"choice-\" + index,\n                    name:this.state.id,\n                    label:choice,\n                    value:choice,\n                    checked:this.state.value === choice\n                });\n            }).bind(this);\n        },\n        \n        render:function(){\n            return (\n                <div className=\"form-group\">\n                    <label className=\"item-label\" htmlFor={this.state.id}>\n                        {this.props.label}\n                    </label>\n                    <div className=\"item-content\">\n                        {this.renderChoices()}\n                    </div>\n                </div>\n            );\n        }\n    });\n    \n现在使用这个组件就可以像下面这样：\n\n    <MultipeChoice choice={arrOfChoices} ... />\n    \n现在又有另外一个问题，就是父子组件之间怎么通信的一个问题，放在我们现在的例子来说，子组件状态变化以后父组件不知道。\n\n> ##### 父子组件之间的关系\n\n父子组件通信最简单的方式就是使用props，父组件通过props传递一个回调方法，子组件在需要时进行调用。\n\n现在我们继续改造...\n\n先来对父组件进行改造：\n\n    var MultipeChoice = React.createClass({\n        ...\n        \n        //  定义的handleChanged回调方法，供子组件状态变化后调用\n        handleChanged:function(value){\n            this.setState({\n                value:value\n            });\n            this.props.onCompleted(value);\n        },\n        \n        renderChoices:function(){\n            return this.props.choices.map(function(item,index){\n                return RadioInput({\n                    ...\n                    onChanged:this.handleChanged\n                });\n            }).bind(this);\n        },\n        \n        ...\n    });\n    \n再来对子组件进行改造：\n\n    var RadioInput = React.createClass({\n        ...\n        \n        propTypes:{\n            ...\n            onChanged:React.PropTypes.bool\n        },\n        \n        getInitialState:function(){\n            var id = this.props.id || (new Date().getTime()).toString(32);\n            //  如果没传id,就拿当前时间戳生成一个\n            return {\n                id:id,\n                name:id,\n                checked:!!this.state.checked\n                //  强转成布尔值\n            };\n        },\n        \n        handleChanged:function(ev){\n            var checked = ev.target.checked;\n            this.setState({\n                checked:checked\n            });\n            if(checked){\n                this.props.onChanged(this.props.value);\n            }\n        },\n        \n        //  修改render方法,根据state和props重新组装HTML\n        render:function(){\n            return (\n                <div className=\"redio\">\n                    <label htmlFor={this.state.id}>\n                        <input type=\"radio\" \n                        onChange={this.handleChanged}\n                        />\n                        {this.props.label}\n                    </label>\n                </div>\n            );\n        }\n    });\n    \n以上就是我们一个组件复合的例子。\n    \n#### mixin\n\nmixin允许我们定义可以在多个组件中公用的方法。\n\n> ##### 什么是mixin\n\n我们先来看一个来自React主页上的定时器组件的例子：\n\n    var Timer = React.createClass({\n        getInitialState:function(){\n            return {\n                secondElapsed:0\n            };\n        },\n        tick:function(){\n            this.setState({\n                secondElapsed:this.state.secondElapsed + 1\n            });\n        },\n        componentWillUnmount:function(){\n            clearInterval(this.interval);\n        },\n        componentDidMount:function(){\n            this.interval = setInterval(this.tick,1000);\n        },\n        render:function(){\n            return (\n                <div>\n                    second Elapsed:{this.state.secondElapsed}\n                </div>\n            );\n        }\n    });\n    \n上面的代码看起来还不错，但是如果我们有多个组件要用定时器时，这时候就体现出一个代码复用性的问题，这时候就到mixin大显神威的时候了。现在来改造一个像下面一样的定时器组件：\n\n    var IntervalMixin = function(interval){\n        return {\n            componentDidMount:function(){\n                this._interval = setInterval(this.onTick,interval);\n            },\n            componentWillUnmount:function(){\n                clearInterval(this._interval);\n            }\n        };\n    };\n    \n    var Timer = React.createClass({\n        mixins:[\n            IntervalMixin(1000)\n        ],\n        getInitialState:function(){\n            return {\n                secondElapsed:0\n            };\n        },\n        onTick:function(){\n            this.setState({\n                secondElapsed:this.state.secondElapsed + 1\n            });\n        },\n        render:function(){\n            return (\n                <div>\n                    second Elapsed:{this.state.secondElapsed}\n                </div>\n            );\n        }\n    });\n    \n把刚才的改进了，并且可以传入相关的时间间隔\n    \nmixin，可以理解成就是把一个 mixin 对象上的方法都混合到了另一个组件上，和 jQuery中$.extend 方法的作用相同。\n\nmixin和组件中有关生命周期的方法是不冲突的，反而会被合并，也就是说他们都会被执行。\n\n    var Component = React.createClass({\n        mixins:[\n            {\n                getInitialState:function(){\n                    return {a:1};\n                }\n            }\n        ],\n        getInitialState:function(){\n            return {b:2};\n        }\n    });\n\n就上上面的例子，我们在mixin中实现了一个getInitialState，同样在组件类中也实现了一个getInitialState，得到的初始state为{a:1,b:2}，如果组件类中的方法和mixin中的方法返回对象中有相同的键，React会给出一个警告。\n\n> ##### mixin的相关执行顺序和作用\n\n以组件中的生命周期方法为例，比如componentDidMount，会按照mixin数组中的顺序进行调用，并且最终调用组件类中的componentDisMount。\n\nmixin是解决代码复用性最强大的工具之一，它能让我们只专注组件自身的逻辑。","slug":"2015-12-04-react-component-mixin","published":1,"updated":"2016-09-27T04:11:57.000Z","comments":1,"photos":[],"link":"","_id":"civ7fsefb0016t95fogjxoimi","content":"<p>在传统的HTML中，元素是构成页面的基础单元。但在React中，组件是构建页面的基础单元。我们可以把React中的组件理解成混入了javaScript表达能力的HTML元素。在React中，一个组件就相当于一个javaScript函数，它接收props和state作为参数，并且输入渲染好的DOM，组件的意义在于用来呈现和表达应用中的某一部分数据。</p>\n<h4 id=\"组件的复合\"><a href=\"#组件的复合\" class=\"headerlink\" title=\"组件的复合\"></a>组件的复合</h4><p>我们都知道，在React中声明一个组件用React.createClass的方法，但是React并没有给我们提供一个叫React.extendClass的方法让我们来拓展或继承已经声明好的组件。我们可以通过组件复合的方法来构造一个新的组件。</p>\n<p>下面是一个组件复用的例子：</p>\n<p>我们现在要渲染一个选择题组件MultipeChoice，包含多个选项RadioInput。</p>\n<blockquote>\n<h5 id=\"选项组件\"><a href=\"#选项组件\" class=\"headerlink\" title=\"选项组件\"></a>选项组件</h5></blockquote>\n<p>先来组装HTML：</p>\n<pre><code>var RadioInput = React.createClass({\n    render:function(){\n        return (\n            &lt;div className=&quot;redio&quot;&gt;\n                &lt;label&gt;\n                    &lt;input type=&quot;radio&quot; value=&quot;1&quot; /&gt;\n                    选项说明\n                &lt;/label&gt;\n            &lt;/div&gt;\n        );\n    }\n});\n</code></pre><p>现在一个选项的HTML就组件完成了，但是现在内容和选项的值都是写死的，所以我们需要给这个组件添加一些属性，下面继续完善这个组件：</p>\n<pre><code>var RadioInput = React.createClass({\n\n    //  propTypes给组件增加一个说明,标明每个prop属性的类型和是否必填\n    propTypes:{\n        id:React.PropTypes.string,\n        name:React.PropTypes.string.isRequired,\n        label:React.PropTypes.string.isRequired,\n        value:React.PropTypes.string.isRequired,\n        checkd:React.PropTypes.bool\n    },\n\n    //  getDefauleProps可以给一些非必填属性指定默认值\n    getDefauleProps:function(){\n        return {\n            id:null,\n            checked:false\n        };\n    }\n});\n</code></pre><p>现在组件有了相应的props了，我们的组件需要随着时间而变化的数据，id对于每个实例来说相当重要，以及用户能随时更新的checked值，现在需要定义一些初始状态。</p>\n<pre><code>var RadioInput = React.createClass({\n    ...\n    getInitialState:function(){\n        var id = this.props.id || (new Date().getTime()).toString(32);\n        //  如果没传id,就拿当前时间戳生成一个\n        return {\n            id:id,\n            name:id,\n            checked:!!this.state.checked\n            //  强转成布尔值\n        };\n    },\n\n    //  修改render方法,根据state和props重新组装HTML\n    render:function(){\n        return (\n            &lt;div className=&quot;redio&quot;&gt;\n                &lt;label&gt;\n                    &lt;input type=&quot;radio&quot; \n                        id={this.state.id}\n                        name={this.state.name}\n                        value={this.props.value}\n                        checked={this.state.checked}\n                    /&gt;\n                    {this.props.label}\n                &lt;/label&gt;\n            &lt;/div&gt;\n        );\n    }\n});\n</code></pre><p>到此，就算完成一个选项组件的构建。</p>\n<blockquote>\n<h5 id=\"父组件的构建及整合到父组件\"><a href=\"#父组件的构建及整合到父组件\" class=\"headerlink\" title=\"父组件的构建及整合到父组件\"></a>父组件的构建及整合到父组件</h5></blockquote>\n<p>现在来构建父组件MultipeChoice</p>\n<pre><code>var MultipeChoice = React.createClass({\n\n    //  指定一些数据类型和必须性\n    propTypes:{\n        value:React.PropTypes.string,\n        choices:React.PropTypes.array.isRequired,\n        onCompleted:React.PropTypes.func.isRequired\n    },\n\n    getInitialState:function(){\n        return {\n            id:uniqueId(&quot;mutil-choice-&quot;),\n            value:this.props.value\n        };\n    },\n\n    render:function(){\n        return (\n            &lt;div className=&quot;form-group&quot;&gt;\n                &lt;label className=&quot;item-label&quot; htmlFor={this.state.id}&gt;\n                    {this.props.label}\n                &lt;/label&gt;\n                &lt;div className=&quot;item-content&quot;&gt;\n                    &lt;RadioInput ... /&gt;\n                    ...\n                    &lt;RadioInput ... /&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n        );\n    }\n});\n</code></pre><p>我们假设一个RadioInput就是一个选项组件，为了生成他们，我们需要对选项列表进行映射，把每一项都转换成一个组件。</p>\n<pre><code>var MultipeChoice = React.createClass({\n    ...\n\n    //  遍历属性中的choices数组,返回选项列表\n    renderChoices:function(){\n        return this.props.choices.map(function(item,index){\n            return RadioInput({\n                id:&quot;choice-&quot; + index,\n                name:this.state.id,\n                label:choice,\n                value:choice,\n                checked:this.state.value === choice\n            });\n        }).bind(this);\n    },\n\n    render:function(){\n        return (\n            &lt;div className=&quot;form-group&quot;&gt;\n                &lt;label className=&quot;item-label&quot; htmlFor={this.state.id}&gt;\n                    {this.props.label}\n                &lt;/label&gt;\n                &lt;div className=&quot;item-content&quot;&gt;\n                    {this.renderChoices()}\n                &lt;/div&gt;\n            &lt;/div&gt;\n        );\n    }\n});\n</code></pre><p>现在使用这个组件就可以像下面这样：</p>\n<pre><code>&lt;MultipeChoice choice={arrOfChoices} ... /&gt;\n</code></pre><p>现在又有另外一个问题，就是父子组件之间怎么通信的一个问题，放在我们现在的例子来说，子组件状态变化以后父组件不知道。</p>\n<blockquote>\n<h5 id=\"父子组件之间的关系\"><a href=\"#父子组件之间的关系\" class=\"headerlink\" title=\"父子组件之间的关系\"></a>父子组件之间的关系</h5></blockquote>\n<p>父子组件通信最简单的方式就是使用props，父组件通过props传递一个回调方法，子组件在需要时进行调用。</p>\n<p>现在我们继续改造…</p>\n<p>先来对父组件进行改造：</p>\n<pre><code>var MultipeChoice = React.createClass({\n    ...\n\n    //  定义的handleChanged回调方法，供子组件状态变化后调用\n    handleChanged:function(value){\n        this.setState({\n            value:value\n        });\n        this.props.onCompleted(value);\n    },\n\n    renderChoices:function(){\n        return this.props.choices.map(function(item,index){\n            return RadioInput({\n                ...\n                onChanged:this.handleChanged\n            });\n        }).bind(this);\n    },\n\n    ...\n});\n</code></pre><p>再来对子组件进行改造：</p>\n<pre><code>var RadioInput = React.createClass({\n    ...\n\n    propTypes:{\n        ...\n        onChanged:React.PropTypes.bool\n    },\n\n    getInitialState:function(){\n        var id = this.props.id || (new Date().getTime()).toString(32);\n        //  如果没传id,就拿当前时间戳生成一个\n        return {\n            id:id,\n            name:id,\n            checked:!!this.state.checked\n            //  强转成布尔值\n        };\n    },\n\n    handleChanged:function(ev){\n        var checked = ev.target.checked;\n        this.setState({\n            checked:checked\n        });\n        if(checked){\n            this.props.onChanged(this.props.value);\n        }\n    },\n\n    //  修改render方法,根据state和props重新组装HTML\n    render:function(){\n        return (\n            &lt;div className=&quot;redio&quot;&gt;\n                &lt;label htmlFor={this.state.id}&gt;\n                    &lt;input type=&quot;radio&quot; \n                    onChange={this.handleChanged}\n                    /&gt;\n                    {this.props.label}\n                &lt;/label&gt;\n            &lt;/div&gt;\n        );\n    }\n});\n</code></pre><p>以上就是我们一个组件复合的例子。</p>\n<h4 id=\"mixin\"><a href=\"#mixin\" class=\"headerlink\" title=\"mixin\"></a>mixin</h4><p>mixin允许我们定义可以在多个组件中公用的方法。</p>\n<blockquote>\n<h5 id=\"什么是mixin\"><a href=\"#什么是mixin\" class=\"headerlink\" title=\"什么是mixin\"></a>什么是mixin</h5></blockquote>\n<p>我们先来看一个来自React主页上的定时器组件的例子：</p>\n<pre><code>var Timer = React.createClass({\n    getInitialState:function(){\n        return {\n            secondElapsed:0\n        };\n    },\n    tick:function(){\n        this.setState({\n            secondElapsed:this.state.secondElapsed + 1\n        });\n    },\n    componentWillUnmount:function(){\n        clearInterval(this.interval);\n    },\n    componentDidMount:function(){\n        this.interval = setInterval(this.tick,1000);\n    },\n    render:function(){\n        return (\n            &lt;div&gt;\n                second Elapsed:{this.state.secondElapsed}\n            &lt;/div&gt;\n        );\n    }\n});\n</code></pre><p>上面的代码看起来还不错，但是如果我们有多个组件要用定时器时，这时候就体现出一个代码复用性的问题，这时候就到mixin大显神威的时候了。现在来改造一个像下面一样的定时器组件：</p>\n<pre><code>var IntervalMixin = function(interval){\n    return {\n        componentDidMount:function(){\n            this._interval = setInterval(this.onTick,interval);\n        },\n        componentWillUnmount:function(){\n            clearInterval(this._interval);\n        }\n    };\n};\n\nvar Timer = React.createClass({\n    mixins:[\n        IntervalMixin(1000)\n    ],\n    getInitialState:function(){\n        return {\n            secondElapsed:0\n        };\n    },\n    onTick:function(){\n        this.setState({\n            secondElapsed:this.state.secondElapsed + 1\n        });\n    },\n    render:function(){\n        return (\n            &lt;div&gt;\n                second Elapsed:{this.state.secondElapsed}\n            &lt;/div&gt;\n        );\n    }\n});\n</code></pre><p>把刚才的改进了，并且可以传入相关的时间间隔</p>\n<p>mixin，可以理解成就是把一个 mixin 对象上的方法都混合到了另一个组件上，和 jQuery中$.extend 方法的作用相同。</p>\n<p>mixin和组件中有关生命周期的方法是不冲突的，反而会被合并，也就是说他们都会被执行。</p>\n<pre><code>var Component = React.createClass({\n    mixins:[\n        {\n            getInitialState:function(){\n                return {a:1};\n            }\n        }\n    ],\n    getInitialState:function(){\n        return {b:2};\n    }\n});\n</code></pre><p>就上上面的例子，我们在mixin中实现了一个getInitialState，同样在组件类中也实现了一个getInitialState，得到的初始state为{a:1,b:2}，如果组件类中的方法和mixin中的方法返回对象中有相同的键，React会给出一个警告。</p>\n<blockquote>\n<h5 id=\"mixin的相关执行顺序和作用\"><a href=\"#mixin的相关执行顺序和作用\" class=\"headerlink\" title=\"mixin的相关执行顺序和作用\"></a>mixin的相关执行顺序和作用</h5></blockquote>\n<p>以组件中的生命周期方法为例，比如componentDidMount，会按照mixin数组中的顺序进行调用，并且最终调用组件类中的componentDisMount。</p>\n<p>mixin是解决代码复用性最强大的工具之一，它能让我们只专注组件自身的逻辑。</p>\n","excerpt":"","more":"<p>在传统的HTML中，元素是构成页面的基础单元。但在React中，组件是构建页面的基础单元。我们可以把React中的组件理解成混入了javaScript表达能力的HTML元素。在React中，一个组件就相当于一个javaScript函数，它接收props和state作为参数，并且输入渲染好的DOM，组件的意义在于用来呈现和表达应用中的某一部分数据。</p>\n<h4 id=\"组件的复合\"><a href=\"#组件的复合\" class=\"headerlink\" title=\"组件的复合\"></a>组件的复合</h4><p>我们都知道，在React中声明一个组件用React.createClass的方法，但是React并没有给我们提供一个叫React.extendClass的方法让我们来拓展或继承已经声明好的组件。我们可以通过组件复合的方法来构造一个新的组件。</p>\n<p>下面是一个组件复用的例子：</p>\n<p>我们现在要渲染一个选择题组件MultipeChoice，包含多个选项RadioInput。</p>\n<blockquote>\n<h5 id=\"选项组件\"><a href=\"#选项组件\" class=\"headerlink\" title=\"选项组件\"></a>选项组件</h5></blockquote>\n<p>先来组装HTML：</p>\n<pre><code>var RadioInput = React.createClass({\n    render:function(){\n        return (\n            &lt;div className=&quot;redio&quot;&gt;\n                &lt;label&gt;\n                    &lt;input type=&quot;radio&quot; value=&quot;1&quot; /&gt;\n                    选项说明\n                &lt;/label&gt;\n            &lt;/div&gt;\n        );\n    }\n});\n</code></pre><p>现在一个选项的HTML就组件完成了，但是现在内容和选项的值都是写死的，所以我们需要给这个组件添加一些属性，下面继续完善这个组件：</p>\n<pre><code>var RadioInput = React.createClass({\n\n    //  propTypes给组件增加一个说明,标明每个prop属性的类型和是否必填\n    propTypes:{\n        id:React.PropTypes.string,\n        name:React.PropTypes.string.isRequired,\n        label:React.PropTypes.string.isRequired,\n        value:React.PropTypes.string.isRequired,\n        checkd:React.PropTypes.bool\n    },\n\n    //  getDefauleProps可以给一些非必填属性指定默认值\n    getDefauleProps:function(){\n        return {\n            id:null,\n            checked:false\n        };\n    }\n});\n</code></pre><p>现在组件有了相应的props了，我们的组件需要随着时间而变化的数据，id对于每个实例来说相当重要，以及用户能随时更新的checked值，现在需要定义一些初始状态。</p>\n<pre><code>var RadioInput = React.createClass({\n    ...\n    getInitialState:function(){\n        var id = this.props.id || (new Date().getTime()).toString(32);\n        //  如果没传id,就拿当前时间戳生成一个\n        return {\n            id:id,\n            name:id,\n            checked:!!this.state.checked\n            //  强转成布尔值\n        };\n    },\n\n    //  修改render方法,根据state和props重新组装HTML\n    render:function(){\n        return (\n            &lt;div className=&quot;redio&quot;&gt;\n                &lt;label&gt;\n                    &lt;input type=&quot;radio&quot; \n                        id={this.state.id}\n                        name={this.state.name}\n                        value={this.props.value}\n                        checked={this.state.checked}\n                    /&gt;\n                    {this.props.label}\n                &lt;/label&gt;\n            &lt;/div&gt;\n        );\n    }\n});\n</code></pre><p>到此，就算完成一个选项组件的构建。</p>\n<blockquote>\n<h5 id=\"父组件的构建及整合到父组件\"><a href=\"#父组件的构建及整合到父组件\" class=\"headerlink\" title=\"父组件的构建及整合到父组件\"></a>父组件的构建及整合到父组件</h5></blockquote>\n<p>现在来构建父组件MultipeChoice</p>\n<pre><code>var MultipeChoice = React.createClass({\n\n    //  指定一些数据类型和必须性\n    propTypes:{\n        value:React.PropTypes.string,\n        choices:React.PropTypes.array.isRequired,\n        onCompleted:React.PropTypes.func.isRequired\n    },\n\n    getInitialState:function(){\n        return {\n            id:uniqueId(&quot;mutil-choice-&quot;),\n            value:this.props.value\n        };\n    },\n\n    render:function(){\n        return (\n            &lt;div className=&quot;form-group&quot;&gt;\n                &lt;label className=&quot;item-label&quot; htmlFor={this.state.id}&gt;\n                    {this.props.label}\n                &lt;/label&gt;\n                &lt;div className=&quot;item-content&quot;&gt;\n                    &lt;RadioInput ... /&gt;\n                    ...\n                    &lt;RadioInput ... /&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n        );\n    }\n});\n</code></pre><p>我们假设一个RadioInput就是一个选项组件，为了生成他们，我们需要对选项列表进行映射，把每一项都转换成一个组件。</p>\n<pre><code>var MultipeChoice = React.createClass({\n    ...\n\n    //  遍历属性中的choices数组,返回选项列表\n    renderChoices:function(){\n        return this.props.choices.map(function(item,index){\n            return RadioInput({\n                id:&quot;choice-&quot; + index,\n                name:this.state.id,\n                label:choice,\n                value:choice,\n                checked:this.state.value === choice\n            });\n        }).bind(this);\n    },\n\n    render:function(){\n        return (\n            &lt;div className=&quot;form-group&quot;&gt;\n                &lt;label className=&quot;item-label&quot; htmlFor={this.state.id}&gt;\n                    {this.props.label}\n                &lt;/label&gt;\n                &lt;div className=&quot;item-content&quot;&gt;\n                    {this.renderChoices()}\n                &lt;/div&gt;\n            &lt;/div&gt;\n        );\n    }\n});\n</code></pre><p>现在使用这个组件就可以像下面这样：</p>\n<pre><code>&lt;MultipeChoice choice={arrOfChoices} ... /&gt;\n</code></pre><p>现在又有另外一个问题，就是父子组件之间怎么通信的一个问题，放在我们现在的例子来说，子组件状态变化以后父组件不知道。</p>\n<blockquote>\n<h5 id=\"父子组件之间的关系\"><a href=\"#父子组件之间的关系\" class=\"headerlink\" title=\"父子组件之间的关系\"></a>父子组件之间的关系</h5></blockquote>\n<p>父子组件通信最简单的方式就是使用props，父组件通过props传递一个回调方法，子组件在需要时进行调用。</p>\n<p>现在我们继续改造…</p>\n<p>先来对父组件进行改造：</p>\n<pre><code>var MultipeChoice = React.createClass({\n    ...\n\n    //  定义的handleChanged回调方法，供子组件状态变化后调用\n    handleChanged:function(value){\n        this.setState({\n            value:value\n        });\n        this.props.onCompleted(value);\n    },\n\n    renderChoices:function(){\n        return this.props.choices.map(function(item,index){\n            return RadioInput({\n                ...\n                onChanged:this.handleChanged\n            });\n        }).bind(this);\n    },\n\n    ...\n});\n</code></pre><p>再来对子组件进行改造：</p>\n<pre><code>var RadioInput = React.createClass({\n    ...\n\n    propTypes:{\n        ...\n        onChanged:React.PropTypes.bool\n    },\n\n    getInitialState:function(){\n        var id = this.props.id || (new Date().getTime()).toString(32);\n        //  如果没传id,就拿当前时间戳生成一个\n        return {\n            id:id,\n            name:id,\n            checked:!!this.state.checked\n            //  强转成布尔值\n        };\n    },\n\n    handleChanged:function(ev){\n        var checked = ev.target.checked;\n        this.setState({\n            checked:checked\n        });\n        if(checked){\n            this.props.onChanged(this.props.value);\n        }\n    },\n\n    //  修改render方法,根据state和props重新组装HTML\n    render:function(){\n        return (\n            &lt;div className=&quot;redio&quot;&gt;\n                &lt;label htmlFor={this.state.id}&gt;\n                    &lt;input type=&quot;radio&quot; \n                    onChange={this.handleChanged}\n                    /&gt;\n                    {this.props.label}\n                &lt;/label&gt;\n            &lt;/div&gt;\n        );\n    }\n});\n</code></pre><p>以上就是我们一个组件复合的例子。</p>\n<h4 id=\"mixin\"><a href=\"#mixin\" class=\"headerlink\" title=\"mixin\"></a>mixin</h4><p>mixin允许我们定义可以在多个组件中公用的方法。</p>\n<blockquote>\n<h5 id=\"什么是mixin\"><a href=\"#什么是mixin\" class=\"headerlink\" title=\"什么是mixin\"></a>什么是mixin</h5></blockquote>\n<p>我们先来看一个来自React主页上的定时器组件的例子：</p>\n<pre><code>var Timer = React.createClass({\n    getInitialState:function(){\n        return {\n            secondElapsed:0\n        };\n    },\n    tick:function(){\n        this.setState({\n            secondElapsed:this.state.secondElapsed + 1\n        });\n    },\n    componentWillUnmount:function(){\n        clearInterval(this.interval);\n    },\n    componentDidMount:function(){\n        this.interval = setInterval(this.tick,1000);\n    },\n    render:function(){\n        return (\n            &lt;div&gt;\n                second Elapsed:{this.state.secondElapsed}\n            &lt;/div&gt;\n        );\n    }\n});\n</code></pre><p>上面的代码看起来还不错，但是如果我们有多个组件要用定时器时，这时候就体现出一个代码复用性的问题，这时候就到mixin大显神威的时候了。现在来改造一个像下面一样的定时器组件：</p>\n<pre><code>var IntervalMixin = function(interval){\n    return {\n        componentDidMount:function(){\n            this._interval = setInterval(this.onTick,interval);\n        },\n        componentWillUnmount:function(){\n            clearInterval(this._interval);\n        }\n    };\n};\n\nvar Timer = React.createClass({\n    mixins:[\n        IntervalMixin(1000)\n    ],\n    getInitialState:function(){\n        return {\n            secondElapsed:0\n        };\n    },\n    onTick:function(){\n        this.setState({\n            secondElapsed:this.state.secondElapsed + 1\n        });\n    },\n    render:function(){\n        return (\n            &lt;div&gt;\n                second Elapsed:{this.state.secondElapsed}\n            &lt;/div&gt;\n        );\n    }\n});\n</code></pre><p>把刚才的改进了，并且可以传入相关的时间间隔</p>\n<p>mixin，可以理解成就是把一个 mixin 对象上的方法都混合到了另一个组件上，和 jQuery中$.extend 方法的作用相同。</p>\n<p>mixin和组件中有关生命周期的方法是不冲突的，反而会被合并，也就是说他们都会被执行。</p>\n<pre><code>var Component = React.createClass({\n    mixins:[\n        {\n            getInitialState:function(){\n                return {a:1};\n            }\n        }\n    ],\n    getInitialState:function(){\n        return {b:2};\n    }\n});\n</code></pre><p>就上上面的例子，我们在mixin中实现了一个getInitialState，同样在组件类中也实现了一个getInitialState，得到的初始state为{a:1,b:2}，如果组件类中的方法和mixin中的方法返回对象中有相同的键，React会给出一个警告。</p>\n<blockquote>\n<h5 id=\"mixin的相关执行顺序和作用\"><a href=\"#mixin的相关执行顺序和作用\" class=\"headerlink\" title=\"mixin的相关执行顺序和作用\"></a>mixin的相关执行顺序和作用</h5></blockquote>\n<p>以组件中的生命周期方法为例，比如componentDidMount，会按照mixin数组中的顺序进行调用，并且最终调用组件类中的componentDisMount。</p>\n<p>mixin是解决代码复用性最强大的工具之一，它能让我们只专注组件自身的逻辑。</p>\n"},{"layout":"post","title":"React中的DOM操作","date":"2015-12-04T16:00:00.000Z","_content":"\n大多数情况下，React的虚拟DOM已经可以创建我们想要的用户体验，而根本不需要直接操作底层真实的DOM，通过组件的复合，把负责的交互聚合为呈现给用户的连贯整体。\n\n但是在某些情况下，比如与一个没有使用React的第三类库的整合，或者执行一个React没有原生支持的操作等等，我们就不得不去操作底层DOM来达到我们的目的。\n\n#### DOM操作\n\n> ##### 访问受控制的DOM节点\n\nReact提供了一个受其自身控制的方法，这些方法只有在生命周期的相关方法里才有效。我们可以给组件的相关元素添加一个ref属性来实现。\n\n    var CanvasComponent = React.createClass({\n        render:function(){\n            return (\n                <canvas ref=\"canvasEle\" />\n            );\n        }\n    });\n    \n这样就可以通过this.refs.canvasEle来访问到这个canvas节点了，需要注意的是这里的ref属性必须是唯一的，如果定义了相同的ref也是\"canvasEle\"，那么操作将无效。\n\n一旦访问到了该元素，那么就可以通过getDOMNode()方法来访问底层的DOM节点，需要注意的是，不要在render方法中尝试用该方法，因为在render方法执行完之前，组件还未挂载，该DOM节点不是最有效的，所以可能会报异常。\n\n所以要在组件被挂载后使用，比如componentDidMount或者一些用户操作后的事件处理函数，就像下面这样：\n\n    var CanvasComponent = React.createClass({\n        render:function(){\n            return (\n                <canvas ref=\"canvasEle\" />\n            );\n        },\n        \n        componentDidMount:function(){\n            var oCanvas = this.refs.canvasEle.getNode();\n            //  现在oCanvas就是我们的canvas节点，可以调用canvas下的相关方法来进行操作\n        }\n    }); \n\nReact的refs和getDOMNode很强大，但是使用它们可能会导致React在性能上的一些问题，所以我们不到在没有其他方式的时候，尽量不要用它们来解决问题。\n\n> #####整合非React类库\n\n很多成熟的javaScript类库并没有使用React构建，此时就需要我们自己来进行整合。\n\n比如现在要使用一个autocomplete插件，包含下面的基础代码：\n    \n    autocomplete({\n        target:document.getElementById(\"select\"),\n        data:[\n            \"option1\",\"option2\",\"option2\"\n        ],\n        events:{\n            select:function(item){\n                alert(\"你选择了\" + item);\n            }\n        }\n    });\n    \n这个类库需要一个DOM节点，一个数组，一个事件的相关对象，所以，这里就用到了DOM操作，刚才提到，在React中使用DOM操作要在组件挂载完成后或一些事件处理函数中完成。\n\n    var SelectComponent = React.createClass({\n        getDefaultProps:function(){\n            return {\n                data:[\n                        \"option1\",\"option2\",\"option2\"\n                    ]\n            };\n        },\n        render:function(){\n            return (\n                <div id=\"select\" ref=\"autoCompleteDOM\"></div>\n            );\n        },\n        handleSelect:function(item){\n            alert(\"你选择了\" + item);\n        },\n        componentDidMount:function(){\n            autocomplete({\n                target:this.refs.autoCompleteDOM.getDOMNode(),\n                data:this.props.data,\n                events:{\n                    select:this.handleSelect\n                }\n            });\n        }\n    });\n    \n现在把autocomplete引入到React中了，但是这样还不够，要知道，在这个组件被移除了怎么办，所以引入外部插件时一般需要注意在组件类中再实现一个componentWillUnmount的方法，这样在组件被移除，它会对自身进行清理，从而避免内存泄露等性能问题。\n\n> #####侵入式插件\n\n在整合非React类库的时候，我们希望整合的类库仅仅操作的是组件的子元素，但是有时并非如此，此时我们就需要把这些额外的操作在React中规避掉，防止出现DOM被意外修改的错误。处理这种问题，最有效的方法就是把DOM的操控权完全给我们自己，而不是给这些类库。\n\n","source":"_posts/2015-12-05-react-dom.md","raw":"---\nlayout: post\ntitle: React中的DOM操作\ndate: 2015-12-05\ncategories: [React]\n---\n\n大多数情况下，React的虚拟DOM已经可以创建我们想要的用户体验，而根本不需要直接操作底层真实的DOM，通过组件的复合，把负责的交互聚合为呈现给用户的连贯整体。\n\n但是在某些情况下，比如与一个没有使用React的第三类库的整合，或者执行一个React没有原生支持的操作等等，我们就不得不去操作底层DOM来达到我们的目的。\n\n#### DOM操作\n\n> ##### 访问受控制的DOM节点\n\nReact提供了一个受其自身控制的方法，这些方法只有在生命周期的相关方法里才有效。我们可以给组件的相关元素添加一个ref属性来实现。\n\n    var CanvasComponent = React.createClass({\n        render:function(){\n            return (\n                <canvas ref=\"canvasEle\" />\n            );\n        }\n    });\n    \n这样就可以通过this.refs.canvasEle来访问到这个canvas节点了，需要注意的是这里的ref属性必须是唯一的，如果定义了相同的ref也是\"canvasEle\"，那么操作将无效。\n\n一旦访问到了该元素，那么就可以通过getDOMNode()方法来访问底层的DOM节点，需要注意的是，不要在render方法中尝试用该方法，因为在render方法执行完之前，组件还未挂载，该DOM节点不是最有效的，所以可能会报异常。\n\n所以要在组件被挂载后使用，比如componentDidMount或者一些用户操作后的事件处理函数，就像下面这样：\n\n    var CanvasComponent = React.createClass({\n        render:function(){\n            return (\n                <canvas ref=\"canvasEle\" />\n            );\n        },\n        \n        componentDidMount:function(){\n            var oCanvas = this.refs.canvasEle.getNode();\n            //  现在oCanvas就是我们的canvas节点，可以调用canvas下的相关方法来进行操作\n        }\n    }); \n\nReact的refs和getDOMNode很强大，但是使用它们可能会导致React在性能上的一些问题，所以我们不到在没有其他方式的时候，尽量不要用它们来解决问题。\n\n> #####整合非React类库\n\n很多成熟的javaScript类库并没有使用React构建，此时就需要我们自己来进行整合。\n\n比如现在要使用一个autocomplete插件，包含下面的基础代码：\n    \n    autocomplete({\n        target:document.getElementById(\"select\"),\n        data:[\n            \"option1\",\"option2\",\"option2\"\n        ],\n        events:{\n            select:function(item){\n                alert(\"你选择了\" + item);\n            }\n        }\n    });\n    \n这个类库需要一个DOM节点，一个数组，一个事件的相关对象，所以，这里就用到了DOM操作，刚才提到，在React中使用DOM操作要在组件挂载完成后或一些事件处理函数中完成。\n\n    var SelectComponent = React.createClass({\n        getDefaultProps:function(){\n            return {\n                data:[\n                        \"option1\",\"option2\",\"option2\"\n                    ]\n            };\n        },\n        render:function(){\n            return (\n                <div id=\"select\" ref=\"autoCompleteDOM\"></div>\n            );\n        },\n        handleSelect:function(item){\n            alert(\"你选择了\" + item);\n        },\n        componentDidMount:function(){\n            autocomplete({\n                target:this.refs.autoCompleteDOM.getDOMNode(),\n                data:this.props.data,\n                events:{\n                    select:this.handleSelect\n                }\n            });\n        }\n    });\n    \n现在把autocomplete引入到React中了，但是这样还不够，要知道，在这个组件被移除了怎么办，所以引入外部插件时一般需要注意在组件类中再实现一个componentWillUnmount的方法，这样在组件被移除，它会对自身进行清理，从而避免内存泄露等性能问题。\n\n> #####侵入式插件\n\n在整合非React类库的时候，我们希望整合的类库仅仅操作的是组件的子元素，但是有时并非如此，此时我们就需要把这些额外的操作在React中规避掉，防止出现DOM被意外修改的错误。处理这种问题，最有效的方法就是把DOM的操控权完全给我们自己，而不是给这些类库。\n\n","slug":"2015-12-05-react-dom","published":1,"updated":"2016-09-27T04:12:04.000Z","comments":1,"photos":[],"link":"","_id":"civ7fsefd0018t95fbmp3ktpx","content":"<p>大多数情况下，React的虚拟DOM已经可以创建我们想要的用户体验，而根本不需要直接操作底层真实的DOM，通过组件的复合，把负责的交互聚合为呈现给用户的连贯整体。</p>\n<p>但是在某些情况下，比如与一个没有使用React的第三类库的整合，或者执行一个React没有原生支持的操作等等，我们就不得不去操作底层DOM来达到我们的目的。</p>\n<h4 id=\"DOM操作\"><a href=\"#DOM操作\" class=\"headerlink\" title=\"DOM操作\"></a>DOM操作</h4><blockquote>\n<h5 id=\"访问受控制的DOM节点\"><a href=\"#访问受控制的DOM节点\" class=\"headerlink\" title=\"访问受控制的DOM节点\"></a>访问受控制的DOM节点</h5></blockquote>\n<p>React提供了一个受其自身控制的方法，这些方法只有在生命周期的相关方法里才有效。我们可以给组件的相关元素添加一个ref属性来实现。</p>\n<pre><code>var CanvasComponent = React.createClass({\n    render:function(){\n        return (\n            &lt;canvas ref=&quot;canvasEle&quot; /&gt;\n        );\n    }\n});\n</code></pre><p>这样就可以通过this.refs.canvasEle来访问到这个canvas节点了，需要注意的是这里的ref属性必须是唯一的，如果定义了相同的ref也是”canvasEle”，那么操作将无效。</p>\n<p>一旦访问到了该元素，那么就可以通过getDOMNode()方法来访问底层的DOM节点，需要注意的是，不要在render方法中尝试用该方法，因为在render方法执行完之前，组件还未挂载，该DOM节点不是最有效的，所以可能会报异常。</p>\n<p>所以要在组件被挂载后使用，比如componentDidMount或者一些用户操作后的事件处理函数，就像下面这样：</p>\n<pre><code>var CanvasComponent = React.createClass({\n    render:function(){\n        return (\n            &lt;canvas ref=&quot;canvasEle&quot; /&gt;\n        );\n    },\n\n    componentDidMount:function(){\n        var oCanvas = this.refs.canvasEle.getNode();\n        //  现在oCanvas就是我们的canvas节点，可以调用canvas下的相关方法来进行操作\n    }\n}); \n</code></pre><p>React的refs和getDOMNode很强大，但是使用它们可能会导致React在性能上的一些问题，所以我们不到在没有其他方式的时候，尽量不要用它们来解决问题。</p>\n<blockquote>\n<p>#####整合非React类库</p>\n</blockquote>\n<p>很多成熟的javaScript类库并没有使用React构建，此时就需要我们自己来进行整合。</p>\n<p>比如现在要使用一个autocomplete插件，包含下面的基础代码：</p>\n<pre><code>autocomplete({\n    target:document.getElementById(&quot;select&quot;),\n    data:[\n        &quot;option1&quot;,&quot;option2&quot;,&quot;option2&quot;\n    ],\n    events:{\n        select:function(item){\n            alert(&quot;你选择了&quot; + item);\n        }\n    }\n});\n</code></pre><p>这个类库需要一个DOM节点，一个数组，一个事件的相关对象，所以，这里就用到了DOM操作，刚才提到，在React中使用DOM操作要在组件挂载完成后或一些事件处理函数中完成。</p>\n<pre><code>var SelectComponent = React.createClass({\n    getDefaultProps:function(){\n        return {\n            data:[\n                    &quot;option1&quot;,&quot;option2&quot;,&quot;option2&quot;\n                ]\n        };\n    },\n    render:function(){\n        return (\n            &lt;div id=&quot;select&quot; ref=&quot;autoCompleteDOM&quot;&gt;&lt;/div&gt;\n        );\n    },\n    handleSelect:function(item){\n        alert(&quot;你选择了&quot; + item);\n    },\n    componentDidMount:function(){\n        autocomplete({\n            target:this.refs.autoCompleteDOM.getDOMNode(),\n            data:this.props.data,\n            events:{\n                select:this.handleSelect\n            }\n        });\n    }\n});\n</code></pre><p>现在把autocomplete引入到React中了，但是这样还不够，要知道，在这个组件被移除了怎么办，所以引入外部插件时一般需要注意在组件类中再实现一个componentWillUnmount的方法，这样在组件被移除，它会对自身进行清理，从而避免内存泄露等性能问题。</p>\n<blockquote>\n<p>#####侵入式插件</p>\n</blockquote>\n<p>在整合非React类库的时候，我们希望整合的类库仅仅操作的是组件的子元素，但是有时并非如此，此时我们就需要把这些额外的操作在React中规避掉，防止出现DOM被意外修改的错误。处理这种问题，最有效的方法就是把DOM的操控权完全给我们自己，而不是给这些类库。</p>\n","excerpt":"","more":"<p>大多数情况下，React的虚拟DOM已经可以创建我们想要的用户体验，而根本不需要直接操作底层真实的DOM，通过组件的复合，把负责的交互聚合为呈现给用户的连贯整体。</p>\n<p>但是在某些情况下，比如与一个没有使用React的第三类库的整合，或者执行一个React没有原生支持的操作等等，我们就不得不去操作底层DOM来达到我们的目的。</p>\n<h4 id=\"DOM操作\"><a href=\"#DOM操作\" class=\"headerlink\" title=\"DOM操作\"></a>DOM操作</h4><blockquote>\n<h5 id=\"访问受控制的DOM节点\"><a href=\"#访问受控制的DOM节点\" class=\"headerlink\" title=\"访问受控制的DOM节点\"></a>访问受控制的DOM节点</h5></blockquote>\n<p>React提供了一个受其自身控制的方法，这些方法只有在生命周期的相关方法里才有效。我们可以给组件的相关元素添加一个ref属性来实现。</p>\n<pre><code>var CanvasComponent = React.createClass({\n    render:function(){\n        return (\n            &lt;canvas ref=&quot;canvasEle&quot; /&gt;\n        );\n    }\n});\n</code></pre><p>这样就可以通过this.refs.canvasEle来访问到这个canvas节点了，需要注意的是这里的ref属性必须是唯一的，如果定义了相同的ref也是”canvasEle”，那么操作将无效。</p>\n<p>一旦访问到了该元素，那么就可以通过getDOMNode()方法来访问底层的DOM节点，需要注意的是，不要在render方法中尝试用该方法，因为在render方法执行完之前，组件还未挂载，该DOM节点不是最有效的，所以可能会报异常。</p>\n<p>所以要在组件被挂载后使用，比如componentDidMount或者一些用户操作后的事件处理函数，就像下面这样：</p>\n<pre><code>var CanvasComponent = React.createClass({\n    render:function(){\n        return (\n            &lt;canvas ref=&quot;canvasEle&quot; /&gt;\n        );\n    },\n\n    componentDidMount:function(){\n        var oCanvas = this.refs.canvasEle.getNode();\n        //  现在oCanvas就是我们的canvas节点，可以调用canvas下的相关方法来进行操作\n    }\n}); \n</code></pre><p>React的refs和getDOMNode很强大，但是使用它们可能会导致React在性能上的一些问题，所以我们不到在没有其他方式的时候，尽量不要用它们来解决问题。</p>\n<blockquote>\n<p>#####整合非React类库</p>\n</blockquote>\n<p>很多成熟的javaScript类库并没有使用React构建，此时就需要我们自己来进行整合。</p>\n<p>比如现在要使用一个autocomplete插件，包含下面的基础代码：</p>\n<pre><code>autocomplete({\n    target:document.getElementById(&quot;select&quot;),\n    data:[\n        &quot;option1&quot;,&quot;option2&quot;,&quot;option2&quot;\n    ],\n    events:{\n        select:function(item){\n            alert(&quot;你选择了&quot; + item);\n        }\n    }\n});\n</code></pre><p>这个类库需要一个DOM节点，一个数组，一个事件的相关对象，所以，这里就用到了DOM操作，刚才提到，在React中使用DOM操作要在组件挂载完成后或一些事件处理函数中完成。</p>\n<pre><code>var SelectComponent = React.createClass({\n    getDefaultProps:function(){\n        return {\n            data:[\n                    &quot;option1&quot;,&quot;option2&quot;,&quot;option2&quot;\n                ]\n        };\n    },\n    render:function(){\n        return (\n            &lt;div id=&quot;select&quot; ref=&quot;autoCompleteDOM&quot;&gt;&lt;/div&gt;\n        );\n    },\n    handleSelect:function(item){\n        alert(&quot;你选择了&quot; + item);\n    },\n    componentDidMount:function(){\n        autocomplete({\n            target:this.refs.autoCompleteDOM.getDOMNode(),\n            data:this.props.data,\n            events:{\n                select:this.handleSelect\n            }\n        });\n    }\n});\n</code></pre><p>现在把autocomplete引入到React中了，但是这样还不够，要知道，在这个组件被移除了怎么办，所以引入外部插件时一般需要注意在组件类中再实现一个componentWillUnmount的方法，这样在组件被移除，它会对自身进行清理，从而避免内存泄露等性能问题。</p>\n<blockquote>\n<p>#####侵入式插件</p>\n</blockquote>\n<p>在整合非React类库的时候，我们希望整合的类库仅仅操作的是组件的子元素，但是有时并非如此，此时我们就需要把这些额外的操作在React中规避掉，防止出现DOM被意外修改的错误。处理这种问题，最有效的方法就是把DOM的操控权完全给我们自己，而不是给这些类库。</p>\n"},{"layout":"post","title":"React Native自定义原生模块","date":"2016-01-11T16:00:00.000Z","_content":"\n现如今，越来越多的移动开发者选择用React Native来开发他们的app。虽然React Native提供了强大的API供我们调用，但是对于一些功能(比如第三方支付、文件上传之类的)，原生模块中并没有提供给我们相关的API，这时候就需要我们来自己封装一些东西来给js端调用。这边以ios端的为例来介绍。\n\n\n---\n\n###### 模块配置表\n\n在RN加载的时候，所有注册并且符合规范的模块都会被导出并且生成相应的模块数据类RCTModuleData，而模块数据中缓存了模块的对象实例，以及模块索引id。\n\n最后大概生成一个如下的模块配置表:\n\n    {\n        \"remoteModuleConfig\": {\n            \"className\": {\n                \"methods\": {\n                    \"method\": {\n                        \"type\": \"remote\",\n                        \"methodID\": 0\n                    },\n                    ...\n                },\n                \"moduleID\": 4\n            },\n            ...\n         },\n    }\n\n###### 通信流程\n\n先看一个js调用OC的下的方法走了哪些步骤:\n\n![](/imgs/progress.jpg)\n\n1.JS端调用某个OC模块暴露出来的方法。\n\n2.把上一步的调用分解为ModuleName,MethodName,arguments，再扔给MessageQueue处理。\n\n3.在这一步把JS的callback函数缓存在MessageQueue的一个成员变量里，用CallbackID代表callback。在通过保存在MessageQueue的模块配置表把上一步传进来的ModuleName和MethodName转为ModuleID和MethodID。\n\n4.把上述步骤得到的ModuleID,MethodId,CallbackID和其他参数argus传给OC。至于具体是怎么传的，后面再说。\n\n5.OC接收到消息，通过模块配置表拿到对应的模块和方法。\n\n6.RCTModuleMethod对JS传过来的每一个参数进行处理。\n\n7.OC模块方法调用完，执行block回调。\n\n8.调用到第6步说明的RCTModuleMethod生成的block。\n\n9.block里带着CallbackID和block传过来的参数去调JS里MessageQueue的方法invokeCallbackAndReturnFlushedQueue。\n\n10.MessageQueue通过CallbackID找到相应的JS callback方法。\n\n11.调用callback方法，并把OC带过来的参数一起传过去，完成回调。\n\n整个流程就是这样，简单概括下，差不多就是：JS函数调用转ModuleID/MethodID -> callback转CallbackID -> OC根据ID拿到方法 -> 处理参数 -> 调用OC方法 -> 回调CallbackID -> JS通过CallbackID拿到callback执行\n\n下面就简单分享一个从OC暴露方法到JS端调用的例子：\n\n\n    // OC(RCTDeviceExtension.m)\n    \n    #import \"RCTBridgeModule.h\"\n    #import \"RCTUtils.h\"\n    //  RCTScreenSize用到\n    \n    @interface RCTDeviceExtension : NSObject <RCTBridgeModule>\n    \n    @end\n    \n    @implementation RCTDeviceExtension\n    \n    RCT_EXPORT_MODULE();\n    //  暴露一个模块\n    \n    /**\n      获取设备的相关信息\n     **/\n    static NSDictionary *DynamicDimesions(){\n      CGFloat width = MIN(RCTScreenSize().width,RCTScreenSize().height);\n      //  宽\n      CGFloat height = MAX(RCTScreenSize().width,RCTScreenSize().height);\n      //  高\n      CGFloat scale = RCTScreenScale();\n      //  像素密度\n      \n      if(UIDeviceOrientationIsLandscape([UIDevice currentDevice].orientation)){\n        width = MAX(RCTScreenSize().width,RCTScreenSize().height);\n        height = MIN(RCTScreenSize().width,RCTScreenSize().height);\n      }\n      \n      return @{\n                @\"width\":@(width),\n                @\"height\":@(height),\n                @\"scale\":@(scale)\n               };\n      //  在回调方法中作为一个对象,有width,height,scale属性\n      \n    }\n    \n    RCT_EXPORT_METHOD(getDeviceInfo:(RCTResponseSenderBlock)callback){\n      callback(@[[NSNull null],DynamicDimesions()]);\n    };\n    //  暴露方法\n    \n    @end\n    \n这里OC暴露一个类,DeviceExtension(RCTDeviceExtension被编译成DeviceExtension)，在JS端，我们就可以通过如下方式来调用相关方法。\n\n    var DeviceExtension = require(\"NativeModules\").DeviceExtension;\n    //  require(\"NativeModules\")用来加载原生模块(包括自定义模块)\n    \n    DeviceExtension.getDeviceInfo(function(err,info){\n      console.log(info);\n    });\n    \n这样我们的自定义API就实现了，后面如果再有更复杂的功能的时候，思路都是一样的，只不过步骤会更繁杂一些。","source":"_posts/2016-01-12-expend-objectc.md","raw":"---\nlayout: post\ntitle: React Native自定义原生模块\ndate: 2016-01-12\ncategories: [React]\n---\n\n现如今，越来越多的移动开发者选择用React Native来开发他们的app。虽然React Native提供了强大的API供我们调用，但是对于一些功能(比如第三方支付、文件上传之类的)，原生模块中并没有提供给我们相关的API，这时候就需要我们来自己封装一些东西来给js端调用。这边以ios端的为例来介绍。\n\n\n---\n\n###### 模块配置表\n\n在RN加载的时候，所有注册并且符合规范的模块都会被导出并且生成相应的模块数据类RCTModuleData，而模块数据中缓存了模块的对象实例，以及模块索引id。\n\n最后大概生成一个如下的模块配置表:\n\n    {\n        \"remoteModuleConfig\": {\n            \"className\": {\n                \"methods\": {\n                    \"method\": {\n                        \"type\": \"remote\",\n                        \"methodID\": 0\n                    },\n                    ...\n                },\n                \"moduleID\": 4\n            },\n            ...\n         },\n    }\n\n###### 通信流程\n\n先看一个js调用OC的下的方法走了哪些步骤:\n\n![](/imgs/progress.jpg)\n\n1.JS端调用某个OC模块暴露出来的方法。\n\n2.把上一步的调用分解为ModuleName,MethodName,arguments，再扔给MessageQueue处理。\n\n3.在这一步把JS的callback函数缓存在MessageQueue的一个成员变量里，用CallbackID代表callback。在通过保存在MessageQueue的模块配置表把上一步传进来的ModuleName和MethodName转为ModuleID和MethodID。\n\n4.把上述步骤得到的ModuleID,MethodId,CallbackID和其他参数argus传给OC。至于具体是怎么传的，后面再说。\n\n5.OC接收到消息，通过模块配置表拿到对应的模块和方法。\n\n6.RCTModuleMethod对JS传过来的每一个参数进行处理。\n\n7.OC模块方法调用完，执行block回调。\n\n8.调用到第6步说明的RCTModuleMethod生成的block。\n\n9.block里带着CallbackID和block传过来的参数去调JS里MessageQueue的方法invokeCallbackAndReturnFlushedQueue。\n\n10.MessageQueue通过CallbackID找到相应的JS callback方法。\n\n11.调用callback方法，并把OC带过来的参数一起传过去，完成回调。\n\n整个流程就是这样，简单概括下，差不多就是：JS函数调用转ModuleID/MethodID -> callback转CallbackID -> OC根据ID拿到方法 -> 处理参数 -> 调用OC方法 -> 回调CallbackID -> JS通过CallbackID拿到callback执行\n\n下面就简单分享一个从OC暴露方法到JS端调用的例子：\n\n\n    // OC(RCTDeviceExtension.m)\n    \n    #import \"RCTBridgeModule.h\"\n    #import \"RCTUtils.h\"\n    //  RCTScreenSize用到\n    \n    @interface RCTDeviceExtension : NSObject <RCTBridgeModule>\n    \n    @end\n    \n    @implementation RCTDeviceExtension\n    \n    RCT_EXPORT_MODULE();\n    //  暴露一个模块\n    \n    /**\n      获取设备的相关信息\n     **/\n    static NSDictionary *DynamicDimesions(){\n      CGFloat width = MIN(RCTScreenSize().width,RCTScreenSize().height);\n      //  宽\n      CGFloat height = MAX(RCTScreenSize().width,RCTScreenSize().height);\n      //  高\n      CGFloat scale = RCTScreenScale();\n      //  像素密度\n      \n      if(UIDeviceOrientationIsLandscape([UIDevice currentDevice].orientation)){\n        width = MAX(RCTScreenSize().width,RCTScreenSize().height);\n        height = MIN(RCTScreenSize().width,RCTScreenSize().height);\n      }\n      \n      return @{\n                @\"width\":@(width),\n                @\"height\":@(height),\n                @\"scale\":@(scale)\n               };\n      //  在回调方法中作为一个对象,有width,height,scale属性\n      \n    }\n    \n    RCT_EXPORT_METHOD(getDeviceInfo:(RCTResponseSenderBlock)callback){\n      callback(@[[NSNull null],DynamicDimesions()]);\n    };\n    //  暴露方法\n    \n    @end\n    \n这里OC暴露一个类,DeviceExtension(RCTDeviceExtension被编译成DeviceExtension)，在JS端，我们就可以通过如下方式来调用相关方法。\n\n    var DeviceExtension = require(\"NativeModules\").DeviceExtension;\n    //  require(\"NativeModules\")用来加载原生模块(包括自定义模块)\n    \n    DeviceExtension.getDeviceInfo(function(err,info){\n      console.log(info);\n    });\n    \n这样我们的自定义API就实现了，后面如果再有更复杂的功能的时候，思路都是一样的，只不过步骤会更繁杂一些。","slug":"2016-01-12-expend-objectc","published":1,"updated":"2016-11-07T02:19:51.000Z","_id":"civ7fsefe001at95fsqz7yqa3","comments":1,"photos":[],"link":"","content":"<p>现如今，越来越多的移动开发者选择用React Native来开发他们的app。虽然React Native提供了强大的API供我们调用，但是对于一些功能(比如第三方支付、文件上传之类的)，原生模块中并没有提供给我们相关的API，这时候就需要我们来自己封装一些东西来给js端调用。这边以ios端的为例来介绍。</p>\n<hr>\n<h6 id=\"模块配置表\"><a href=\"#模块配置表\" class=\"headerlink\" title=\"模块配置表\"></a>模块配置表</h6><p>在RN加载的时候，所有注册并且符合规范的模块都会被导出并且生成相应的模块数据类RCTModuleData，而模块数据中缓存了模块的对象实例，以及模块索引id。</p>\n<p>最后大概生成一个如下的模块配置表:</p>\n<pre><code>{\n    &quot;remoteModuleConfig&quot;: {\n        &quot;className&quot;: {\n            &quot;methods&quot;: {\n                &quot;method&quot;: {\n                    &quot;type&quot;: &quot;remote&quot;,\n                    &quot;methodID&quot;: 0\n                },\n                ...\n            },\n            &quot;moduleID&quot;: 4\n        },\n        ...\n     },\n}\n</code></pre><h6 id=\"通信流程\"><a href=\"#通信流程\" class=\"headerlink\" title=\"通信流程\"></a>通信流程</h6><p>先看一个js调用OC的下的方法走了哪些步骤:</p>\n<p><img src=\"/imgs/progress.jpg\" alt=\"\"></p>\n<p>1.JS端调用某个OC模块暴露出来的方法。</p>\n<p>2.把上一步的调用分解为ModuleName,MethodName,arguments，再扔给MessageQueue处理。</p>\n<p>3.在这一步把JS的callback函数缓存在MessageQueue的一个成员变量里，用CallbackID代表callback。在通过保存在MessageQueue的模块配置表把上一步传进来的ModuleName和MethodName转为ModuleID和MethodID。</p>\n<p>4.把上述步骤得到的ModuleID,MethodId,CallbackID和其他参数argus传给OC。至于具体是怎么传的，后面再说。</p>\n<p>5.OC接收到消息，通过模块配置表拿到对应的模块和方法。</p>\n<p>6.RCTModuleMethod对JS传过来的每一个参数进行处理。</p>\n<p>7.OC模块方法调用完，执行block回调。</p>\n<p>8.调用到第6步说明的RCTModuleMethod生成的block。</p>\n<p>9.block里带着CallbackID和block传过来的参数去调JS里MessageQueue的方法invokeCallbackAndReturnFlushedQueue。</p>\n<p>10.MessageQueue通过CallbackID找到相应的JS callback方法。</p>\n<p>11.调用callback方法，并把OC带过来的参数一起传过去，完成回调。</p>\n<p>整个流程就是这样，简单概括下，差不多就是：JS函数调用转ModuleID/MethodID -&gt; callback转CallbackID -&gt; OC根据ID拿到方法 -&gt; 处理参数 -&gt; 调用OC方法 -&gt; 回调CallbackID -&gt; JS通过CallbackID拿到callback执行</p>\n<p>下面就简单分享一个从OC暴露方法到JS端调用的例子：</p>\n<pre><code>// OC(RCTDeviceExtension.m)\n\n#import &quot;RCTBridgeModule.h&quot;\n#import &quot;RCTUtils.h&quot;\n//  RCTScreenSize用到\n\n@interface RCTDeviceExtension : NSObject &lt;RCTBridgeModule&gt;\n\n@end\n\n@implementation RCTDeviceExtension\n\nRCT_EXPORT_MODULE();\n//  暴露一个模块\n\n/**\n  获取设备的相关信息\n **/\nstatic NSDictionary *DynamicDimesions(){\n  CGFloat width = MIN(RCTScreenSize().width,RCTScreenSize().height);\n  //  宽\n  CGFloat height = MAX(RCTScreenSize().width,RCTScreenSize().height);\n  //  高\n  CGFloat scale = RCTScreenScale();\n  //  像素密度\n\n  if(UIDeviceOrientationIsLandscape([UIDevice currentDevice].orientation)){\n    width = MAX(RCTScreenSize().width,RCTScreenSize().height);\n    height = MIN(RCTScreenSize().width,RCTScreenSize().height);\n  }\n\n  return @{\n            @&quot;width&quot;:@(width),\n            @&quot;height&quot;:@(height),\n            @&quot;scale&quot;:@(scale)\n           };\n  //  在回调方法中作为一个对象,有width,height,scale属性\n\n}\n\nRCT_EXPORT_METHOD(getDeviceInfo:(RCTResponseSenderBlock)callback){\n  callback(@[[NSNull null],DynamicDimesions()]);\n};\n//  暴露方法\n\n@end\n</code></pre><p>这里OC暴露一个类,DeviceExtension(RCTDeviceExtension被编译成DeviceExtension)，在JS端，我们就可以通过如下方式来调用相关方法。</p>\n<pre><code>var DeviceExtension = require(&quot;NativeModules&quot;).DeviceExtension;\n//  require(&quot;NativeModules&quot;)用来加载原生模块(包括自定义模块)\n\nDeviceExtension.getDeviceInfo(function(err,info){\n  console.log(info);\n});\n</code></pre><p>这样我们的自定义API就实现了，后面如果再有更复杂的功能的时候，思路都是一样的，只不过步骤会更繁杂一些。</p>\n","excerpt":"","more":"<p>现如今，越来越多的移动开发者选择用React Native来开发他们的app。虽然React Native提供了强大的API供我们调用，但是对于一些功能(比如第三方支付、文件上传之类的)，原生模块中并没有提供给我们相关的API，这时候就需要我们来自己封装一些东西来给js端调用。这边以ios端的为例来介绍。</p>\n<hr>\n<h6 id=\"模块配置表\"><a href=\"#模块配置表\" class=\"headerlink\" title=\"模块配置表\"></a>模块配置表</h6><p>在RN加载的时候，所有注册并且符合规范的模块都会被导出并且生成相应的模块数据类RCTModuleData，而模块数据中缓存了模块的对象实例，以及模块索引id。</p>\n<p>最后大概生成一个如下的模块配置表:</p>\n<pre><code>{\n    &quot;remoteModuleConfig&quot;: {\n        &quot;className&quot;: {\n            &quot;methods&quot;: {\n                &quot;method&quot;: {\n                    &quot;type&quot;: &quot;remote&quot;,\n                    &quot;methodID&quot;: 0\n                },\n                ...\n            },\n            &quot;moduleID&quot;: 4\n        },\n        ...\n     },\n}\n</code></pre><h6 id=\"通信流程\"><a href=\"#通信流程\" class=\"headerlink\" title=\"通信流程\"></a>通信流程</h6><p>先看一个js调用OC的下的方法走了哪些步骤:</p>\n<p><img src=\"/imgs/progress.jpg\" alt=\"\"></p>\n<p>1.JS端调用某个OC模块暴露出来的方法。</p>\n<p>2.把上一步的调用分解为ModuleName,MethodName,arguments，再扔给MessageQueue处理。</p>\n<p>3.在这一步把JS的callback函数缓存在MessageQueue的一个成员变量里，用CallbackID代表callback。在通过保存在MessageQueue的模块配置表把上一步传进来的ModuleName和MethodName转为ModuleID和MethodID。</p>\n<p>4.把上述步骤得到的ModuleID,MethodId,CallbackID和其他参数argus传给OC。至于具体是怎么传的，后面再说。</p>\n<p>5.OC接收到消息，通过模块配置表拿到对应的模块和方法。</p>\n<p>6.RCTModuleMethod对JS传过来的每一个参数进行处理。</p>\n<p>7.OC模块方法调用完，执行block回调。</p>\n<p>8.调用到第6步说明的RCTModuleMethod生成的block。</p>\n<p>9.block里带着CallbackID和block传过来的参数去调JS里MessageQueue的方法invokeCallbackAndReturnFlushedQueue。</p>\n<p>10.MessageQueue通过CallbackID找到相应的JS callback方法。</p>\n<p>11.调用callback方法，并把OC带过来的参数一起传过去，完成回调。</p>\n<p>整个流程就是这样，简单概括下，差不多就是：JS函数调用转ModuleID/MethodID -&gt; callback转CallbackID -&gt; OC根据ID拿到方法 -&gt; 处理参数 -&gt; 调用OC方法 -&gt; 回调CallbackID -&gt; JS通过CallbackID拿到callback执行</p>\n<p>下面就简单分享一个从OC暴露方法到JS端调用的例子：</p>\n<pre><code>// OC(RCTDeviceExtension.m)\n\n#import &quot;RCTBridgeModule.h&quot;\n#import &quot;RCTUtils.h&quot;\n//  RCTScreenSize用到\n\n@interface RCTDeviceExtension : NSObject &lt;RCTBridgeModule&gt;\n\n@end\n\n@implementation RCTDeviceExtension\n\nRCT_EXPORT_MODULE();\n//  暴露一个模块\n\n/**\n  获取设备的相关信息\n **/\nstatic NSDictionary *DynamicDimesions(){\n  CGFloat width = MIN(RCTScreenSize().width,RCTScreenSize().height);\n  //  宽\n  CGFloat height = MAX(RCTScreenSize().width,RCTScreenSize().height);\n  //  高\n  CGFloat scale = RCTScreenScale();\n  //  像素密度\n\n  if(UIDeviceOrientationIsLandscape([UIDevice currentDevice].orientation)){\n    width = MAX(RCTScreenSize().width,RCTScreenSize().height);\n    height = MIN(RCTScreenSize().width,RCTScreenSize().height);\n  }\n\n  return @{\n            @&quot;width&quot;:@(width),\n            @&quot;height&quot;:@(height),\n            @&quot;scale&quot;:@(scale)\n           };\n  //  在回调方法中作为一个对象,有width,height,scale属性\n\n}\n\nRCT_EXPORT_METHOD(getDeviceInfo:(RCTResponseSenderBlock)callback){\n  callback(@[[NSNull null],DynamicDimesions()]);\n};\n//  暴露方法\n\n@end\n</code></pre><p>这里OC暴露一个类,DeviceExtension(RCTDeviceExtension被编译成DeviceExtension)，在JS端，我们就可以通过如下方式来调用相关方法。</p>\n<pre><code>var DeviceExtension = require(&quot;NativeModules&quot;).DeviceExtension;\n//  require(&quot;NativeModules&quot;)用来加载原生模块(包括自定义模块)\n\nDeviceExtension.getDeviceInfo(function(err,info){\n  console.log(info);\n});\n</code></pre><p>这样我们的自定义API就实现了，后面如果再有更复杂的功能的时候，思路都是一样的，只不过步骤会更繁杂一些。</p>\n"},{"layout":"post","title":"javascript的高阶函数","date":"2016-01-15T16:00:00.000Z","_content":"\n高阶函数:听到高阶感觉很高大上的一个词,但是实现起来并不是那么难。\n\n记得有一次在看js面试题相关资料时,看到类似于下面一个题目,实现一个函数,能有如下写法,实现两个值相加并返回,写法大概是这样的:\n\n    add(10)(5);\n    \n以前没见过这种写法,相信大家对下面的写法肯定不陌生:\n\n    function add(){\n        return function(a,b){\n            return a + b;\n        };\n    }\n    \n    //  然后调用的时候写成下面的样子\n    \n    add()(10,5);\n    \n    //  最后返回15\n    \n仔细观察这两种写法,发现它们在写法上差别很小,第一种写法是一个括号里放一个参数,而第二种写法是把两个参数放在同一个括号里,既然写法类似,实现起来肯定区别也不是特别大,且看下面的实现:\n\n    function add(a){\n        return function(b){\n            return a + b;\n        }\n    }\n    \n这样我们就实现了一个高阶函数。在上面两个例子中,调用add并没有立即返回一个计算后的值,而是返回了一个函数,调用该返回的函数后,才会返回具体计算后的值,这样就有了第二对括号。\n\n再来看个例子:\n\n    function func(p1){\n        var self = this;\n    \n        function fd(p2) {\n            this.add1 = function (p3) {\n                return p1 + \",\" + p2 + \" \" + p3;\n            };\n        }\n    \n        self.add =  function (p2){\n            fd.call(this, p2);\n            return this.add1;\n        };\n        \n        return self.add;\n    }\n    \n    //  也可以直接这样实现\n    function func(p1){\n        return function(p2){\n            return function(p3){\n                return p1 + \",\" + p2 + \" \" + p3;\n            }\n        }\n    }\n    \n再来个实例,解决数组元素累加的问题:\n\n    function addArray(arr){\n        var res = 0;\n        if(Array.prototype.forEach){\n            arr.forEach(function(item){\n                res += item;\n            });\n            return res;\n        }\n        for(var i = 0,len = arr.length;i < len;i ++){\n            res += arr[i];\n        }\n        return res;\n    }\n        \n    function applyAdd(func,arr){\n        return func.apply(func,Array.prototype.slice.call(arguments, 1));\n    }\n        \n    console.log(applyAdd(addArray,[1,2,3,4,5,6,7,8,9]));\n    \n在调用applyAdd时,其实真正走的是addArray方法。\n\n在著名的js工具库underscoreJs中,也有类似的例子,后面介绍。","source":"_posts/2016-01-16-javascript-higher-order-functions.md","raw":"---\nlayout: post\ntitle: javascript的高阶函数\ndate: 2016-01-16\ncategories: [javascript, 高阶函数]\n---\n\n高阶函数:听到高阶感觉很高大上的一个词,但是实现起来并不是那么难。\n\n记得有一次在看js面试题相关资料时,看到类似于下面一个题目,实现一个函数,能有如下写法,实现两个值相加并返回,写法大概是这样的:\n\n    add(10)(5);\n    \n以前没见过这种写法,相信大家对下面的写法肯定不陌生:\n\n    function add(){\n        return function(a,b){\n            return a + b;\n        };\n    }\n    \n    //  然后调用的时候写成下面的样子\n    \n    add()(10,5);\n    \n    //  最后返回15\n    \n仔细观察这两种写法,发现它们在写法上差别很小,第一种写法是一个括号里放一个参数,而第二种写法是把两个参数放在同一个括号里,既然写法类似,实现起来肯定区别也不是特别大,且看下面的实现:\n\n    function add(a){\n        return function(b){\n            return a + b;\n        }\n    }\n    \n这样我们就实现了一个高阶函数。在上面两个例子中,调用add并没有立即返回一个计算后的值,而是返回了一个函数,调用该返回的函数后,才会返回具体计算后的值,这样就有了第二对括号。\n\n再来看个例子:\n\n    function func(p1){\n        var self = this;\n    \n        function fd(p2) {\n            this.add1 = function (p3) {\n                return p1 + \",\" + p2 + \" \" + p3;\n            };\n        }\n    \n        self.add =  function (p2){\n            fd.call(this, p2);\n            return this.add1;\n        };\n        \n        return self.add;\n    }\n    \n    //  也可以直接这样实现\n    function func(p1){\n        return function(p2){\n            return function(p3){\n                return p1 + \",\" + p2 + \" \" + p3;\n            }\n        }\n    }\n    \n再来个实例,解决数组元素累加的问题:\n\n    function addArray(arr){\n        var res = 0;\n        if(Array.prototype.forEach){\n            arr.forEach(function(item){\n                res += item;\n            });\n            return res;\n        }\n        for(var i = 0,len = arr.length;i < len;i ++){\n            res += arr[i];\n        }\n        return res;\n    }\n        \n    function applyAdd(func,arr){\n        return func.apply(func,Array.prototype.slice.call(arguments, 1));\n    }\n        \n    console.log(applyAdd(addArray,[1,2,3,4,5,6,7,8,9]));\n    \n在调用applyAdd时,其实真正走的是addArray方法。\n\n在著名的js工具库underscoreJs中,也有类似的例子,后面介绍。","slug":"2016-01-16-javascript-higher-order-functions","published":1,"updated":"2016-11-09T14:01:45.000Z","_id":"civ7fsefg001ct95fupm2pdjw","comments":1,"photos":[],"link":"","content":"<p>高阶函数:听到高阶感觉很高大上的一个词,但是实现起来并不是那么难。</p>\n<p>记得有一次在看js面试题相关资料时,看到类似于下面一个题目,实现一个函数,能有如下写法,实现两个值相加并返回,写法大概是这样的:</p>\n<pre><code>add(10)(5);\n</code></pre><p>以前没见过这种写法,相信大家对下面的写法肯定不陌生:</p>\n<pre><code>function add(){\n    return function(a,b){\n        return a + b;\n    };\n}\n\n//  然后调用的时候写成下面的样子\n\nadd()(10,5);\n\n//  最后返回15\n</code></pre><p>仔细观察这两种写法,发现它们在写法上差别很小,第一种写法是一个括号里放一个参数,而第二种写法是把两个参数放在同一个括号里,既然写法类似,实现起来肯定区别也不是特别大,且看下面的实现:</p>\n<pre><code>function add(a){\n    return function(b){\n        return a + b;\n    }\n}\n</code></pre><p>这样我们就实现了一个高阶函数。在上面两个例子中,调用add并没有立即返回一个计算后的值,而是返回了一个函数,调用该返回的函数后,才会返回具体计算后的值,这样就有了第二对括号。</p>\n<p>再来看个例子:</p>\n<pre><code>function func(p1){\n    var self = this;\n\n    function fd(p2) {\n        this.add1 = function (p3) {\n            return p1 + &quot;,&quot; + p2 + &quot; &quot; + p3;\n        };\n    }\n\n    self.add =  function (p2){\n        fd.call(this, p2);\n        return this.add1;\n    };\n\n    return self.add;\n}\n\n//  也可以直接这样实现\nfunction func(p1){\n    return function(p2){\n        return function(p3){\n            return p1 + &quot;,&quot; + p2 + &quot; &quot; + p3;\n        }\n    }\n}\n</code></pre><p>再来个实例,解决数组元素累加的问题:</p>\n<pre><code>function addArray(arr){\n    var res = 0;\n    if(Array.prototype.forEach){\n        arr.forEach(function(item){\n            res += item;\n        });\n        return res;\n    }\n    for(var i = 0,len = arr.length;i &lt; len;i ++){\n        res += arr[i];\n    }\n    return res;\n}\n\nfunction applyAdd(func,arr){\n    return func.apply(func,Array.prototype.slice.call(arguments, 1));\n}\n\nconsole.log(applyAdd(addArray,[1,2,3,4,5,6,7,8,9]));\n</code></pre><p>在调用applyAdd时,其实真正走的是addArray方法。</p>\n<p>在著名的js工具库underscoreJs中,也有类似的例子,后面介绍。</p>\n","excerpt":"","more":"<p>高阶函数:听到高阶感觉很高大上的一个词,但是实现起来并不是那么难。</p>\n<p>记得有一次在看js面试题相关资料时,看到类似于下面一个题目,实现一个函数,能有如下写法,实现两个值相加并返回,写法大概是这样的:</p>\n<pre><code>add(10)(5);\n</code></pre><p>以前没见过这种写法,相信大家对下面的写法肯定不陌生:</p>\n<pre><code>function add(){\n    return function(a,b){\n        return a + b;\n    };\n}\n\n//  然后调用的时候写成下面的样子\n\nadd()(10,5);\n\n//  最后返回15\n</code></pre><p>仔细观察这两种写法,发现它们在写法上差别很小,第一种写法是一个括号里放一个参数,而第二种写法是把两个参数放在同一个括号里,既然写法类似,实现起来肯定区别也不是特别大,且看下面的实现:</p>\n<pre><code>function add(a){\n    return function(b){\n        return a + b;\n    }\n}\n</code></pre><p>这样我们就实现了一个高阶函数。在上面两个例子中,调用add并没有立即返回一个计算后的值,而是返回了一个函数,调用该返回的函数后,才会返回具体计算后的值,这样就有了第二对括号。</p>\n<p>再来看个例子:</p>\n<pre><code>function func(p1){\n    var self = this;\n\n    function fd(p2) {\n        this.add1 = function (p3) {\n            return p1 + &quot;,&quot; + p2 + &quot; &quot; + p3;\n        };\n    }\n\n    self.add =  function (p2){\n        fd.call(this, p2);\n        return this.add1;\n    };\n\n    return self.add;\n}\n\n//  也可以直接这样实现\nfunction func(p1){\n    return function(p2){\n        return function(p3){\n            return p1 + &quot;,&quot; + p2 + &quot; &quot; + p3;\n        }\n    }\n}\n</code></pre><p>再来个实例,解决数组元素累加的问题:</p>\n<pre><code>function addArray(arr){\n    var res = 0;\n    if(Array.prototype.forEach){\n        arr.forEach(function(item){\n            res += item;\n        });\n        return res;\n    }\n    for(var i = 0,len = arr.length;i &lt; len;i ++){\n        res += arr[i];\n    }\n    return res;\n}\n\nfunction applyAdd(func,arr){\n    return func.apply(func,Array.prototype.slice.call(arguments, 1));\n}\n\nconsole.log(applyAdd(addArray,[1,2,3,4,5,6,7,8,9]));\n</code></pre><p>在调用applyAdd时,其实真正走的是addArray方法。</p>\n<p>在著名的js工具库underscoreJs中,也有类似的例子,后面介绍。</p>\n"},{"layout":"post","title":"javascript实现继承之2","date":"2016-03-09T16:00:00.000Z","_content":"\n在前面的一篇文章[JavaScript实现继承](http://rwson.github.io/%E6%8A%80%E6%9C%AF/2015/05/26/js-object-extend.html)介绍过js中通过原型来继承的两种方法\n\n1. 伪造对象继承:通过把父类的实例赋值给子类的prototype，然后在子类的构造函数中调用父类的构造方法；\n2. 类式继承(原型式继承):通过一个空函数中转，把父类的示例赋值给该空函数的原型，然后再把该空函数的prototype赋值给子类的prototype，再在子类的构造方法中调用父类的构造器，实现继承。\n\n综合上面两个方法，其实都通过两次调用父类的构造器来实现，第二种方法相对于第一种只是在子类原型上少了些父类的实例属性。\n\n在《javaScript高级程序》中，介绍了另外一种继承的实现方式，名为\"寄生式组合继承\"。所谓的寄生式组合继承，不必为了子类的原型而调用超类型的构造函数，要实现继承只需要父类原型的一个副本。下面的具体的代码:\n\n    /**\n     * 寄生式组合继承\n     * @param subType   子类\n     * @param superType 父类\n     **/\n    function inheritPrototype(subType,subperType){\n        var prototype = Object(superType.prototype);\n        prototype.constructor = subType;\n        subType.prototype = prototype;\n    }\n    \n    /**\n     * 父类\n     * @param name   name属性\n     **/\n    function superClass(name) {\n        this.name = name;\n    }\n    \n    superClass.prototype.sayName = function() {\n        alert(this.name);    \n    };\n    \n    /**\n     * 子类\n     * @param name   name属性\n     * @param age    age属性\n     **/\n    function subClass(name,age) {\n        superClass.call(this,name);\n        this.age = age;\n    }\n    \n    //  实现继承\n    inheritPrototype(subClass,superClass);\n\n这样就只调用了一次父类的构造方法，在性能上更优秀。","source":"_posts/2016-03-10-js-object-extend2.md","raw":"---\nlayout: post\ntitle: javascript实现继承之2\ndate: 2016-03-10\ncategories: [javascript, 继承]\n---\n\n在前面的一篇文章[JavaScript实现继承](http://rwson.github.io/%E6%8A%80%E6%9C%AF/2015/05/26/js-object-extend.html)介绍过js中通过原型来继承的两种方法\n\n1. 伪造对象继承:通过把父类的实例赋值给子类的prototype，然后在子类的构造函数中调用父类的构造方法；\n2. 类式继承(原型式继承):通过一个空函数中转，把父类的示例赋值给该空函数的原型，然后再把该空函数的prototype赋值给子类的prototype，再在子类的构造方法中调用父类的构造器，实现继承。\n\n综合上面两个方法，其实都通过两次调用父类的构造器来实现，第二种方法相对于第一种只是在子类原型上少了些父类的实例属性。\n\n在《javaScript高级程序》中，介绍了另外一种继承的实现方式，名为\"寄生式组合继承\"。所谓的寄生式组合继承，不必为了子类的原型而调用超类型的构造函数，要实现继承只需要父类原型的一个副本。下面的具体的代码:\n\n    /**\n     * 寄生式组合继承\n     * @param subType   子类\n     * @param superType 父类\n     **/\n    function inheritPrototype(subType,subperType){\n        var prototype = Object(superType.prototype);\n        prototype.constructor = subType;\n        subType.prototype = prototype;\n    }\n    \n    /**\n     * 父类\n     * @param name   name属性\n     **/\n    function superClass(name) {\n        this.name = name;\n    }\n    \n    superClass.prototype.sayName = function() {\n        alert(this.name);    \n    };\n    \n    /**\n     * 子类\n     * @param name   name属性\n     * @param age    age属性\n     **/\n    function subClass(name,age) {\n        superClass.call(this,name);\n        this.age = age;\n    }\n    \n    //  实现继承\n    inheritPrototype(subClass,superClass);\n\n这样就只调用了一次父类的构造方法，在性能上更优秀。","slug":"2016-03-10-js-object-extend2","published":1,"updated":"2016-11-09T14:01:53.000Z","_id":"civ7fsefi001et95fzh4a14pu","comments":1,"photos":[],"link":"","content":"<p>在前面的一篇文章<a href=\"http://rwson.github.io/%E6%8A%80%E6%9C%AF/2015/05/26/js-object-extend.html\" target=\"_blank\" rel=\"external\">JavaScript实现继承</a>介绍过js中通过原型来继承的两种方法</p>\n<ol>\n<li>伪造对象继承:通过把父类的实例赋值给子类的prototype，然后在子类的构造函数中调用父类的构造方法；</li>\n<li>类式继承(原型式继承):通过一个空函数中转，把父类的示例赋值给该空函数的原型，然后再把该空函数的prototype赋值给子类的prototype，再在子类的构造方法中调用父类的构造器，实现继承。</li>\n</ol>\n<p>综合上面两个方法，其实都通过两次调用父类的构造器来实现，第二种方法相对于第一种只是在子类原型上少了些父类的实例属性。</p>\n<p>在《javaScript高级程序》中，介绍了另外一种继承的实现方式，名为”寄生式组合继承”。所谓的寄生式组合继承，不必为了子类的原型而调用超类型的构造函数，要实现继承只需要父类原型的一个副本。下面的具体的代码:</p>\n<pre><code>/**\n * 寄生式组合继承\n * @param subType   子类\n * @param superType 父类\n **/\nfunction inheritPrototype(subType,subperType){\n    var prototype = Object(superType.prototype);\n    prototype.constructor = subType;\n    subType.prototype = prototype;\n}\n\n/**\n * 父类\n * @param name   name属性\n **/\nfunction superClass(name) {\n    this.name = name;\n}\n\nsuperClass.prototype.sayName = function() {\n    alert(this.name);    \n};\n\n/**\n * 子类\n * @param name   name属性\n * @param age    age属性\n **/\nfunction subClass(name,age) {\n    superClass.call(this,name);\n    this.age = age;\n}\n\n//  实现继承\ninheritPrototype(subClass,superClass);\n</code></pre><p>这样就只调用了一次父类的构造方法，在性能上更优秀。</p>\n","excerpt":"","more":"<p>在前面的一篇文章<a href=\"http://rwson.github.io/%E6%8A%80%E6%9C%AF/2015/05/26/js-object-extend.html\">JavaScript实现继承</a>介绍过js中通过原型来继承的两种方法</p>\n<ol>\n<li>伪造对象继承:通过把父类的实例赋值给子类的prototype，然后在子类的构造函数中调用父类的构造方法；</li>\n<li>类式继承(原型式继承):通过一个空函数中转，把父类的示例赋值给该空函数的原型，然后再把该空函数的prototype赋值给子类的prototype，再在子类的构造方法中调用父类的构造器，实现继承。</li>\n</ol>\n<p>综合上面两个方法，其实都通过两次调用父类的构造器来实现，第二种方法相对于第一种只是在子类原型上少了些父类的实例属性。</p>\n<p>在《javaScript高级程序》中，介绍了另外一种继承的实现方式，名为”寄生式组合继承”。所谓的寄生式组合继承，不必为了子类的原型而调用超类型的构造函数，要实现继承只需要父类原型的一个副本。下面的具体的代码:</p>\n<pre><code>/**\n * 寄生式组合继承\n * @param subType   子类\n * @param superType 父类\n **/\nfunction inheritPrototype(subType,subperType){\n    var prototype = Object(superType.prototype);\n    prototype.constructor = subType;\n    subType.prototype = prototype;\n}\n\n/**\n * 父类\n * @param name   name属性\n **/\nfunction superClass(name) {\n    this.name = name;\n}\n\nsuperClass.prototype.sayName = function() {\n    alert(this.name);    \n};\n\n/**\n * 子类\n * @param name   name属性\n * @param age    age属性\n **/\nfunction subClass(name,age) {\n    superClass.call(this,name);\n    this.age = age;\n}\n\n//  实现继承\ninheritPrototype(subClass,superClass);\n</code></pre><p>这样就只调用了一次父类的构造方法，在性能上更优秀。</p>\n"},{"layout":"post","title":"实现模块化编程","date":"2016-03-23T16:00:00.000Z","_content":"\n先上个小例子(工资计算器):\n\n- 传统\n\n\n```\n    //  绩效奖金\n    function performanceCoefficient(salary) {\n        return salary * 0.2;\n    }\n    \n    //  住房公积金\n    function companyReserve(salary) {\n        return salary * 0.2;\n    }\n    \n    //  个人所得税、五险一金\n    function incomeTax(remain) {\n        return (remain - 3500) * 0.2;\n    }\n    \n    //  基本工资\n    var salary = 10000;\n    \n    //  最后税前工资\n    var finalSalary = salary + performanceCoefficient(salary);\n    \n    finalSalary = finalSalary - incomeTax(finalSalary - companyReserve(finalSalary));\n    \n    console.log(finalSalary);\n```\n\n\n- 类模块化\n\n```\n    //  全局变量,存储已经声明的模块\n    var modules = {};\n    \n    //  先来实现几个工具函数\n    var define = (function() {\n    \n    //  根据depArrs中的模块名称找出modules中的相关对象\n    var _require = function(depArrs) {\n        return depArrs.map(function(dep) {\n            return modules[dep];\n        });\n    };\n\n        //  define函数实际做的事情\n        return function(id, depArrs, factory) {\n        \n            //  判断是否已经声明过同名模块\n            deps.map(function(dep) {\n                return dep.factory.apply(window, dep.deps);\n            });\n    \n            var deps = _require(depArrs);\n            if (modules[id]) {\n                throw new Error(\"module \" + id + \" has been declared!\");\n            }\n            modules[id] = {\n                id: id,\n                factory: factory,\n                deps: deps\n            };\n        };\n    })();\n\n    //  实现一个调用主入口文件,只需传入模块id即可\n    //  类似于sea中的sea.use(\"id\", [], function(){ /*...*/ })\n    //  或者requirejs中的require([\"id\"])\n    var loader = function(id) {\n        if (!modules[id]) {\n            throw new Error(\"module\" + id + \" has not been declared!\");\n        }\n        var deps = modules[id].deps;\n        deps = deps.map(function(dep) {\n            return dep.factory.apply(window, dep.deps);\n        });\n        modules[id].factory.apply(window, deps);\n    };\n\n    //  声明一个计算模块\n    define(\"calc\", [], function() {\n        return {\n            performanceCoefficient: function(salary) {\n                return salary * 0.2;\n            },\n            companyReserve: function(salary) {\n                return salary * 0.2;\n            },\n            incomeTax: function(remain) {\n                return (remain - 3500) * 0.2;\n            }\n        };\n    });\n    \n    //  最终用来计算工资的模块\n    define(\"salary\",[\"calc\"], function(calc) {\n        var slary = 10000000,\n            finalSalary = slary + calc.performanceCoefficient(slary);\n            \n        finalSalary = finalSalary - calc.incomeTax(finalSalary - calc.companyReserve(finalSalary));\n        \n        console.log(finalSalary);\n        \n    });\n    \n    loader(\"salary\");\n```\n\n\n上面两段代码都完成了相同的功能,但是在写法上差别很大,称第二种方式是类模块化的原因是现在的代码还没有完全实现模块化,所有的模块都在同一文件,没有实现完全解耦,这时就需要加载器(require)来帮我们完成各功能模块分文件的目的,模块化的优势不言而喻,后面介绍一步步实现一个符合AMD规范的加载器。","source":"_posts/2016-03-24-javascript-self-loader.md","raw":"---\nlayout: post\ntitle: 实现模块化编程\ndate: 2016-03-24\ncategories: [javascript, 继承]\n---\n\n先上个小例子(工资计算器):\n\n- 传统\n\n\n```\n    //  绩效奖金\n    function performanceCoefficient(salary) {\n        return salary * 0.2;\n    }\n    \n    //  住房公积金\n    function companyReserve(salary) {\n        return salary * 0.2;\n    }\n    \n    //  个人所得税、五险一金\n    function incomeTax(remain) {\n        return (remain - 3500) * 0.2;\n    }\n    \n    //  基本工资\n    var salary = 10000;\n    \n    //  最后税前工资\n    var finalSalary = salary + performanceCoefficient(salary);\n    \n    finalSalary = finalSalary - incomeTax(finalSalary - companyReserve(finalSalary));\n    \n    console.log(finalSalary);\n```\n\n\n- 类模块化\n\n```\n    //  全局变量,存储已经声明的模块\n    var modules = {};\n    \n    //  先来实现几个工具函数\n    var define = (function() {\n    \n    //  根据depArrs中的模块名称找出modules中的相关对象\n    var _require = function(depArrs) {\n        return depArrs.map(function(dep) {\n            return modules[dep];\n        });\n    };\n\n        //  define函数实际做的事情\n        return function(id, depArrs, factory) {\n        \n            //  判断是否已经声明过同名模块\n            deps.map(function(dep) {\n                return dep.factory.apply(window, dep.deps);\n            });\n    \n            var deps = _require(depArrs);\n            if (modules[id]) {\n                throw new Error(\"module \" + id + \" has been declared!\");\n            }\n            modules[id] = {\n                id: id,\n                factory: factory,\n                deps: deps\n            };\n        };\n    })();\n\n    //  实现一个调用主入口文件,只需传入模块id即可\n    //  类似于sea中的sea.use(\"id\", [], function(){ /*...*/ })\n    //  或者requirejs中的require([\"id\"])\n    var loader = function(id) {\n        if (!modules[id]) {\n            throw new Error(\"module\" + id + \" has not been declared!\");\n        }\n        var deps = modules[id].deps;\n        deps = deps.map(function(dep) {\n            return dep.factory.apply(window, dep.deps);\n        });\n        modules[id].factory.apply(window, deps);\n    };\n\n    //  声明一个计算模块\n    define(\"calc\", [], function() {\n        return {\n            performanceCoefficient: function(salary) {\n                return salary * 0.2;\n            },\n            companyReserve: function(salary) {\n                return salary * 0.2;\n            },\n            incomeTax: function(remain) {\n                return (remain - 3500) * 0.2;\n            }\n        };\n    });\n    \n    //  最终用来计算工资的模块\n    define(\"salary\",[\"calc\"], function(calc) {\n        var slary = 10000000,\n            finalSalary = slary + calc.performanceCoefficient(slary);\n            \n        finalSalary = finalSalary - calc.incomeTax(finalSalary - calc.companyReserve(finalSalary));\n        \n        console.log(finalSalary);\n        \n    });\n    \n    loader(\"salary\");\n```\n\n\n上面两段代码都完成了相同的功能,但是在写法上差别很大,称第二种方式是类模块化的原因是现在的代码还没有完全实现模块化,所有的模块都在同一文件,没有实现完全解耦,这时就需要加载器(require)来帮我们完成各功能模块分文件的目的,模块化的优势不言而喻,后面介绍一步步实现一个符合AMD规范的加载器。","slug":"2016-03-24-javascript-self-loader","published":1,"updated":"2016-11-09T14:01:58.000Z","_id":"civ7fsefl001ht95f3tdsh34o","comments":1,"photos":[],"link":"","content":"<p>先上个小例子(工资计算器):</p>\n<ul>\n<li>传统</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">//  绩效奖金</div><div class=\"line\">function performanceCoefficient(salary) &#123;</div><div class=\"line\">    return salary * 0.2;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//  住房公积金</div><div class=\"line\">function companyReserve(salary) &#123;</div><div class=\"line\">    return salary * 0.2;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//  个人所得税、五险一金</div><div class=\"line\">function incomeTax(remain) &#123;</div><div class=\"line\">    return (remain - 3500) * 0.2;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//  基本工资</div><div class=\"line\">var salary = 10000;</div><div class=\"line\"></div><div class=\"line\">//  最后税前工资</div><div class=\"line\">var finalSalary = salary + performanceCoefficient(salary);</div><div class=\"line\"></div><div class=\"line\">finalSalary = finalSalary - incomeTax(finalSalary - companyReserve(finalSalary));</div><div class=\"line\"></div><div class=\"line\">console.log(finalSalary);</div></pre></td></tr></table></figure>\n<ul>\n<li>类模块化</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div></pre></td><td class=\"code\"><pre><div class=\"line\">//  全局变量,存储已经声明的模块</div><div class=\"line\">var modules = &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">//  先来实现几个工具函数</div><div class=\"line\">var define = (function() &#123;</div><div class=\"line\"></div><div class=\"line\">//  根据depArrs中的模块名称找出modules中的相关对象</div><div class=\"line\">var _require = function(depArrs) &#123;</div><div class=\"line\">    return depArrs.map(function(dep) &#123;</div><div class=\"line\">        return modules[dep];</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">    //  define函数实际做的事情</div><div class=\"line\">    return function(id, depArrs, factory) &#123;</div><div class=\"line\">    </div><div class=\"line\">        //  判断是否已经声明过同名模块</div><div class=\"line\">        deps.map(function(dep) &#123;</div><div class=\"line\">            return dep.factory.apply(window, dep.deps);</div><div class=\"line\">        &#125;);</div><div class=\"line\"></div><div class=\"line\">        var deps = _require(depArrs);</div><div class=\"line\">        if (modules[id]) &#123;</div><div class=\"line\">            throw new Error(&quot;module &quot; + id + &quot; has been declared!&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        modules[id] = &#123;</div><div class=\"line\">            id: id,</div><div class=\"line\">            factory: factory,</div><div class=\"line\">            deps: deps</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;)();</div><div class=\"line\"></div><div class=\"line\">//  实现一个调用主入口文件,只需传入模块id即可</div><div class=\"line\">//  类似于sea中的sea.use(&quot;id&quot;, [], function()&#123; /*...*/ &#125;)</div><div class=\"line\">//  或者requirejs中的require([&quot;id&quot;])</div><div class=\"line\">var loader = function(id) &#123;</div><div class=\"line\">    if (!modules[id]) &#123;</div><div class=\"line\">        throw new Error(&quot;module&quot; + id + &quot; has not been declared!&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    var deps = modules[id].deps;</div><div class=\"line\">    deps = deps.map(function(dep) &#123;</div><div class=\"line\">        return dep.factory.apply(window, dep.deps);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    modules[id].factory.apply(window, deps);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">//  声明一个计算模块</div><div class=\"line\">define(&quot;calc&quot;, [], function() &#123;</div><div class=\"line\">    return &#123;</div><div class=\"line\">        performanceCoefficient: function(salary) &#123;</div><div class=\"line\">            return salary * 0.2;</div><div class=\"line\">        &#125;,</div><div class=\"line\">        companyReserve: function(salary) &#123;</div><div class=\"line\">            return salary * 0.2;</div><div class=\"line\">        &#125;,</div><div class=\"line\">        incomeTax: function(remain) &#123;</div><div class=\"line\">            return (remain - 3500) * 0.2;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">//  最终用来计算工资的模块</div><div class=\"line\">define(&quot;salary&quot;,[&quot;calc&quot;], function(calc) &#123;</div><div class=\"line\">    var slary = 10000000,</div><div class=\"line\">        finalSalary = slary + calc.performanceCoefficient(slary);</div><div class=\"line\">        </div><div class=\"line\">    finalSalary = finalSalary - calc.incomeTax(finalSalary - calc.companyReserve(finalSalary));</div><div class=\"line\">    </div><div class=\"line\">    console.log(finalSalary);</div><div class=\"line\">    </div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">loader(&quot;salary&quot;);</div></pre></td></tr></table></figure>\n<p>上面两段代码都完成了相同的功能,但是在写法上差别很大,称第二种方式是类模块化的原因是现在的代码还没有完全实现模块化,所有的模块都在同一文件,没有实现完全解耦,这时就需要加载器(require)来帮我们完成各功能模块分文件的目的,模块化的优势不言而喻,后面介绍一步步实现一个符合AMD规范的加载器。</p>\n","excerpt":"","more":"<p>先上个小例子(工资计算器):</p>\n<ul>\n<li>传统</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">//  绩效奖金</div><div class=\"line\">function performanceCoefficient(salary) &#123;</div><div class=\"line\">    return salary * 0.2;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//  住房公积金</div><div class=\"line\">function companyReserve(salary) &#123;</div><div class=\"line\">    return salary * 0.2;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//  个人所得税、五险一金</div><div class=\"line\">function incomeTax(remain) &#123;</div><div class=\"line\">    return (remain - 3500) * 0.2;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//  基本工资</div><div class=\"line\">var salary = 10000;</div><div class=\"line\"></div><div class=\"line\">//  最后税前工资</div><div class=\"line\">var finalSalary = salary + performanceCoefficient(salary);</div><div class=\"line\"></div><div class=\"line\">finalSalary = finalSalary - incomeTax(finalSalary - companyReserve(finalSalary));</div><div class=\"line\"></div><div class=\"line\">console.log(finalSalary);</div></pre></td></tr></table></figure>\n<ul>\n<li>类模块化</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div></pre></td><td class=\"code\"><pre><div class=\"line\">//  全局变量,存储已经声明的模块</div><div class=\"line\">var modules = &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">//  先来实现几个工具函数</div><div class=\"line\">var define = (function() &#123;</div><div class=\"line\"></div><div class=\"line\">//  根据depArrs中的模块名称找出modules中的相关对象</div><div class=\"line\">var _require = function(depArrs) &#123;</div><div class=\"line\">    return depArrs.map(function(dep) &#123;</div><div class=\"line\">        return modules[dep];</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">    //  define函数实际做的事情</div><div class=\"line\">    return function(id, depArrs, factory) &#123;</div><div class=\"line\">    </div><div class=\"line\">        //  判断是否已经声明过同名模块</div><div class=\"line\">        deps.map(function(dep) &#123;</div><div class=\"line\">            return dep.factory.apply(window, dep.deps);</div><div class=\"line\">        &#125;);</div><div class=\"line\"></div><div class=\"line\">        var deps = _require(depArrs);</div><div class=\"line\">        if (modules[id]) &#123;</div><div class=\"line\">            throw new Error(&quot;module &quot; + id + &quot; has been declared!&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        modules[id] = &#123;</div><div class=\"line\">            id: id,</div><div class=\"line\">            factory: factory,</div><div class=\"line\">            deps: deps</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;)();</div><div class=\"line\"></div><div class=\"line\">//  实现一个调用主入口文件,只需传入模块id即可</div><div class=\"line\">//  类似于sea中的sea.use(&quot;id&quot;, [], function()&#123; /*...*/ &#125;)</div><div class=\"line\">//  或者requirejs中的require([&quot;id&quot;])</div><div class=\"line\">var loader = function(id) &#123;</div><div class=\"line\">    if (!modules[id]) &#123;</div><div class=\"line\">        throw new Error(&quot;module&quot; + id + &quot; has not been declared!&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    var deps = modules[id].deps;</div><div class=\"line\">    deps = deps.map(function(dep) &#123;</div><div class=\"line\">        return dep.factory.apply(window, dep.deps);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    modules[id].factory.apply(window, deps);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">//  声明一个计算模块</div><div class=\"line\">define(&quot;calc&quot;, [], function() &#123;</div><div class=\"line\">    return &#123;</div><div class=\"line\">        performanceCoefficient: function(salary) &#123;</div><div class=\"line\">            return salary * 0.2;</div><div class=\"line\">        &#125;,</div><div class=\"line\">        companyReserve: function(salary) &#123;</div><div class=\"line\">            return salary * 0.2;</div><div class=\"line\">        &#125;,</div><div class=\"line\">        incomeTax: function(remain) &#123;</div><div class=\"line\">            return (remain - 3500) * 0.2;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">//  最终用来计算工资的模块</div><div class=\"line\">define(&quot;salary&quot;,[&quot;calc&quot;], function(calc) &#123;</div><div class=\"line\">    var slary = 10000000,</div><div class=\"line\">        finalSalary = slary + calc.performanceCoefficient(slary);</div><div class=\"line\">        </div><div class=\"line\">    finalSalary = finalSalary - calc.incomeTax(finalSalary - calc.companyReserve(finalSalary));</div><div class=\"line\">    </div><div class=\"line\">    console.log(finalSalary);</div><div class=\"line\">    </div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">loader(&quot;salary&quot;);</div></pre></td></tr></table></figure>\n<p>上面两段代码都完成了相同的功能,但是在写法上差别很大,称第二种方式是类模块化的原因是现在的代码还没有完全实现模块化,所有的模块都在同一文件,没有实现完全解耦,这时就需要加载器(require)来帮我们完成各功能模块分文件的目的,模块化的优势不言而喻,后面介绍一步步实现一个符合AMD规范的加载器。</p>\n"},{"layout":"post","title":"ES6中的Promise","date":"2016-05-03T16:00:00.000Z","_content":"\n在执行一些异步操作(典型的有JavaScript中的ajax/NodeJs中读取文件等等)的时候,我们不知道该操作什么时候完成,所以就需要在不同的时候写上回调,等到有返回的时候,再执行下一步操作,下面就用jQuery中的一个ajax来做示例:\n\n    $.ajax({\n        \"url\": \"xxx\",\n        \"type\": \"GET\",\n        \"dataType\": \"\"JSON,\n        \"success\": function(res){},\n        \"error\": function(ex){\n            //  do some thing\n        }\n    });\n\n最基础的一个ajax示例,当我们有多个ajax嵌套请求的时候,就中了所谓的\"回调地狱\",类似于下面的写法:\n\n    $.ajax({\n        //  some configs\n        \"success\": function(res){\n            $.ajax({\n                //  ...\n                \"success\": function(res){\n                    $.ajax({\n                        //  ...\n                        \"success\":function(res){\n                            .\n                            .\n                            .\n                        }\n                    });\n                }\n            });\n        }\n    });\n\n一层套着一层,代码可读性很差,且不容易后期的维护\n\n这时候就需要一个比前者好的解决方案来解决该问题,ES6中的Promise一定程度上解决了该问题:\n\n我们可以利用Promise对ajax进行一层封装\n\n    function _ajax(url, method, args) {\n        let promise = new Promise((resolve, reject) => {\n\n            let client = new XMLHttpRequest();\n            let uri = url;\n\n            if (args && (method == \"POST\" || method == \"PUT\")) {\n                let argcount = 0;\n                uri += \"?\";\n                for (var key in args) {\n                    if (args.hasOwnProperty(key)) {\n                        if (argcount++) {\n                            uri += '&';\n                        }\n                        uri += encodeURIComponent(key) + '=' + encodeURIComponent(args[key]);\n                    }\n                }\n            }\n\n            client.open(method, uri);\n            client.send();\n\n            client.onload = function() {\n                if (this.status >= 200 && this.status < 300) {\n                    resolve(this.response);\n                } else {\n                    reject(this.statusText);\n                }\n            };\n            client.onerror = function() {\n                reject(this.statusText);\n            };\n\n        });\n\n        return promise;\n    }\n\n    let core = {\n\n        \"GET\": function(args) {\n            return _ajax(url, \"GET\", args);\n        },\n\n        \"POST\": function(args) {\n            return _ajax(url, \"POST\", args);\n        },\n\n        \"PUT\": function(args) {\n            return _ajax(url, \"PUT\", args);\n        },\n\n        \"DELETE\": function(args) {\n            return _ajax(url, \"DELETE\", args);\n        }\n\n    };\n\n上面这段代码是JavaScript MDN上的代码(可能稍微有点改动),它对ajax进行了一层封装,经过这层封装,我们可以像下面这样写一些异步代码:\n\n    $http(\"xxx\")\n    .GET()\n    .then((data) => {\n        \n        //  do something\n        \n        $http(\"xxx2\")\n        .GET()\n        .then((data) => {\n        \n            //  do something\n            \n            $http(\"xxx3\")\n            .GET({\"key\",\"value\"})\n            .then((data) => {\n                //  do something...\n            })\n            \n            \n        },(ex) => {});\n        \n    })\n    .catch((ex) => {});\n\n虽然还有嵌套,但是代码看起来已经舒服了很多。\n\nPromise是一个异步编程的抽象,它是一个返回值或抛出exception的代理对象,一般promise对象都有一个then方法,这个then方法是我们如何获得返回值(成功实现承诺的结果值,称为fulfillment)或抛出exception(拒绝承诺的理由,称为rejection)，then是用两个可选的回调作为参数,我们可以称为onFulfilled和OnRejected,也可以把OnRejected写在catch里面\n\n所以一个Promise一共有下面几个状态\n\n1. pending待承诺 - promise初始状态\n2. fulfilled实现承诺 - 一个承诺成功实现状态\n3. rejected拒绝承诺 - 一个承诺失败的状态\n\n再来个NodeJs中读取文件的例子:\n\n    function readFile(path) {\n        var fs = require(\"fs\");\n        var prromise = new Promise((resolve, reject) => {\n            fs.readdir(path, (ex, files) => {\n                if (ex) {\n                    return reject(ex);\n                }\n                return resolve(files);\n            });\n        });\n        \n        return prromise;\n    }\n\n    readFile(config.avatarPath + \"1\").then((files) => {\n        //  do some thing\n        console.log(files);\n    }).catch((ex) => {\n        //  do something...\n        console.log(ex);\n    });\n    \n如果不用Promise和一些ES6的特性,上面的代码应该看起来是下面的这样子:\n\n    var fs = require(\"fs\");\n    fs.readdir(path, function (ex, files) {\n        if (ex) {\n            //  do something\n            return console.log();\n        }\n        \n        //  do some thing\n        console.log(files);\n    });\n\n代码量可能更少,但是陷入\"回调地狱\"的可能就更大了,在ES7中,又新增了async/await特性来针对异步操作的,后面介绍😄\n\n","source":"_posts/2016-05-04-es6-promise.md","raw":"---\nlayout: post\ntitle: ES6中的Promise\ndate: 2016-05-04\ncategories: [ES6, Promise]\n---\n\n在执行一些异步操作(典型的有JavaScript中的ajax/NodeJs中读取文件等等)的时候,我们不知道该操作什么时候完成,所以就需要在不同的时候写上回调,等到有返回的时候,再执行下一步操作,下面就用jQuery中的一个ajax来做示例:\n\n    $.ajax({\n        \"url\": \"xxx\",\n        \"type\": \"GET\",\n        \"dataType\": \"\"JSON,\n        \"success\": function(res){},\n        \"error\": function(ex){\n            //  do some thing\n        }\n    });\n\n最基础的一个ajax示例,当我们有多个ajax嵌套请求的时候,就中了所谓的\"回调地狱\",类似于下面的写法:\n\n    $.ajax({\n        //  some configs\n        \"success\": function(res){\n            $.ajax({\n                //  ...\n                \"success\": function(res){\n                    $.ajax({\n                        //  ...\n                        \"success\":function(res){\n                            .\n                            .\n                            .\n                        }\n                    });\n                }\n            });\n        }\n    });\n\n一层套着一层,代码可读性很差,且不容易后期的维护\n\n这时候就需要一个比前者好的解决方案来解决该问题,ES6中的Promise一定程度上解决了该问题:\n\n我们可以利用Promise对ajax进行一层封装\n\n    function _ajax(url, method, args) {\n        let promise = new Promise((resolve, reject) => {\n\n            let client = new XMLHttpRequest();\n            let uri = url;\n\n            if (args && (method == \"POST\" || method == \"PUT\")) {\n                let argcount = 0;\n                uri += \"?\";\n                for (var key in args) {\n                    if (args.hasOwnProperty(key)) {\n                        if (argcount++) {\n                            uri += '&';\n                        }\n                        uri += encodeURIComponent(key) + '=' + encodeURIComponent(args[key]);\n                    }\n                }\n            }\n\n            client.open(method, uri);\n            client.send();\n\n            client.onload = function() {\n                if (this.status >= 200 && this.status < 300) {\n                    resolve(this.response);\n                } else {\n                    reject(this.statusText);\n                }\n            };\n            client.onerror = function() {\n                reject(this.statusText);\n            };\n\n        });\n\n        return promise;\n    }\n\n    let core = {\n\n        \"GET\": function(args) {\n            return _ajax(url, \"GET\", args);\n        },\n\n        \"POST\": function(args) {\n            return _ajax(url, \"POST\", args);\n        },\n\n        \"PUT\": function(args) {\n            return _ajax(url, \"PUT\", args);\n        },\n\n        \"DELETE\": function(args) {\n            return _ajax(url, \"DELETE\", args);\n        }\n\n    };\n\n上面这段代码是JavaScript MDN上的代码(可能稍微有点改动),它对ajax进行了一层封装,经过这层封装,我们可以像下面这样写一些异步代码:\n\n    $http(\"xxx\")\n    .GET()\n    .then((data) => {\n        \n        //  do something\n        \n        $http(\"xxx2\")\n        .GET()\n        .then((data) => {\n        \n            //  do something\n            \n            $http(\"xxx3\")\n            .GET({\"key\",\"value\"})\n            .then((data) => {\n                //  do something...\n            })\n            \n            \n        },(ex) => {});\n        \n    })\n    .catch((ex) => {});\n\n虽然还有嵌套,但是代码看起来已经舒服了很多。\n\nPromise是一个异步编程的抽象,它是一个返回值或抛出exception的代理对象,一般promise对象都有一个then方法,这个then方法是我们如何获得返回值(成功实现承诺的结果值,称为fulfillment)或抛出exception(拒绝承诺的理由,称为rejection)，then是用两个可选的回调作为参数,我们可以称为onFulfilled和OnRejected,也可以把OnRejected写在catch里面\n\n所以一个Promise一共有下面几个状态\n\n1. pending待承诺 - promise初始状态\n2. fulfilled实现承诺 - 一个承诺成功实现状态\n3. rejected拒绝承诺 - 一个承诺失败的状态\n\n再来个NodeJs中读取文件的例子:\n\n    function readFile(path) {\n        var fs = require(\"fs\");\n        var prromise = new Promise((resolve, reject) => {\n            fs.readdir(path, (ex, files) => {\n                if (ex) {\n                    return reject(ex);\n                }\n                return resolve(files);\n            });\n        });\n        \n        return prromise;\n    }\n\n    readFile(config.avatarPath + \"1\").then((files) => {\n        //  do some thing\n        console.log(files);\n    }).catch((ex) => {\n        //  do something...\n        console.log(ex);\n    });\n    \n如果不用Promise和一些ES6的特性,上面的代码应该看起来是下面的这样子:\n\n    var fs = require(\"fs\");\n    fs.readdir(path, function (ex, files) {\n        if (ex) {\n            //  do something\n            return console.log();\n        }\n        \n        //  do some thing\n        console.log(files);\n    });\n\n代码量可能更少,但是陷入\"回调地狱\"的可能就更大了,在ES7中,又新增了async/await特性来针对异步操作的,后面介绍😄\n\n","slug":"2016-05-04-es6-promise","published":1,"updated":"2016-11-09T14:02:05.000Z","_id":"civ7fseft001jt95ffb41ghaq","comments":1,"photos":[],"link":"","content":"<p>在执行一些异步操作(典型的有JavaScript中的ajax/NodeJs中读取文件等等)的时候,我们不知道该操作什么时候完成,所以就需要在不同的时候写上回调,等到有返回的时候,再执行下一步操作,下面就用jQuery中的一个ajax来做示例:</p>\n<pre><code>$.ajax({\n    &quot;url&quot;: &quot;xxx&quot;,\n    &quot;type&quot;: &quot;GET&quot;,\n    &quot;dataType&quot;: &quot;&quot;JSON,\n    &quot;success&quot;: function(res){},\n    &quot;error&quot;: function(ex){\n        //  do some thing\n    }\n});\n</code></pre><p>最基础的一个ajax示例,当我们有多个ajax嵌套请求的时候,就中了所谓的”回调地狱”,类似于下面的写法:</p>\n<pre><code>$.ajax({\n    //  some configs\n    &quot;success&quot;: function(res){\n        $.ajax({\n            //  ...\n            &quot;success&quot;: function(res){\n                $.ajax({\n                    //  ...\n                    &quot;success&quot;:function(res){\n                        .\n                        .\n                        .\n                    }\n                });\n            }\n        });\n    }\n});\n</code></pre><p>一层套着一层,代码可读性很差,且不容易后期的维护</p>\n<p>这时候就需要一个比前者好的解决方案来解决该问题,ES6中的Promise一定程度上解决了该问题:</p>\n<p>我们可以利用Promise对ajax进行一层封装</p>\n<pre><code>function _ajax(url, method, args) {\n    let promise = new Promise((resolve, reject) =&gt; {\n\n        let client = new XMLHttpRequest();\n        let uri = url;\n\n        if (args &amp;&amp; (method == &quot;POST&quot; || method == &quot;PUT&quot;)) {\n            let argcount = 0;\n            uri += &quot;?&quot;;\n            for (var key in args) {\n                if (args.hasOwnProperty(key)) {\n                    if (argcount++) {\n                        uri += &apos;&amp;&apos;;\n                    }\n                    uri += encodeURIComponent(key) + &apos;=&apos; + encodeURIComponent(args[key]);\n                }\n            }\n        }\n\n        client.open(method, uri);\n        client.send();\n\n        client.onload = function() {\n            if (this.status &gt;= 200 &amp;&amp; this.status &lt; 300) {\n                resolve(this.response);\n            } else {\n                reject(this.statusText);\n            }\n        };\n        client.onerror = function() {\n            reject(this.statusText);\n        };\n\n    });\n\n    return promise;\n}\n\nlet core = {\n\n    &quot;GET&quot;: function(args) {\n        return _ajax(url, &quot;GET&quot;, args);\n    },\n\n    &quot;POST&quot;: function(args) {\n        return _ajax(url, &quot;POST&quot;, args);\n    },\n\n    &quot;PUT&quot;: function(args) {\n        return _ajax(url, &quot;PUT&quot;, args);\n    },\n\n    &quot;DELETE&quot;: function(args) {\n        return _ajax(url, &quot;DELETE&quot;, args);\n    }\n\n};\n</code></pre><p>上面这段代码是JavaScript MDN上的代码(可能稍微有点改动),它对ajax进行了一层封装,经过这层封装,我们可以像下面这样写一些异步代码:</p>\n<pre><code>$http(&quot;xxx&quot;)\n.GET()\n.then((data) =&gt; {\n\n    //  do something\n\n    $http(&quot;xxx2&quot;)\n    .GET()\n    .then((data) =&gt; {\n\n        //  do something\n\n        $http(&quot;xxx3&quot;)\n        .GET({&quot;key&quot;,&quot;value&quot;})\n        .then((data) =&gt; {\n            //  do something...\n        })\n\n\n    },(ex) =&gt; {});\n\n})\n.catch((ex) =&gt; {});\n</code></pre><p>虽然还有嵌套,但是代码看起来已经舒服了很多。</p>\n<p>Promise是一个异步编程的抽象,它是一个返回值或抛出exception的代理对象,一般promise对象都有一个then方法,这个then方法是我们如何获得返回值(成功实现承诺的结果值,称为fulfillment)或抛出exception(拒绝承诺的理由,称为rejection)，then是用两个可选的回调作为参数,我们可以称为onFulfilled和OnRejected,也可以把OnRejected写在catch里面</p>\n<p>所以一个Promise一共有下面几个状态</p>\n<ol>\n<li>pending待承诺 - promise初始状态</li>\n<li>fulfilled实现承诺 - 一个承诺成功实现状态</li>\n<li>rejected拒绝承诺 - 一个承诺失败的状态</li>\n</ol>\n<p>再来个NodeJs中读取文件的例子:</p>\n<pre><code>function readFile(path) {\n    var fs = require(&quot;fs&quot;);\n    var prromise = new Promise((resolve, reject) =&gt; {\n        fs.readdir(path, (ex, files) =&gt; {\n            if (ex) {\n                return reject(ex);\n            }\n            return resolve(files);\n        });\n    });\n\n    return prromise;\n}\n\nreadFile(config.avatarPath + &quot;1&quot;).then((files) =&gt; {\n    //  do some thing\n    console.log(files);\n}).catch((ex) =&gt; {\n    //  do something...\n    console.log(ex);\n});\n</code></pre><p>如果不用Promise和一些ES6的特性,上面的代码应该看起来是下面的这样子:</p>\n<pre><code>var fs = require(&quot;fs&quot;);\nfs.readdir(path, function (ex, files) {\n    if (ex) {\n        //  do something\n        return console.log();\n    }\n\n    //  do some thing\n    console.log(files);\n});\n</code></pre><p>代码量可能更少,但是陷入”回调地狱”的可能就更大了,在ES7中,又新增了async/await特性来针对异步操作的,后面介绍😄</p>\n","excerpt":"","more":"<p>在执行一些异步操作(典型的有JavaScript中的ajax/NodeJs中读取文件等等)的时候,我们不知道该操作什么时候完成,所以就需要在不同的时候写上回调,等到有返回的时候,再执行下一步操作,下面就用jQuery中的一个ajax来做示例:</p>\n<pre><code>$.ajax({\n    &quot;url&quot;: &quot;xxx&quot;,\n    &quot;type&quot;: &quot;GET&quot;,\n    &quot;dataType&quot;: &quot;&quot;JSON,\n    &quot;success&quot;: function(res){},\n    &quot;error&quot;: function(ex){\n        //  do some thing\n    }\n});\n</code></pre><p>最基础的一个ajax示例,当我们有多个ajax嵌套请求的时候,就中了所谓的”回调地狱”,类似于下面的写法:</p>\n<pre><code>$.ajax({\n    //  some configs\n    &quot;success&quot;: function(res){\n        $.ajax({\n            //  ...\n            &quot;success&quot;: function(res){\n                $.ajax({\n                    //  ...\n                    &quot;success&quot;:function(res){\n                        .\n                        .\n                        .\n                    }\n                });\n            }\n        });\n    }\n});\n</code></pre><p>一层套着一层,代码可读性很差,且不容易后期的维护</p>\n<p>这时候就需要一个比前者好的解决方案来解决该问题,ES6中的Promise一定程度上解决了该问题:</p>\n<p>我们可以利用Promise对ajax进行一层封装</p>\n<pre><code>function _ajax(url, method, args) {\n    let promise = new Promise((resolve, reject) =&gt; {\n\n        let client = new XMLHttpRequest();\n        let uri = url;\n\n        if (args &amp;&amp; (method == &quot;POST&quot; || method == &quot;PUT&quot;)) {\n            let argcount = 0;\n            uri += &quot;?&quot;;\n            for (var key in args) {\n                if (args.hasOwnProperty(key)) {\n                    if (argcount++) {\n                        uri += &apos;&amp;&apos;;\n                    }\n                    uri += encodeURIComponent(key) + &apos;=&apos; + encodeURIComponent(args[key]);\n                }\n            }\n        }\n\n        client.open(method, uri);\n        client.send();\n\n        client.onload = function() {\n            if (this.status &gt;= 200 &amp;&amp; this.status &lt; 300) {\n                resolve(this.response);\n            } else {\n                reject(this.statusText);\n            }\n        };\n        client.onerror = function() {\n            reject(this.statusText);\n        };\n\n    });\n\n    return promise;\n}\n\nlet core = {\n\n    &quot;GET&quot;: function(args) {\n        return _ajax(url, &quot;GET&quot;, args);\n    },\n\n    &quot;POST&quot;: function(args) {\n        return _ajax(url, &quot;POST&quot;, args);\n    },\n\n    &quot;PUT&quot;: function(args) {\n        return _ajax(url, &quot;PUT&quot;, args);\n    },\n\n    &quot;DELETE&quot;: function(args) {\n        return _ajax(url, &quot;DELETE&quot;, args);\n    }\n\n};\n</code></pre><p>上面这段代码是JavaScript MDN上的代码(可能稍微有点改动),它对ajax进行了一层封装,经过这层封装,我们可以像下面这样写一些异步代码:</p>\n<pre><code>$http(&quot;xxx&quot;)\n.GET()\n.then((data) =&gt; {\n\n    //  do something\n\n    $http(&quot;xxx2&quot;)\n    .GET()\n    .then((data) =&gt; {\n\n        //  do something\n\n        $http(&quot;xxx3&quot;)\n        .GET({&quot;key&quot;,&quot;value&quot;})\n        .then((data) =&gt; {\n            //  do something...\n        })\n\n\n    },(ex) =&gt; {});\n\n})\n.catch((ex) =&gt; {});\n</code></pre><p>虽然还有嵌套,但是代码看起来已经舒服了很多。</p>\n<p>Promise是一个异步编程的抽象,它是一个返回值或抛出exception的代理对象,一般promise对象都有一个then方法,这个then方法是我们如何获得返回值(成功实现承诺的结果值,称为fulfillment)或抛出exception(拒绝承诺的理由,称为rejection)，then是用两个可选的回调作为参数,我们可以称为onFulfilled和OnRejected,也可以把OnRejected写在catch里面</p>\n<p>所以一个Promise一共有下面几个状态</p>\n<ol>\n<li>pending待承诺 - promise初始状态</li>\n<li>fulfilled实现承诺 - 一个承诺成功实现状态</li>\n<li>rejected拒绝承诺 - 一个承诺失败的状态</li>\n</ol>\n<p>再来个NodeJs中读取文件的例子:</p>\n<pre><code>function readFile(path) {\n    var fs = require(&quot;fs&quot;);\n    var prromise = new Promise((resolve, reject) =&gt; {\n        fs.readdir(path, (ex, files) =&gt; {\n            if (ex) {\n                return reject(ex);\n            }\n            return resolve(files);\n        });\n    });\n\n    return prromise;\n}\n\nreadFile(config.avatarPath + &quot;1&quot;).then((files) =&gt; {\n    //  do some thing\n    console.log(files);\n}).catch((ex) =&gt; {\n    //  do something...\n    console.log(ex);\n});\n</code></pre><p>如果不用Promise和一些ES6的特性,上面的代码应该看起来是下面的这样子:</p>\n<pre><code>var fs = require(&quot;fs&quot;);\nfs.readdir(path, function (ex, files) {\n    if (ex) {\n        //  do something\n        return console.log();\n    }\n\n    //  do some thing\n    console.log(files);\n});\n</code></pre><p>代码量可能更少,但是陷入”回调地狱”的可能就更大了,在ES7中,又新增了async/await特性来针对异步操作的,后面介绍😄</p>\n"},{"layout":"post","title":"检测数据变化","date":"2016-06-22T16:00:00.000Z","_content":"\nMVVM一直是最近几年的很火的一个词之一,以angularjs和Vue为代表的都是这种模式,但是实现完全不同。Vue是通过ES5中的新增方法Object.defineProperty并且给该属性指定getter/setter(setter上调用observe方法)方法来实现的;而angularjs中则是通过脏检查来实现该模式,也就是对所有数据当都调用一个轮询($digest),然后比对每个属性值,如果发生变化,就调用相应的处理回调函数,这种方式的缺点显而易见,当数据达到一定数量时候,处理起来就显得笨重吃力,个人觉得可以给整个数据提供一个setData方法,传入需要设置的新数据,然后内部做一个深拷贝,这样就只需要把新设置的数据和原来的数据进行对比,在性能上应该优于给所有数据轮询的方式。下面是具体实现:\n\n    var _class2 = {};\n\n    function Vm() {\n    }\n\n    Vm.prototype = {\n\n        \"constructor\": Vm,\n\n        //  外部调用setData\n        \"setData\": function (data) {\n        \n            //  初始化数据\n            if (!this.data) {\n                this.data = data;\n                console.log(\"initialize data\");\n            } else {\n            \n                //  深拷贝老数据,不然可能造成oldData指向新数据的问题\n                var oldData = _copy(this.data, true);\n                \n                for (var i in data) {\n                    if (data.hasOwnProperty(i)) {\n                        this.data[i] = data[i];\n                    }\n                }\n                \n                //  获取比对结果(新设置的数据)\n                var res = this.compareData(oldData, data);\n                \n                //  数据发生变化,打印出变化前后的数据\n                if (res.isChanged) {\n                    for (var j in res) {\n                        if (j !== \"isChanged\" && res.hasOwnProperty(j)) {\n                            console.group(\"data changed\");\n                            console.log(\"new data:\");\n                            console.log(res[j][\"newData\"]);\n                            console.log(\"old data:\");\n                            console.log(res[j][\"oldData\"]);\n                            console.groupEnd(\"data changed\");\n                        }\n                    }\n                } else {\n                    console.log(\"data is not change!\");\n                }\n            }\n        },\n\n        //  数据比对方法,在setData中自动调用\n        \"compareData\": function (oldData, newData) {\n            var res = {\n                \"isChanged\": false\n            };\n\n            //  遍历每一项\n            for (var i in newData) {\n                var oldVal = oldData[i];\n                var curVal = newData[i];\n\n                //  不相等情况\n                if (!_eq(oldVal, curVal, [], [])) {\n                    res.isChanged = true;\n                    \n                    //  保存新数据和老数据\n                    res[i] = {\n                        \"newData\": curVal,\n                        \"oldData\": oldVal\n                    };\n                }\n            }\n            return res;\n        }\n\n    };\n\n    /**\n     * 深度判断两个对象是否相等(摘自underscore中的eq方法)\n     * @param a         第一个个对象\n     * @param b         第二个对象\n     * @param aStack    第一个栈\n     * @param bStack    第二个栈\n     * @returns {boolean}\n     * @private\n     */\n    function _eq(a, b, aStack, bStack) {\n\n        // 获取第一个对象原型上的类名\n        var className = _class2.toString.call(a);\n\n        /**\n         * 检查两个基本数据类型的值是否相等\n         * 对于引用数据类型,如果它们来自同一个引用(同一个对象进行比较),则认为其相等\n         * 需要注意的是0 === -0的结果为true,所以后面的1 / a 和 1  / b 是来判断0 和 -0 的情况(1 / -0 = -Infinity) != (1 / 0 = Infinity)\n         */\n        if (a === b) return a !== 0 || 1 / a == 1 / b;\n\n        /**\n         * 处理undefined 和 null的情况\n         * undefined == null 的结果为true,而undefined === null 的结果为false\n         */\n        if (a == null || b == null) return a === b;\n\n        // 两个类名不同,直接返回false\n        if (className != _class2.toString.call(b)) return false;\n\n        switch (className) {\n            case '[object String]':\n\n                /**\n                 * toString.call(\"str\") == \"[object String]\" -> true\n                 * toString.call(String(\"str\")) == \"[object String]\" -> true\n                 * toString.call(new String(\"str\")) == \"[object String]\" -> true\n                 */\n                return a == (\"\" + b);\n            case '[object Number]':\n\n                /**\n                 * +a 会把 a转换成一个数字,如果转换结果和原来不同则被认为NaN\n                 * NaN != NaN,因此当a和b同时为NaN时,无法简单地使用a == b进行匹配,用相同的方法检查b是否为NaN(即 b != +b)\n                 * 和刚进方法体一样,判断0和-0的情况\n                 */\n                return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n            case '[object Date]':\n            case '[object Boolean]':\n\n                /**\n                 * 把bool和date类型转换成对应的数字来比较\n                 * +true -> 1 / +false -> 0 / +(new Date()) -> (new Date()).getTime()\n                 */\n                return +a == +b;\n            case '[object RegExp]':\n\n                //  匹配正则表达式的相关属性是否相同(元字符串/全局匹配/多行模式/忽略大小写)\n                return a.source == b.source &&\n                    a.global == b.global &&\n                    a.multiline == b.multiline &&\n                    a.ignoreCase == b.ignoreCase;\n        }\n\n        //  处理数组类型或对象类型(typeof [] = typeof {} = \"object\")\n        if (typeof a != 'object' || typeof b != 'object') return false;\n\n        //  在isEqual方法中传递的是空数组\n        //  在方法体内部,判断的会再次进行传递被操作后的a堆和b堆\n        var length = aStack.length;\n\n        while (length--) {\n            // 如果堆中的某个对象与数据a匹配,则再判断另一个堆中相同位置的对象是否等于第二个对象\n            if (aStack[length] == a) return bStack[length] == b;\n        }\n\n        // 获取两个对象的构造器\n        var aCtor = a.constructor, bCtor = b.constructor;\n\n        //  判断两个对象如果不是不是同一个类的实例则认为不相等\n        if (aCtor !== bCtor && !(_isType(bCtor, \"function\") &&\n            (aCtor instanceof aCtor) &&\n            _isType(bCtor, \"function\") &&\n            (bCtor instanceof bCtor))) {\n            return false;\n        }\n\n        // 把a和b分别放到a堆和b堆中\n        aStack.push(a);\n        bStack.push(b);\n\n        //  局部变量\n        var size = 0, result = true;\n\n        // 数组类型比较\n        if (className == '[object Array]') {\n            size = a.length;\n\n            //  比较两个数组的长度是否相等\n            result = size == b.length;\n\n            //  如果长度相同,再依次比较数组的每项\n            if (result) {\n                while (size--) {\n                    if (!(result = _eq(a[size], b[size], aStack, bStack))) break;\n                }\n            }\n        } else {\n\n            // 如果是对象类型,枚举第一个对象,判断b和a中的每个属性值是否相同,记录a中属性值的个数\n            for (var key in a) {\n                if (a.hasOwnProperty(key)) {\n                    size++;\n                    if (!(result = b.hasOwnProperty(key) && _eq(a[key], b[key], aStack, bStack))) break;\n                }\n            }\n\n            /**\n             * 如果a中有的属性b中都有\n             * 再枚举b对象,判断长度,如果b中属性值的长度大于size则result为false(!1 = false / !0 = true)\n             */\n            if (result) {\n                for (key in b) {\n                    if (b.hasOwnProperty(key) && !(size--)) break;\n                }\n\n                // 当对象b中的属性多于对象a, 则认为两个对象不相等\n                result = !size;\n            }\n        }\n\n        // 删除堆中的数据,防止再进行迭代\n        aStack.pop();\n        bStack.pop();\n\n        //  返回比较结果\n        return result;\n    }\n\n    /**\n     * 拷贝一个对象(摘自underscore中的copy方法)\n     * @param obj   被拷贝的对象\n     * @param deep  是否深拷贝\n     * @returns {*}\n     * @private\n     */\n    function _copy(obj, deep) {\n        //  typeof []/{} -> \"object\"\n        var copied;\n        if (!deep || obj == null || typeof obj !== \"object\") {\n            return obj;\n        }\n        var copied;\n        if (_isType(obj, \"Object\")) {\n            copied = {};\n        } else if (_isType(obj, \"Array\")) {\n            copied = [];\n        }\n        for (var i in obj) {\n            if (obj.hasOwnProperty(i)) {\n                copied[i] = obj[i];\n            }\n        }\n        return copied;\n    }\n\n    /**\n     * 判断一个对象是否为指定类型\n     * @param obj           被判断的对象\n     * @param typeStr       类型字符串\n     * @returns {boolean}\n     * @private\n     */\n    function _isType(obj, typeStr) {\n        return _class2.toString.call(obj).toLowerCase() === (\"[object \" + typeStr + \"]\").toLowerCase();\n    }\n\nHTML中则可以如下调用:\n\n    var vm = new Vm();\n    vm.setData({\n        \"arr\": [1,2,4],\n        \"obj\": {\n            \"name\": \"son\",\n            \"age\": 23\n        }\n    });\n\n    vm.setData({\n        \"arr\": [1,2,3,4],\n        \"obj\": {\n            \"name\": \"rwson\",\n            \"age\": 24\n        },\n        \"added\": \"new add data\"\n    });\n        \n \n最后控制台输出信息如下图所示:\n\n![result](/imgs/watch-data-change.png)","source":"_posts/2016-06-23-watch-data-change.md","raw":"---\nlayout: post\ntitle: 检测数据变化\ndate: 2016-06-23\ncategories: [javascript]\n---\n\nMVVM一直是最近几年的很火的一个词之一,以angularjs和Vue为代表的都是这种模式,但是实现完全不同。Vue是通过ES5中的新增方法Object.defineProperty并且给该属性指定getter/setter(setter上调用observe方法)方法来实现的;而angularjs中则是通过脏检查来实现该模式,也就是对所有数据当都调用一个轮询($digest),然后比对每个属性值,如果发生变化,就调用相应的处理回调函数,这种方式的缺点显而易见,当数据达到一定数量时候,处理起来就显得笨重吃力,个人觉得可以给整个数据提供一个setData方法,传入需要设置的新数据,然后内部做一个深拷贝,这样就只需要把新设置的数据和原来的数据进行对比,在性能上应该优于给所有数据轮询的方式。下面是具体实现:\n\n    var _class2 = {};\n\n    function Vm() {\n    }\n\n    Vm.prototype = {\n\n        \"constructor\": Vm,\n\n        //  外部调用setData\n        \"setData\": function (data) {\n        \n            //  初始化数据\n            if (!this.data) {\n                this.data = data;\n                console.log(\"initialize data\");\n            } else {\n            \n                //  深拷贝老数据,不然可能造成oldData指向新数据的问题\n                var oldData = _copy(this.data, true);\n                \n                for (var i in data) {\n                    if (data.hasOwnProperty(i)) {\n                        this.data[i] = data[i];\n                    }\n                }\n                \n                //  获取比对结果(新设置的数据)\n                var res = this.compareData(oldData, data);\n                \n                //  数据发生变化,打印出变化前后的数据\n                if (res.isChanged) {\n                    for (var j in res) {\n                        if (j !== \"isChanged\" && res.hasOwnProperty(j)) {\n                            console.group(\"data changed\");\n                            console.log(\"new data:\");\n                            console.log(res[j][\"newData\"]);\n                            console.log(\"old data:\");\n                            console.log(res[j][\"oldData\"]);\n                            console.groupEnd(\"data changed\");\n                        }\n                    }\n                } else {\n                    console.log(\"data is not change!\");\n                }\n            }\n        },\n\n        //  数据比对方法,在setData中自动调用\n        \"compareData\": function (oldData, newData) {\n            var res = {\n                \"isChanged\": false\n            };\n\n            //  遍历每一项\n            for (var i in newData) {\n                var oldVal = oldData[i];\n                var curVal = newData[i];\n\n                //  不相等情况\n                if (!_eq(oldVal, curVal, [], [])) {\n                    res.isChanged = true;\n                    \n                    //  保存新数据和老数据\n                    res[i] = {\n                        \"newData\": curVal,\n                        \"oldData\": oldVal\n                    };\n                }\n            }\n            return res;\n        }\n\n    };\n\n    /**\n     * 深度判断两个对象是否相等(摘自underscore中的eq方法)\n     * @param a         第一个个对象\n     * @param b         第二个对象\n     * @param aStack    第一个栈\n     * @param bStack    第二个栈\n     * @returns {boolean}\n     * @private\n     */\n    function _eq(a, b, aStack, bStack) {\n\n        // 获取第一个对象原型上的类名\n        var className = _class2.toString.call(a);\n\n        /**\n         * 检查两个基本数据类型的值是否相等\n         * 对于引用数据类型,如果它们来自同一个引用(同一个对象进行比较),则认为其相等\n         * 需要注意的是0 === -0的结果为true,所以后面的1 / a 和 1  / b 是来判断0 和 -0 的情况(1 / -0 = -Infinity) != (1 / 0 = Infinity)\n         */\n        if (a === b) return a !== 0 || 1 / a == 1 / b;\n\n        /**\n         * 处理undefined 和 null的情况\n         * undefined == null 的结果为true,而undefined === null 的结果为false\n         */\n        if (a == null || b == null) return a === b;\n\n        // 两个类名不同,直接返回false\n        if (className != _class2.toString.call(b)) return false;\n\n        switch (className) {\n            case '[object String]':\n\n                /**\n                 * toString.call(\"str\") == \"[object String]\" -> true\n                 * toString.call(String(\"str\")) == \"[object String]\" -> true\n                 * toString.call(new String(\"str\")) == \"[object String]\" -> true\n                 */\n                return a == (\"\" + b);\n            case '[object Number]':\n\n                /**\n                 * +a 会把 a转换成一个数字,如果转换结果和原来不同则被认为NaN\n                 * NaN != NaN,因此当a和b同时为NaN时,无法简单地使用a == b进行匹配,用相同的方法检查b是否为NaN(即 b != +b)\n                 * 和刚进方法体一样,判断0和-0的情况\n                 */\n                return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n            case '[object Date]':\n            case '[object Boolean]':\n\n                /**\n                 * 把bool和date类型转换成对应的数字来比较\n                 * +true -> 1 / +false -> 0 / +(new Date()) -> (new Date()).getTime()\n                 */\n                return +a == +b;\n            case '[object RegExp]':\n\n                //  匹配正则表达式的相关属性是否相同(元字符串/全局匹配/多行模式/忽略大小写)\n                return a.source == b.source &&\n                    a.global == b.global &&\n                    a.multiline == b.multiline &&\n                    a.ignoreCase == b.ignoreCase;\n        }\n\n        //  处理数组类型或对象类型(typeof [] = typeof {} = \"object\")\n        if (typeof a != 'object' || typeof b != 'object') return false;\n\n        //  在isEqual方法中传递的是空数组\n        //  在方法体内部,判断的会再次进行传递被操作后的a堆和b堆\n        var length = aStack.length;\n\n        while (length--) {\n            // 如果堆中的某个对象与数据a匹配,则再判断另一个堆中相同位置的对象是否等于第二个对象\n            if (aStack[length] == a) return bStack[length] == b;\n        }\n\n        // 获取两个对象的构造器\n        var aCtor = a.constructor, bCtor = b.constructor;\n\n        //  判断两个对象如果不是不是同一个类的实例则认为不相等\n        if (aCtor !== bCtor && !(_isType(bCtor, \"function\") &&\n            (aCtor instanceof aCtor) &&\n            _isType(bCtor, \"function\") &&\n            (bCtor instanceof bCtor))) {\n            return false;\n        }\n\n        // 把a和b分别放到a堆和b堆中\n        aStack.push(a);\n        bStack.push(b);\n\n        //  局部变量\n        var size = 0, result = true;\n\n        // 数组类型比较\n        if (className == '[object Array]') {\n            size = a.length;\n\n            //  比较两个数组的长度是否相等\n            result = size == b.length;\n\n            //  如果长度相同,再依次比较数组的每项\n            if (result) {\n                while (size--) {\n                    if (!(result = _eq(a[size], b[size], aStack, bStack))) break;\n                }\n            }\n        } else {\n\n            // 如果是对象类型,枚举第一个对象,判断b和a中的每个属性值是否相同,记录a中属性值的个数\n            for (var key in a) {\n                if (a.hasOwnProperty(key)) {\n                    size++;\n                    if (!(result = b.hasOwnProperty(key) && _eq(a[key], b[key], aStack, bStack))) break;\n                }\n            }\n\n            /**\n             * 如果a中有的属性b中都有\n             * 再枚举b对象,判断长度,如果b中属性值的长度大于size则result为false(!1 = false / !0 = true)\n             */\n            if (result) {\n                for (key in b) {\n                    if (b.hasOwnProperty(key) && !(size--)) break;\n                }\n\n                // 当对象b中的属性多于对象a, 则认为两个对象不相等\n                result = !size;\n            }\n        }\n\n        // 删除堆中的数据,防止再进行迭代\n        aStack.pop();\n        bStack.pop();\n\n        //  返回比较结果\n        return result;\n    }\n\n    /**\n     * 拷贝一个对象(摘自underscore中的copy方法)\n     * @param obj   被拷贝的对象\n     * @param deep  是否深拷贝\n     * @returns {*}\n     * @private\n     */\n    function _copy(obj, deep) {\n        //  typeof []/{} -> \"object\"\n        var copied;\n        if (!deep || obj == null || typeof obj !== \"object\") {\n            return obj;\n        }\n        var copied;\n        if (_isType(obj, \"Object\")) {\n            copied = {};\n        } else if (_isType(obj, \"Array\")) {\n            copied = [];\n        }\n        for (var i in obj) {\n            if (obj.hasOwnProperty(i)) {\n                copied[i] = obj[i];\n            }\n        }\n        return copied;\n    }\n\n    /**\n     * 判断一个对象是否为指定类型\n     * @param obj           被判断的对象\n     * @param typeStr       类型字符串\n     * @returns {boolean}\n     * @private\n     */\n    function _isType(obj, typeStr) {\n        return _class2.toString.call(obj).toLowerCase() === (\"[object \" + typeStr + \"]\").toLowerCase();\n    }\n\nHTML中则可以如下调用:\n\n    var vm = new Vm();\n    vm.setData({\n        \"arr\": [1,2,4],\n        \"obj\": {\n            \"name\": \"son\",\n            \"age\": 23\n        }\n    });\n\n    vm.setData({\n        \"arr\": [1,2,3,4],\n        \"obj\": {\n            \"name\": \"rwson\",\n            \"age\": 24\n        },\n        \"added\": \"new add data\"\n    });\n        \n \n最后控制台输出信息如下图所示:\n\n![result](/imgs/watch-data-change.png)","slug":"2016-06-23-watch-data-change","published":1,"updated":"2016-11-07T02:19:51.000Z","_id":"civ7fsefu001mt95f4bbtir1b","comments":1,"photos":[],"link":"","content":"<p>MVVM一直是最近几年的很火的一个词之一,以angularjs和Vue为代表的都是这种模式,但是实现完全不同。Vue是通过ES5中的新增方法Object.defineProperty并且给该属性指定getter/setter(setter上调用observe方法)方法来实现的;而angularjs中则是通过脏检查来实现该模式,也就是对所有数据当都调用一个轮询($digest),然后比对每个属性值,如果发生变化,就调用相应的处理回调函数,这种方式的缺点显而易见,当数据达到一定数量时候,处理起来就显得笨重吃力,个人觉得可以给整个数据提供一个setData方法,传入需要设置的新数据,然后内部做一个深拷贝,这样就只需要把新设置的数据和原来的数据进行对比,在性能上应该优于给所有数据轮询的方式。下面是具体实现:</p>\n<pre><code>var _class2 = {};\n\nfunction Vm() {\n}\n\nVm.prototype = {\n\n    &quot;constructor&quot;: Vm,\n\n    //  外部调用setData\n    &quot;setData&quot;: function (data) {\n\n        //  初始化数据\n        if (!this.data) {\n            this.data = data;\n            console.log(&quot;initialize data&quot;);\n        } else {\n\n            //  深拷贝老数据,不然可能造成oldData指向新数据的问题\n            var oldData = _copy(this.data, true);\n\n            for (var i in data) {\n                if (data.hasOwnProperty(i)) {\n                    this.data[i] = data[i];\n                }\n            }\n\n            //  获取比对结果(新设置的数据)\n            var res = this.compareData(oldData, data);\n\n            //  数据发生变化,打印出变化前后的数据\n            if (res.isChanged) {\n                for (var j in res) {\n                    if (j !== &quot;isChanged&quot; &amp;&amp; res.hasOwnProperty(j)) {\n                        console.group(&quot;data changed&quot;);\n                        console.log(&quot;new data:&quot;);\n                        console.log(res[j][&quot;newData&quot;]);\n                        console.log(&quot;old data:&quot;);\n                        console.log(res[j][&quot;oldData&quot;]);\n                        console.groupEnd(&quot;data changed&quot;);\n                    }\n                }\n            } else {\n                console.log(&quot;data is not change!&quot;);\n            }\n        }\n    },\n\n    //  数据比对方法,在setData中自动调用\n    &quot;compareData&quot;: function (oldData, newData) {\n        var res = {\n            &quot;isChanged&quot;: false\n        };\n\n        //  遍历每一项\n        for (var i in newData) {\n            var oldVal = oldData[i];\n            var curVal = newData[i];\n\n            //  不相等情况\n            if (!_eq(oldVal, curVal, [], [])) {\n                res.isChanged = true;\n\n                //  保存新数据和老数据\n                res[i] = {\n                    &quot;newData&quot;: curVal,\n                    &quot;oldData&quot;: oldVal\n                };\n            }\n        }\n        return res;\n    }\n\n};\n\n/**\n * 深度判断两个对象是否相等(摘自underscore中的eq方法)\n * @param a         第一个个对象\n * @param b         第二个对象\n * @param aStack    第一个栈\n * @param bStack    第二个栈\n * @returns {boolean}\n * @private\n */\nfunction _eq(a, b, aStack, bStack) {\n\n    // 获取第一个对象原型上的类名\n    var className = _class2.toString.call(a);\n\n    /**\n     * 检查两个基本数据类型的值是否相等\n     * 对于引用数据类型,如果它们来自同一个引用(同一个对象进行比较),则认为其相等\n     * 需要注意的是0 === -0的结果为true,所以后面的1 / a 和 1  / b 是来判断0 和 -0 的情况(1 / -0 = -Infinity) != (1 / 0 = Infinity)\n     */\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n\n    /**\n     * 处理undefined 和 null的情况\n     * undefined == null 的结果为true,而undefined === null 的结果为false\n     */\n    if (a == null || b == null) return a === b;\n\n    // 两个类名不同,直接返回false\n    if (className != _class2.toString.call(b)) return false;\n\n    switch (className) {\n        case &apos;[object String]&apos;:\n\n            /**\n             * toString.call(&quot;str&quot;) == &quot;[object String]&quot; -&gt; true\n             * toString.call(String(&quot;str&quot;)) == &quot;[object String]&quot; -&gt; true\n             * toString.call(new String(&quot;str&quot;)) == &quot;[object String]&quot; -&gt; true\n             */\n            return a == (&quot;&quot; + b);\n        case &apos;[object Number]&apos;:\n\n            /**\n             * +a 会把 a转换成一个数字,如果转换结果和原来不同则被认为NaN\n             * NaN != NaN,因此当a和b同时为NaN时,无法简单地使用a == b进行匹配,用相同的方法检查b是否为NaN(即 b != +b)\n             * 和刚进方法体一样,判断0和-0的情况\n             */\n            return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n        case &apos;[object Date]&apos;:\n        case &apos;[object Boolean]&apos;:\n\n            /**\n             * 把bool和date类型转换成对应的数字来比较\n             * +true -&gt; 1 / +false -&gt; 0 / +(new Date()) -&gt; (new Date()).getTime()\n             */\n            return +a == +b;\n        case &apos;[object RegExp]&apos;:\n\n            //  匹配正则表达式的相关属性是否相同(元字符串/全局匹配/多行模式/忽略大小写)\n            return a.source == b.source &amp;&amp;\n                a.global == b.global &amp;&amp;\n                a.multiline == b.multiline &amp;&amp;\n                a.ignoreCase == b.ignoreCase;\n    }\n\n    //  处理数组类型或对象类型(typeof [] = typeof {} = &quot;object&quot;)\n    if (typeof a != &apos;object&apos; || typeof b != &apos;object&apos;) return false;\n\n    //  在isEqual方法中传递的是空数组\n    //  在方法体内部,判断的会再次进行传递被操作后的a堆和b堆\n    var length = aStack.length;\n\n    while (length--) {\n        // 如果堆中的某个对象与数据a匹配,则再判断另一个堆中相同位置的对象是否等于第二个对象\n        if (aStack[length] == a) return bStack[length] == b;\n    }\n\n    // 获取两个对象的构造器\n    var aCtor = a.constructor, bCtor = b.constructor;\n\n    //  判断两个对象如果不是不是同一个类的实例则认为不相等\n    if (aCtor !== bCtor &amp;&amp; !(_isType(bCtor, &quot;function&quot;) &amp;&amp;\n        (aCtor instanceof aCtor) &amp;&amp;\n        _isType(bCtor, &quot;function&quot;) &amp;&amp;\n        (bCtor instanceof bCtor))) {\n        return false;\n    }\n\n    // 把a和b分别放到a堆和b堆中\n    aStack.push(a);\n    bStack.push(b);\n\n    //  局部变量\n    var size = 0, result = true;\n\n    // 数组类型比较\n    if (className == &apos;[object Array]&apos;) {\n        size = a.length;\n\n        //  比较两个数组的长度是否相等\n        result = size == b.length;\n\n        //  如果长度相同,再依次比较数组的每项\n        if (result) {\n            while (size--) {\n                if (!(result = _eq(a[size], b[size], aStack, bStack))) break;\n            }\n        }\n    } else {\n\n        // 如果是对象类型,枚举第一个对象,判断b和a中的每个属性值是否相同,记录a中属性值的个数\n        for (var key in a) {\n            if (a.hasOwnProperty(key)) {\n                size++;\n                if (!(result = b.hasOwnProperty(key) &amp;&amp; _eq(a[key], b[key], aStack, bStack))) break;\n            }\n        }\n\n        /**\n         * 如果a中有的属性b中都有\n         * 再枚举b对象,判断长度,如果b中属性值的长度大于size则result为false(!1 = false / !0 = true)\n         */\n        if (result) {\n            for (key in b) {\n                if (b.hasOwnProperty(key) &amp;&amp; !(size--)) break;\n            }\n\n            // 当对象b中的属性多于对象a, 则认为两个对象不相等\n            result = !size;\n        }\n    }\n\n    // 删除堆中的数据,防止再进行迭代\n    aStack.pop();\n    bStack.pop();\n\n    //  返回比较结果\n    return result;\n}\n\n/**\n * 拷贝一个对象(摘自underscore中的copy方法)\n * @param obj   被拷贝的对象\n * @param deep  是否深拷贝\n * @returns {*}\n * @private\n */\nfunction _copy(obj, deep) {\n    //  typeof []/{} -&gt; &quot;object&quot;\n    var copied;\n    if (!deep || obj == null || typeof obj !== &quot;object&quot;) {\n        return obj;\n    }\n    var copied;\n    if (_isType(obj, &quot;Object&quot;)) {\n        copied = {};\n    } else if (_isType(obj, &quot;Array&quot;)) {\n        copied = [];\n    }\n    for (var i in obj) {\n        if (obj.hasOwnProperty(i)) {\n            copied[i] = obj[i];\n        }\n    }\n    return copied;\n}\n\n/**\n * 判断一个对象是否为指定类型\n * @param obj           被判断的对象\n * @param typeStr       类型字符串\n * @returns {boolean}\n * @private\n */\nfunction _isType(obj, typeStr) {\n    return _class2.toString.call(obj).toLowerCase() === (&quot;[object &quot; + typeStr + &quot;]&quot;).toLowerCase();\n}\n</code></pre><p>HTML中则可以如下调用:</p>\n<pre><code>var vm = new Vm();\nvm.setData({\n    &quot;arr&quot;: [1,2,4],\n    &quot;obj&quot;: {\n        &quot;name&quot;: &quot;son&quot;,\n        &quot;age&quot;: 23\n    }\n});\n\nvm.setData({\n    &quot;arr&quot;: [1,2,3,4],\n    &quot;obj&quot;: {\n        &quot;name&quot;: &quot;rwson&quot;,\n        &quot;age&quot;: 24\n    },\n    &quot;added&quot;: &quot;new add data&quot;\n});\n</code></pre><p>最后控制台输出信息如下图所示:</p>\n<p><img src=\"/imgs/watch-data-change.png\" alt=\"result\"></p>\n","excerpt":"","more":"<p>MVVM一直是最近几年的很火的一个词之一,以angularjs和Vue为代表的都是这种模式,但是实现完全不同。Vue是通过ES5中的新增方法Object.defineProperty并且给该属性指定getter/setter(setter上调用observe方法)方法来实现的;而angularjs中则是通过脏检查来实现该模式,也就是对所有数据当都调用一个轮询($digest),然后比对每个属性值,如果发生变化,就调用相应的处理回调函数,这种方式的缺点显而易见,当数据达到一定数量时候,处理起来就显得笨重吃力,个人觉得可以给整个数据提供一个setData方法,传入需要设置的新数据,然后内部做一个深拷贝,这样就只需要把新设置的数据和原来的数据进行对比,在性能上应该优于给所有数据轮询的方式。下面是具体实现:</p>\n<pre><code>var _class2 = {};\n\nfunction Vm() {\n}\n\nVm.prototype = {\n\n    &quot;constructor&quot;: Vm,\n\n    //  外部调用setData\n    &quot;setData&quot;: function (data) {\n\n        //  初始化数据\n        if (!this.data) {\n            this.data = data;\n            console.log(&quot;initialize data&quot;);\n        } else {\n\n            //  深拷贝老数据,不然可能造成oldData指向新数据的问题\n            var oldData = _copy(this.data, true);\n\n            for (var i in data) {\n                if (data.hasOwnProperty(i)) {\n                    this.data[i] = data[i];\n                }\n            }\n\n            //  获取比对结果(新设置的数据)\n            var res = this.compareData(oldData, data);\n\n            //  数据发生变化,打印出变化前后的数据\n            if (res.isChanged) {\n                for (var j in res) {\n                    if (j !== &quot;isChanged&quot; &amp;&amp; res.hasOwnProperty(j)) {\n                        console.group(&quot;data changed&quot;);\n                        console.log(&quot;new data:&quot;);\n                        console.log(res[j][&quot;newData&quot;]);\n                        console.log(&quot;old data:&quot;);\n                        console.log(res[j][&quot;oldData&quot;]);\n                        console.groupEnd(&quot;data changed&quot;);\n                    }\n                }\n            } else {\n                console.log(&quot;data is not change!&quot;);\n            }\n        }\n    },\n\n    //  数据比对方法,在setData中自动调用\n    &quot;compareData&quot;: function (oldData, newData) {\n        var res = {\n            &quot;isChanged&quot;: false\n        };\n\n        //  遍历每一项\n        for (var i in newData) {\n            var oldVal = oldData[i];\n            var curVal = newData[i];\n\n            //  不相等情况\n            if (!_eq(oldVal, curVal, [], [])) {\n                res.isChanged = true;\n\n                //  保存新数据和老数据\n                res[i] = {\n                    &quot;newData&quot;: curVal,\n                    &quot;oldData&quot;: oldVal\n                };\n            }\n        }\n        return res;\n    }\n\n};\n\n/**\n * 深度判断两个对象是否相等(摘自underscore中的eq方法)\n * @param a         第一个个对象\n * @param b         第二个对象\n * @param aStack    第一个栈\n * @param bStack    第二个栈\n * @returns {boolean}\n * @private\n */\nfunction _eq(a, b, aStack, bStack) {\n\n    // 获取第一个对象原型上的类名\n    var className = _class2.toString.call(a);\n\n    /**\n     * 检查两个基本数据类型的值是否相等\n     * 对于引用数据类型,如果它们来自同一个引用(同一个对象进行比较),则认为其相等\n     * 需要注意的是0 === -0的结果为true,所以后面的1 / a 和 1  / b 是来判断0 和 -0 的情况(1 / -0 = -Infinity) != (1 / 0 = Infinity)\n     */\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n\n    /**\n     * 处理undefined 和 null的情况\n     * undefined == null 的结果为true,而undefined === null 的结果为false\n     */\n    if (a == null || b == null) return a === b;\n\n    // 两个类名不同,直接返回false\n    if (className != _class2.toString.call(b)) return false;\n\n    switch (className) {\n        case &apos;[object String]&apos;:\n\n            /**\n             * toString.call(&quot;str&quot;) == &quot;[object String]&quot; -&gt; true\n             * toString.call(String(&quot;str&quot;)) == &quot;[object String]&quot; -&gt; true\n             * toString.call(new String(&quot;str&quot;)) == &quot;[object String]&quot; -&gt; true\n             */\n            return a == (&quot;&quot; + b);\n        case &apos;[object Number]&apos;:\n\n            /**\n             * +a 会把 a转换成一个数字,如果转换结果和原来不同则被认为NaN\n             * NaN != NaN,因此当a和b同时为NaN时,无法简单地使用a == b进行匹配,用相同的方法检查b是否为NaN(即 b != +b)\n             * 和刚进方法体一样,判断0和-0的情况\n             */\n            return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n        case &apos;[object Date]&apos;:\n        case &apos;[object Boolean]&apos;:\n\n            /**\n             * 把bool和date类型转换成对应的数字来比较\n             * +true -&gt; 1 / +false -&gt; 0 / +(new Date()) -&gt; (new Date()).getTime()\n             */\n            return +a == +b;\n        case &apos;[object RegExp]&apos;:\n\n            //  匹配正则表达式的相关属性是否相同(元字符串/全局匹配/多行模式/忽略大小写)\n            return a.source == b.source &amp;&amp;\n                a.global == b.global &amp;&amp;\n                a.multiline == b.multiline &amp;&amp;\n                a.ignoreCase == b.ignoreCase;\n    }\n\n    //  处理数组类型或对象类型(typeof [] = typeof {} = &quot;object&quot;)\n    if (typeof a != &apos;object&apos; || typeof b != &apos;object&apos;) return false;\n\n    //  在isEqual方法中传递的是空数组\n    //  在方法体内部,判断的会再次进行传递被操作后的a堆和b堆\n    var length = aStack.length;\n\n    while (length--) {\n        // 如果堆中的某个对象与数据a匹配,则再判断另一个堆中相同位置的对象是否等于第二个对象\n        if (aStack[length] == a) return bStack[length] == b;\n    }\n\n    // 获取两个对象的构造器\n    var aCtor = a.constructor, bCtor = b.constructor;\n\n    //  判断两个对象如果不是不是同一个类的实例则认为不相等\n    if (aCtor !== bCtor &amp;&amp; !(_isType(bCtor, &quot;function&quot;) &amp;&amp;\n        (aCtor instanceof aCtor) &amp;&amp;\n        _isType(bCtor, &quot;function&quot;) &amp;&amp;\n        (bCtor instanceof bCtor))) {\n        return false;\n    }\n\n    // 把a和b分别放到a堆和b堆中\n    aStack.push(a);\n    bStack.push(b);\n\n    //  局部变量\n    var size = 0, result = true;\n\n    // 数组类型比较\n    if (className == &apos;[object Array]&apos;) {\n        size = a.length;\n\n        //  比较两个数组的长度是否相等\n        result = size == b.length;\n\n        //  如果长度相同,再依次比较数组的每项\n        if (result) {\n            while (size--) {\n                if (!(result = _eq(a[size], b[size], aStack, bStack))) break;\n            }\n        }\n    } else {\n\n        // 如果是对象类型,枚举第一个对象,判断b和a中的每个属性值是否相同,记录a中属性值的个数\n        for (var key in a) {\n            if (a.hasOwnProperty(key)) {\n                size++;\n                if (!(result = b.hasOwnProperty(key) &amp;&amp; _eq(a[key], b[key], aStack, bStack))) break;\n            }\n        }\n\n        /**\n         * 如果a中有的属性b中都有\n         * 再枚举b对象,判断长度,如果b中属性值的长度大于size则result为false(!1 = false / !0 = true)\n         */\n        if (result) {\n            for (key in b) {\n                if (b.hasOwnProperty(key) &amp;&amp; !(size--)) break;\n            }\n\n            // 当对象b中的属性多于对象a, 则认为两个对象不相等\n            result = !size;\n        }\n    }\n\n    // 删除堆中的数据,防止再进行迭代\n    aStack.pop();\n    bStack.pop();\n\n    //  返回比较结果\n    return result;\n}\n\n/**\n * 拷贝一个对象(摘自underscore中的copy方法)\n * @param obj   被拷贝的对象\n * @param deep  是否深拷贝\n * @returns {*}\n * @private\n */\nfunction _copy(obj, deep) {\n    //  typeof []/{} -&gt; &quot;object&quot;\n    var copied;\n    if (!deep || obj == null || typeof obj !== &quot;object&quot;) {\n        return obj;\n    }\n    var copied;\n    if (_isType(obj, &quot;Object&quot;)) {\n        copied = {};\n    } else if (_isType(obj, &quot;Array&quot;)) {\n        copied = [];\n    }\n    for (var i in obj) {\n        if (obj.hasOwnProperty(i)) {\n            copied[i] = obj[i];\n        }\n    }\n    return copied;\n}\n\n/**\n * 判断一个对象是否为指定类型\n * @param obj           被判断的对象\n * @param typeStr       类型字符串\n * @returns {boolean}\n * @private\n */\nfunction _isType(obj, typeStr) {\n    return _class2.toString.call(obj).toLowerCase() === (&quot;[object &quot; + typeStr + &quot;]&quot;).toLowerCase();\n}\n</code></pre><p>HTML中则可以如下调用:</p>\n<pre><code>var vm = new Vm();\nvm.setData({\n    &quot;arr&quot;: [1,2,4],\n    &quot;obj&quot;: {\n        &quot;name&quot;: &quot;son&quot;,\n        &quot;age&quot;: 23\n    }\n});\n\nvm.setData({\n    &quot;arr&quot;: [1,2,3,4],\n    &quot;obj&quot;: {\n        &quot;name&quot;: &quot;rwson&quot;,\n        &quot;age&quot;: 24\n    },\n    &quot;added&quot;: &quot;new add data&quot;\n});\n</code></pre><p>最后控制台输出信息如下图所示:</p>\n<p><img src=\"/imgs/watch-data-change.png\" alt=\"result\"></p>\n"},{"layout":"post","title":"fetch中的Timeout","date":"2016-07-09T16:00:00.000Z","_content":"\n随着ES6的普及,fetch已经渐渐取代了普通ajax在异步请求中的位置,以前在用jQuery中的ajax时,可以指定一个timeout属性,设置该请求的超时时间,但是原生的fetch并不支持该属性,如果遇到遇到一个请求一直pedding状态,就只能干等着,什么也干不了。由于fetch本身在被初始化后返回一个Promise对象,我们就可以对其再包一层Promise来实现在fetch请求中加入timeout的功能。\n\n先来看下fetch的基本用法:\n\n    fetch(\"some url\", {\n        \"method\": \"POST\",\n        \"body\": JSON.stringify({\n            \"key\": \"value\",\n            \"arr\": [1,2,3]\n        }),\n        ...\n    })\n    //  parse response to JSON object\n    .then((res) => res.json())\n    .then((res) => {\n        //   success dome something\n    })\n    .catch((ex) => {\n        //  exception occurded\n    });\n    \n在Promise中有个静态方法,叫[Promise.race()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/race),该方法接受一个数组作为参数,数组中的每个元素都是一个Promise的实例,大致用法如下:\n\n    let promise1 = new Promise((resoleve, reject) => {\n        //  do something\n    });\n    \n    let promise2 = new Promise((resoleve, reject) => {\n        //  do something\n    });\n    \n    //  ...\n    \n    let race = Promise.race([promise1, promise2, ...]);\n\n它返回一个Promise,该Promise根据传入的Promise的第一个完成状态(resolve/reject),只要该Promise已完成,就将其返回。\n\n看个下面的例子:\n    \n    const promise1 = new Promise((resolve, reject) => {\n        //  1s后执行reject\n        setTimeout(() => {\n            reject(\"reject\");\n        }, 1000);\n    });\n    \n    const promise2 = new Promise((resolve, reject) => {\n        //  2s后执行resolve\n        setTimeout(() => {\n            resolve(\"success\");\n        }, 2000);\n    });\n\n    const racedPromise = Promise.race([promise1, promise2]);\n    \n    racedPromise()\n    .then(() => {\n        alert(\"success\");\n    })\n    .catch(() => {\n        alert(\"fail\");\n    });\n    \n//  显然上面的代码最终会弹出fail,因为promise1的状态比promise2先确定,所以Promise.race最终返回的是Promise1,由于状态是reject,所以走到了catch回调。\n\n上面说了好多废话:\n\n下面实现一个可设置timeout的fetch:\n\n    /**\n      * @param url      请求地址\n      * @param opt      配置参数\n      * @param timeout  \n      **/\n    function abortFetch(url, opt, timeout) {\n        if(typeof url !== \"string\") {\n        }\n        const fetchIns = fetch(url, opt || {});\n        const abortIns = new Promise((resolve, reject) => {\n            if(typeof timeout === \"number\" && timeout > 0) {\n                setTimeout(() => {\n                    reject({\n                        \"type\": \"abord\"\n                    });\n                }, timeout);\n            }\n        });\n        const finalPromise = Promise.race([fetchIns, abortIns]);\n        return finalPromise;\n    }\n\n    //  用法\n    \n    fetch(\"/fetch-timeout\", {\n        \"method\": \"POST\"\n    })\n    .then((res) => res.json())\n    .then((res) => {\n        if(res.status >= 200 && res.status < 300 || res.status === 302) {\n            //  do something response success\n        } else {\n            //  do something response failed\n        }\n    })\n    .catch((ex) => {\n        switch (ex.type) {\n            case \"abord\": \n                //  do something when request abord\n            break;\n            \n                ...\n            \n            default:\n                //  ...\n            break;\n        }\n    });\n\n到这里,就利用Promise.race实现了一个可配置超时时间的fetch\n","source":"_posts/2016-07-10-fetch-timeout.md","raw":"---\nlayout: post\ntitle: fetch中的Timeout\ndate: 2016-07-10\ncategories: [ES6, fetch]\n---\n\n随着ES6的普及,fetch已经渐渐取代了普通ajax在异步请求中的位置,以前在用jQuery中的ajax时,可以指定一个timeout属性,设置该请求的超时时间,但是原生的fetch并不支持该属性,如果遇到遇到一个请求一直pedding状态,就只能干等着,什么也干不了。由于fetch本身在被初始化后返回一个Promise对象,我们就可以对其再包一层Promise来实现在fetch请求中加入timeout的功能。\n\n先来看下fetch的基本用法:\n\n    fetch(\"some url\", {\n        \"method\": \"POST\",\n        \"body\": JSON.stringify({\n            \"key\": \"value\",\n            \"arr\": [1,2,3]\n        }),\n        ...\n    })\n    //  parse response to JSON object\n    .then((res) => res.json())\n    .then((res) => {\n        //   success dome something\n    })\n    .catch((ex) => {\n        //  exception occurded\n    });\n    \n在Promise中有个静态方法,叫[Promise.race()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/race),该方法接受一个数组作为参数,数组中的每个元素都是一个Promise的实例,大致用法如下:\n\n    let promise1 = new Promise((resoleve, reject) => {\n        //  do something\n    });\n    \n    let promise2 = new Promise((resoleve, reject) => {\n        //  do something\n    });\n    \n    //  ...\n    \n    let race = Promise.race([promise1, promise2, ...]);\n\n它返回一个Promise,该Promise根据传入的Promise的第一个完成状态(resolve/reject),只要该Promise已完成,就将其返回。\n\n看个下面的例子:\n    \n    const promise1 = new Promise((resolve, reject) => {\n        //  1s后执行reject\n        setTimeout(() => {\n            reject(\"reject\");\n        }, 1000);\n    });\n    \n    const promise2 = new Promise((resolve, reject) => {\n        //  2s后执行resolve\n        setTimeout(() => {\n            resolve(\"success\");\n        }, 2000);\n    });\n\n    const racedPromise = Promise.race([promise1, promise2]);\n    \n    racedPromise()\n    .then(() => {\n        alert(\"success\");\n    })\n    .catch(() => {\n        alert(\"fail\");\n    });\n    \n//  显然上面的代码最终会弹出fail,因为promise1的状态比promise2先确定,所以Promise.race最终返回的是Promise1,由于状态是reject,所以走到了catch回调。\n\n上面说了好多废话:\n\n下面实现一个可设置timeout的fetch:\n\n    /**\n      * @param url      请求地址\n      * @param opt      配置参数\n      * @param timeout  \n      **/\n    function abortFetch(url, opt, timeout) {\n        if(typeof url !== \"string\") {\n        }\n        const fetchIns = fetch(url, opt || {});\n        const abortIns = new Promise((resolve, reject) => {\n            if(typeof timeout === \"number\" && timeout > 0) {\n                setTimeout(() => {\n                    reject({\n                        \"type\": \"abord\"\n                    });\n                }, timeout);\n            }\n        });\n        const finalPromise = Promise.race([fetchIns, abortIns]);\n        return finalPromise;\n    }\n\n    //  用法\n    \n    fetch(\"/fetch-timeout\", {\n        \"method\": \"POST\"\n    })\n    .then((res) => res.json())\n    .then((res) => {\n        if(res.status >= 200 && res.status < 300 || res.status === 302) {\n            //  do something response success\n        } else {\n            //  do something response failed\n        }\n    })\n    .catch((ex) => {\n        switch (ex.type) {\n            case \"abord\": \n                //  do something when request abord\n            break;\n            \n                ...\n            \n            default:\n                //  ...\n            break;\n        }\n    });\n\n到这里,就利用Promise.race实现了一个可配置超时时间的fetch\n","slug":"2016-07-10-fetch-timeout","published":1,"updated":"2016-11-09T14:02:21.000Z","_id":"civ7fsefv001ot95fwnd44f2z","comments":1,"photos":[],"link":"","content":"<p>随着ES6的普及,fetch已经渐渐取代了普通ajax在异步请求中的位置,以前在用jQuery中的ajax时,可以指定一个timeout属性,设置该请求的超时时间,但是原生的fetch并不支持该属性,如果遇到遇到一个请求一直pedding状态,就只能干等着,什么也干不了。由于fetch本身在被初始化后返回一个Promise对象,我们就可以对其再包一层Promise来实现在fetch请求中加入timeout的功能。</p>\n<p>先来看下fetch的基本用法:</p>\n<pre><code>fetch(&quot;some url&quot;, {\n    &quot;method&quot;: &quot;POST&quot;,\n    &quot;body&quot;: JSON.stringify({\n        &quot;key&quot;: &quot;value&quot;,\n        &quot;arr&quot;: [1,2,3]\n    }),\n    ...\n})\n//  parse response to JSON object\n.then((res) =&gt; res.json())\n.then((res) =&gt; {\n    //   success dome something\n})\n.catch((ex) =&gt; {\n    //  exception occurded\n});\n</code></pre><p>在Promise中有个静态方法,叫<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/race\" target=\"_blank\" rel=\"external\">Promise.race()</a>,该方法接受一个数组作为参数,数组中的每个元素都是一个Promise的实例,大致用法如下:</p>\n<pre><code>let promise1 = new Promise((resoleve, reject) =&gt; {\n    //  do something\n});\n\nlet promise2 = new Promise((resoleve, reject) =&gt; {\n    //  do something\n});\n\n//  ...\n\nlet race = Promise.race([promise1, promise2, ...]);\n</code></pre><p>它返回一个Promise,该Promise根据传入的Promise的第一个完成状态(resolve/reject),只要该Promise已完成,就将其返回。</p>\n<p>看个下面的例子:</p>\n<pre><code>const promise1 = new Promise((resolve, reject) =&gt; {\n    //  1s后执行reject\n    setTimeout(() =&gt; {\n        reject(&quot;reject&quot;);\n    }, 1000);\n});\n\nconst promise2 = new Promise((resolve, reject) =&gt; {\n    //  2s后执行resolve\n    setTimeout(() =&gt; {\n        resolve(&quot;success&quot;);\n    }, 2000);\n});\n\nconst racedPromise = Promise.race([promise1, promise2]);\n\nracedPromise()\n.then(() =&gt; {\n    alert(&quot;success&quot;);\n})\n.catch(() =&gt; {\n    alert(&quot;fail&quot;);\n});\n</code></pre><p>//  显然上面的代码最终会弹出fail,因为promise1的状态比promise2先确定,所以Promise.race最终返回的是Promise1,由于状态是reject,所以走到了catch回调。</p>\n<p>上面说了好多废话:</p>\n<p>下面实现一个可设置timeout的fetch:</p>\n<pre><code>/**\n  * @param url      请求地址\n  * @param opt      配置参数\n  * @param timeout  \n  **/\nfunction abortFetch(url, opt, timeout) {\n    if(typeof url !== &quot;string&quot;) {\n    }\n    const fetchIns = fetch(url, opt || {});\n    const abortIns = new Promise((resolve, reject) =&gt; {\n        if(typeof timeout === &quot;number&quot; &amp;&amp; timeout &gt; 0) {\n            setTimeout(() =&gt; {\n                reject({\n                    &quot;type&quot;: &quot;abord&quot;\n                });\n            }, timeout);\n        }\n    });\n    const finalPromise = Promise.race([fetchIns, abortIns]);\n    return finalPromise;\n}\n\n//  用法\n\nfetch(&quot;/fetch-timeout&quot;, {\n    &quot;method&quot;: &quot;POST&quot;\n})\n.then((res) =&gt; res.json())\n.then((res) =&gt; {\n    if(res.status &gt;= 200 &amp;&amp; res.status &lt; 300 || res.status === 302) {\n        //  do something response success\n    } else {\n        //  do something response failed\n    }\n})\n.catch((ex) =&gt; {\n    switch (ex.type) {\n        case &quot;abord&quot;: \n            //  do something when request abord\n        break;\n\n            ...\n\n        default:\n            //  ...\n        break;\n    }\n});\n</code></pre><p>到这里,就利用Promise.race实现了一个可配置超时时间的fetch</p>\n","excerpt":"","more":"<p>随着ES6的普及,fetch已经渐渐取代了普通ajax在异步请求中的位置,以前在用jQuery中的ajax时,可以指定一个timeout属性,设置该请求的超时时间,但是原生的fetch并不支持该属性,如果遇到遇到一个请求一直pedding状态,就只能干等着,什么也干不了。由于fetch本身在被初始化后返回一个Promise对象,我们就可以对其再包一层Promise来实现在fetch请求中加入timeout的功能。</p>\n<p>先来看下fetch的基本用法:</p>\n<pre><code>fetch(&quot;some url&quot;, {\n    &quot;method&quot;: &quot;POST&quot;,\n    &quot;body&quot;: JSON.stringify({\n        &quot;key&quot;: &quot;value&quot;,\n        &quot;arr&quot;: [1,2,3]\n    }),\n    ...\n})\n//  parse response to JSON object\n.then((res) =&gt; res.json())\n.then((res) =&gt; {\n    //   success dome something\n})\n.catch((ex) =&gt; {\n    //  exception occurded\n});\n</code></pre><p>在Promise中有个静态方法,叫<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/race\">Promise.race()</a>,该方法接受一个数组作为参数,数组中的每个元素都是一个Promise的实例,大致用法如下:</p>\n<pre><code>let promise1 = new Promise((resoleve, reject) =&gt; {\n    //  do something\n});\n\nlet promise2 = new Promise((resoleve, reject) =&gt; {\n    //  do something\n});\n\n//  ...\n\nlet race = Promise.race([promise1, promise2, ...]);\n</code></pre><p>它返回一个Promise,该Promise根据传入的Promise的第一个完成状态(resolve/reject),只要该Promise已完成,就将其返回。</p>\n<p>看个下面的例子:</p>\n<pre><code>const promise1 = new Promise((resolve, reject) =&gt; {\n    //  1s后执行reject\n    setTimeout(() =&gt; {\n        reject(&quot;reject&quot;);\n    }, 1000);\n});\n\nconst promise2 = new Promise((resolve, reject) =&gt; {\n    //  2s后执行resolve\n    setTimeout(() =&gt; {\n        resolve(&quot;success&quot;);\n    }, 2000);\n});\n\nconst racedPromise = Promise.race([promise1, promise2]);\n\nracedPromise()\n.then(() =&gt; {\n    alert(&quot;success&quot;);\n})\n.catch(() =&gt; {\n    alert(&quot;fail&quot;);\n});\n</code></pre><p>//  显然上面的代码最终会弹出fail,因为promise1的状态比promise2先确定,所以Promise.race最终返回的是Promise1,由于状态是reject,所以走到了catch回调。</p>\n<p>上面说了好多废话:</p>\n<p>下面实现一个可设置timeout的fetch:</p>\n<pre><code>/**\n  * @param url      请求地址\n  * @param opt      配置参数\n  * @param timeout  \n  **/\nfunction abortFetch(url, opt, timeout) {\n    if(typeof url !== &quot;string&quot;) {\n    }\n    const fetchIns = fetch(url, opt || {});\n    const abortIns = new Promise((resolve, reject) =&gt; {\n        if(typeof timeout === &quot;number&quot; &amp;&amp; timeout &gt; 0) {\n            setTimeout(() =&gt; {\n                reject({\n                    &quot;type&quot;: &quot;abord&quot;\n                });\n            }, timeout);\n        }\n    });\n    const finalPromise = Promise.race([fetchIns, abortIns]);\n    return finalPromise;\n}\n\n//  用法\n\nfetch(&quot;/fetch-timeout&quot;, {\n    &quot;method&quot;: &quot;POST&quot;\n})\n.then((res) =&gt; res.json())\n.then((res) =&gt; {\n    if(res.status &gt;= 200 &amp;&amp; res.status &lt; 300 || res.status === 302) {\n        //  do something response success\n    } else {\n        //  do something response failed\n    }\n})\n.catch((ex) =&gt; {\n    switch (ex.type) {\n        case &quot;abord&quot;: \n            //  do something when request abord\n        break;\n\n            ...\n\n        default:\n            //  ...\n        break;\n    }\n});\n</code></pre><p>到这里,就利用Promise.race实现了一个可配置超时时间的fetch</p>\n"},{"layout":"post","title":"javascript函数节流","date":"2016-07-19T16:00:00.000Z","_content":"\n如果我们需要做一个过滤的功能,类似于下面这个效果\n\n![](/imgs/screen.gif)\n\n我们需要给input绑定一个keyup事件,然后根据它的value操作页面或者过滤数据重新渲染页面,但是在数据比较多的时候,如果在keyup里面不做一定限制的话,在性能方面就会有一些影响,这时候,就需要\"函数节流\"这个东西。\n\n在underscore这个库中提供了一个函数节流的方法,其实就是在一定时间内判断某个函数是否被执行过。\n\n就拿我们上面的效果来说:\n\t\n\t\n\t//  HTML\n\t<input type=\"text\" id=\"input\" />\n\t<ul id=\"ul\">\n\t\t<li>111111111</li>\n\t\t<li>22222222</li>\n\t\t<li>333333</li>\n\t\t<li>4444</li>\n\t\t<li>1234</li>\n\t\t<li>5678</li>\n\t\t<li>9999</li>\n\t\t<li>6789</li>\n\t\t<li>01234</li>\n\t</ul>\n\t\n\t\n\t//  javascript\n\t\twindow.onload = function() {\n\t\t\tvar input = document.getElementById(\"input\");\n\t\t\tvar ul = document.getElementById(\"ul\");\n\t\t\tvar li = ul.getElementsByTagName(\"li\");\n\t\t\tvar len = li.length;\n\t\t\tvar value, timeout = null;\n\t\t\tinput.onkeyup = function(ev) {\n\t\t\t    //  上次的还没执行\n\t\t\t    if(timeout) {\n\t\t\t        return;\n\t\t\t    }\n\t\t\t    timeout = setTimeout(function() {\n    \t\t\t    clearTimeout(timeout);\n                    value = ev.target.value.trim();\n    \t\t\t\tfor(var i = 0; i < len; i ++) {\n    \t\t\t\t\tif(li[i].innerHTML.indexOf(value) > -1) {\n    \t\t\t\t\t\tli[i].style.display = \"block\";\n    \t\t\t\t\t} else {\n    \t\t\t\t\t\tli[i].style.display = \"none\";\n    \t\t\t\t\t}\n    \t\t\t\t}\n\t\t\t    }, 200);\n\t\t\t};\n\n\t};\n\t\n下面可以把这个函数再次进行封装:\n\n\n    /**\n     * 函数节流\n     * @param fn        回调函数\n     * @param delay     延迟多久\n     * @param atleast   至少多久触发一次\n     * @return Function\n     */\n    function throttle(fn, delay, atleast) {\n        var timer = null;\n        var previous = null;\n     \n        return function () {\n            var now = +(new Date());\n     \n            if ( !previous ) {\n                previous = now;\n            }\n     \n            if ( now - previous > atleast ) {\n                fn();\n                // 重置上一次开始时间为本次结束时间\n                previous = now;\n            } else {\n                clearTimeout(timer);\n                timer = setTimeout(function() {\n                    fn();\n                }, delay);\n            }\n        }\n    };\n    \n    \n在平时可以有好多地方用到函数节流,比如浏览器的resize,鼠标滚轮事件等等。","source":"_posts/2016-07-20-javascript-function-throttle.md","raw":"---\nlayout: post\ntitle: javascript函数节流\ndate: 2016-07-20\ncategories: [javascript, 函数节流]\n---\n\n如果我们需要做一个过滤的功能,类似于下面这个效果\n\n![](/imgs/screen.gif)\n\n我们需要给input绑定一个keyup事件,然后根据它的value操作页面或者过滤数据重新渲染页面,但是在数据比较多的时候,如果在keyup里面不做一定限制的话,在性能方面就会有一些影响,这时候,就需要\"函数节流\"这个东西。\n\n在underscore这个库中提供了一个函数节流的方法,其实就是在一定时间内判断某个函数是否被执行过。\n\n就拿我们上面的效果来说:\n\t\n\t\n\t//  HTML\n\t<input type=\"text\" id=\"input\" />\n\t<ul id=\"ul\">\n\t\t<li>111111111</li>\n\t\t<li>22222222</li>\n\t\t<li>333333</li>\n\t\t<li>4444</li>\n\t\t<li>1234</li>\n\t\t<li>5678</li>\n\t\t<li>9999</li>\n\t\t<li>6789</li>\n\t\t<li>01234</li>\n\t</ul>\n\t\n\t\n\t//  javascript\n\t\twindow.onload = function() {\n\t\t\tvar input = document.getElementById(\"input\");\n\t\t\tvar ul = document.getElementById(\"ul\");\n\t\t\tvar li = ul.getElementsByTagName(\"li\");\n\t\t\tvar len = li.length;\n\t\t\tvar value, timeout = null;\n\t\t\tinput.onkeyup = function(ev) {\n\t\t\t    //  上次的还没执行\n\t\t\t    if(timeout) {\n\t\t\t        return;\n\t\t\t    }\n\t\t\t    timeout = setTimeout(function() {\n    \t\t\t    clearTimeout(timeout);\n                    value = ev.target.value.trim();\n    \t\t\t\tfor(var i = 0; i < len; i ++) {\n    \t\t\t\t\tif(li[i].innerHTML.indexOf(value) > -1) {\n    \t\t\t\t\t\tli[i].style.display = \"block\";\n    \t\t\t\t\t} else {\n    \t\t\t\t\t\tli[i].style.display = \"none\";\n    \t\t\t\t\t}\n    \t\t\t\t}\n\t\t\t    }, 200);\n\t\t\t};\n\n\t};\n\t\n下面可以把这个函数再次进行封装:\n\n\n    /**\n     * 函数节流\n     * @param fn        回调函数\n     * @param delay     延迟多久\n     * @param atleast   至少多久触发一次\n     * @return Function\n     */\n    function throttle(fn, delay, atleast) {\n        var timer = null;\n        var previous = null;\n     \n        return function () {\n            var now = +(new Date());\n     \n            if ( !previous ) {\n                previous = now;\n            }\n     \n            if ( now - previous > atleast ) {\n                fn();\n                // 重置上一次开始时间为本次结束时间\n                previous = now;\n            } else {\n                clearTimeout(timer);\n                timer = setTimeout(function() {\n                    fn();\n                }, delay);\n            }\n        }\n    };\n    \n    \n在平时可以有好多地方用到函数节流,比如浏览器的resize,鼠标滚轮事件等等。","slug":"2016-07-20-javascript-function-throttle","published":1,"updated":"2016-11-09T14:02:27.000Z","_id":"civ7fsefx001rt95fj8o2dieg","comments":1,"photos":[],"link":"","content":"<p>如果我们需要做一个过滤的功能,类似于下面这个效果</p>\n<p><img src=\"/imgs/screen.gif\" alt=\"\"></p>\n<p>我们需要给input绑定一个keyup事件,然后根据它的value操作页面或者过滤数据重新渲染页面,但是在数据比较多的时候,如果在keyup里面不做一定限制的话,在性能方面就会有一些影响,这时候,就需要”函数节流”这个东西。</p>\n<p>在underscore这个库中提供了一个函数节流的方法,其实就是在一定时间内判断某个函数是否被执行过。</p>\n<p>就拿我们上面的效果来说:</p>\n<pre><code>//  HTML\n&lt;input type=&quot;text&quot; id=&quot;input&quot; /&gt;\n&lt;ul id=&quot;ul&quot;&gt;\n    &lt;li&gt;111111111&lt;/li&gt;\n    &lt;li&gt;22222222&lt;/li&gt;\n    &lt;li&gt;333333&lt;/li&gt;\n    &lt;li&gt;4444&lt;/li&gt;\n    &lt;li&gt;1234&lt;/li&gt;\n    &lt;li&gt;5678&lt;/li&gt;\n    &lt;li&gt;9999&lt;/li&gt;\n    &lt;li&gt;6789&lt;/li&gt;\n    &lt;li&gt;01234&lt;/li&gt;\n&lt;/ul&gt;\n\n\n//  javascript\n    window.onload = function() {\n        var input = document.getElementById(&quot;input&quot;);\n        var ul = document.getElementById(&quot;ul&quot;);\n        var li = ul.getElementsByTagName(&quot;li&quot;);\n        var len = li.length;\n        var value, timeout = null;\n        input.onkeyup = function(ev) {\n            //  上次的还没执行\n            if(timeout) {\n                return;\n            }\n            timeout = setTimeout(function() {\n                clearTimeout(timeout);\n                value = ev.target.value.trim();\n                for(var i = 0; i &lt; len; i ++) {\n                    if(li[i].innerHTML.indexOf(value) &gt; -1) {\n                        li[i].style.display = &quot;block&quot;;\n                    } else {\n                        li[i].style.display = &quot;none&quot;;\n                    }\n                }\n            }, 200);\n        };\n\n};\n</code></pre><p>下面可以把这个函数再次进行封装:</p>\n<pre><code>/**\n * 函数节流\n * @param fn        回调函数\n * @param delay     延迟多久\n * @param atleast   至少多久触发一次\n * @return Function\n */\nfunction throttle(fn, delay, atleast) {\n    var timer = null;\n    var previous = null;\n\n    return function () {\n        var now = +(new Date());\n\n        if ( !previous ) {\n            previous = now;\n        }\n\n        if ( now - previous &gt; atleast ) {\n            fn();\n            // 重置上一次开始时间为本次结束时间\n            previous = now;\n        } else {\n            clearTimeout(timer);\n            timer = setTimeout(function() {\n                fn();\n            }, delay);\n        }\n    }\n};\n</code></pre><p>在平时可以有好多地方用到函数节流,比如浏览器的resize,鼠标滚轮事件等等。</p>\n","excerpt":"","more":"<p>如果我们需要做一个过滤的功能,类似于下面这个效果</p>\n<p><img src=\"/imgs/screen.gif\" alt=\"\"></p>\n<p>我们需要给input绑定一个keyup事件,然后根据它的value操作页面或者过滤数据重新渲染页面,但是在数据比较多的时候,如果在keyup里面不做一定限制的话,在性能方面就会有一些影响,这时候,就需要”函数节流”这个东西。</p>\n<p>在underscore这个库中提供了一个函数节流的方法,其实就是在一定时间内判断某个函数是否被执行过。</p>\n<p>就拿我们上面的效果来说:</p>\n<pre><code>//  HTML\n&lt;input type=&quot;text&quot; id=&quot;input&quot; /&gt;\n&lt;ul id=&quot;ul&quot;&gt;\n    &lt;li&gt;111111111&lt;/li&gt;\n    &lt;li&gt;22222222&lt;/li&gt;\n    &lt;li&gt;333333&lt;/li&gt;\n    &lt;li&gt;4444&lt;/li&gt;\n    &lt;li&gt;1234&lt;/li&gt;\n    &lt;li&gt;5678&lt;/li&gt;\n    &lt;li&gt;9999&lt;/li&gt;\n    &lt;li&gt;6789&lt;/li&gt;\n    &lt;li&gt;01234&lt;/li&gt;\n&lt;/ul&gt;\n\n\n//  javascript\n    window.onload = function() {\n        var input = document.getElementById(&quot;input&quot;);\n        var ul = document.getElementById(&quot;ul&quot;);\n        var li = ul.getElementsByTagName(&quot;li&quot;);\n        var len = li.length;\n        var value, timeout = null;\n        input.onkeyup = function(ev) {\n            //  上次的还没执行\n            if(timeout) {\n                return;\n            }\n            timeout = setTimeout(function() {\n                clearTimeout(timeout);\n                value = ev.target.value.trim();\n                for(var i = 0; i &lt; len; i ++) {\n                    if(li[i].innerHTML.indexOf(value) &gt; -1) {\n                        li[i].style.display = &quot;block&quot;;\n                    } else {\n                        li[i].style.display = &quot;none&quot;;\n                    }\n                }\n            }, 200);\n        };\n\n};\n</code></pre><p>下面可以把这个函数再次进行封装:</p>\n<pre><code>/**\n * 函数节流\n * @param fn        回调函数\n * @param delay     延迟多久\n * @param atleast   至少多久触发一次\n * @return Function\n */\nfunction throttle(fn, delay, atleast) {\n    var timer = null;\n    var previous = null;\n\n    return function () {\n        var now = +(new Date());\n\n        if ( !previous ) {\n            previous = now;\n        }\n\n        if ( now - previous &gt; atleast ) {\n            fn();\n            // 重置上一次开始时间为本次结束时间\n            previous = now;\n        } else {\n            clearTimeout(timer);\n            timer = setTimeout(function() {\n                fn();\n            }, delay);\n        }\n    }\n};\n</code></pre><p>在平时可以有好多地方用到函数节流,比如浏览器的resize,鼠标滚轮事件等等。</p>\n"},{"layout":"post","title":"javascript中Date细节","date":"2016-08-29T16:00:00.000Z","_content":"\n##### Safri浏览器new Date(\"yyyy-mm-dd\")返回invalid Date\n\n许多时候我们需要初始化一个具体某天的日期对象的时候,会用到new Date(),这个方法,我们可以传入一个字符串作为参数来指定具体的日期,而一般我们会传入一个\"yyyy-mm-dd hh:ii:ss\"这种格式作为一个初始日期,但到了Safri浏览器下,就会返回一个invalid Date,调用该Date实例下的所有方法都会返回NaN值,原因是Safri不能正常解析中间的\"-\"分隔符,解决办法也很简单,有两种:\n\n直接\n\n    var myDate1 = Date.parseExact(\"29-11-2010\", \"dd-MM-yyyy\");\n    var myDate2 = Date.parseExact(\"11-29-2010\", \"MM-dd-yyyy\");\n    var myDate3 = Date.parseExact(\"2010-11-29\", \"yyyy-MM-dd\");\n    var myDate4 = Date.parseExact(\"2010-29-11\", \"yyyy-dd-MM\");\n\n或者\n\n    new Date(\"2011-04-12\".replace(/-/g, \"/\"));\n\n##### setMonth溢出问题\n\n实例化一个Date对象,通过如下的方式,然后调用该实例的setMonth方法,把当前月份加1,就像下面这样\n\n    var date = new Date(\"2016/01/30\");\n    date.setMonth(date.getMonth() + 1);\n    console.log(date.getMonth());       //  Tue Mar 01 2016 00:00:00 GMT+0800 (CST)\n    \n或者\n\n    var date = new Date(\"2016/10/31\");\n    date.setMonth(date.getMonth() + 1);\n    console.log(date);                 //  Thu Dec 01 2016 00:00:00 GMT+0800 (CST)\n    \n上面两段我们都希望是返回的是2月和11月,但是真正返回了3月和12月\n\n出现这种情况的原因是2月没有28/29号以后的日期,而当前日期对象的日期为30号,调用setMonth,就导致溢出,下面的例子同理。\n\n解决办法也很简单,在调用setMonth之前,拿下个月的最后一天和当前的比较下,再做相应处理就好,或者更简单粗暴的方法,把当前Date对象的date改成1,哈哈。\n\n","source":"_posts/2016-08-30-something-about-javascript-Date.md","raw":"---\nlayout: post\ntitle: javascript中Date细节\ndate: 2016-08-30\ncategories: [javascript, Date]\n---\n\n##### Safri浏览器new Date(\"yyyy-mm-dd\")返回invalid Date\n\n许多时候我们需要初始化一个具体某天的日期对象的时候,会用到new Date(),这个方法,我们可以传入一个字符串作为参数来指定具体的日期,而一般我们会传入一个\"yyyy-mm-dd hh:ii:ss\"这种格式作为一个初始日期,但到了Safri浏览器下,就会返回一个invalid Date,调用该Date实例下的所有方法都会返回NaN值,原因是Safri不能正常解析中间的\"-\"分隔符,解决办法也很简单,有两种:\n\n直接\n\n    var myDate1 = Date.parseExact(\"29-11-2010\", \"dd-MM-yyyy\");\n    var myDate2 = Date.parseExact(\"11-29-2010\", \"MM-dd-yyyy\");\n    var myDate3 = Date.parseExact(\"2010-11-29\", \"yyyy-MM-dd\");\n    var myDate4 = Date.parseExact(\"2010-29-11\", \"yyyy-dd-MM\");\n\n或者\n\n    new Date(\"2011-04-12\".replace(/-/g, \"/\"));\n\n##### setMonth溢出问题\n\n实例化一个Date对象,通过如下的方式,然后调用该实例的setMonth方法,把当前月份加1,就像下面这样\n\n    var date = new Date(\"2016/01/30\");\n    date.setMonth(date.getMonth() + 1);\n    console.log(date.getMonth());       //  Tue Mar 01 2016 00:00:00 GMT+0800 (CST)\n    \n或者\n\n    var date = new Date(\"2016/10/31\");\n    date.setMonth(date.getMonth() + 1);\n    console.log(date);                 //  Thu Dec 01 2016 00:00:00 GMT+0800 (CST)\n    \n上面两段我们都希望是返回的是2月和11月,但是真正返回了3月和12月\n\n出现这种情况的原因是2月没有28/29号以后的日期,而当前日期对象的日期为30号,调用setMonth,就导致溢出,下面的例子同理。\n\n解决办法也很简单,在调用setMonth之前,拿下个月的最后一天和当前的比较下,再做相应处理就好,或者更简单粗暴的方法,把当前Date对象的date改成1,哈哈。\n\n","slug":"2016-08-30-something-about-javascript-Date","published":1,"updated":"2016-11-09T14:02:36.000Z","_id":"civ7fsefx001tt95fj2ul7s13","comments":1,"photos":[],"link":"","content":"<h5 id=\"Safri浏览器new-Date-“yyyy-mm-dd”-返回invalid-Date\"><a href=\"#Safri浏览器new-Date-“yyyy-mm-dd”-返回invalid-Date\" class=\"headerlink\" title=\"Safri浏览器new Date(“yyyy-mm-dd”)返回invalid Date\"></a>Safri浏览器new Date(“yyyy-mm-dd”)返回invalid Date</h5><p>许多时候我们需要初始化一个具体某天的日期对象的时候,会用到new Date(),这个方法,我们可以传入一个字符串作为参数来指定具体的日期,而一般我们会传入一个”yyyy-mm-dd hh:ii:ss”这种格式作为一个初始日期,但到了Safri浏览器下,就会返回一个invalid Date,调用该Date实例下的所有方法都会返回NaN值,原因是Safri不能正常解析中间的”-“分隔符,解决办法也很简单,有两种:</p>\n<p>直接</p>\n<pre><code>var myDate1 = Date.parseExact(&quot;29-11-2010&quot;, &quot;dd-MM-yyyy&quot;);\nvar myDate2 = Date.parseExact(&quot;11-29-2010&quot;, &quot;MM-dd-yyyy&quot;);\nvar myDate3 = Date.parseExact(&quot;2010-11-29&quot;, &quot;yyyy-MM-dd&quot;);\nvar myDate4 = Date.parseExact(&quot;2010-29-11&quot;, &quot;yyyy-dd-MM&quot;);\n</code></pre><p>或者</p>\n<pre><code>new Date(&quot;2011-04-12&quot;.replace(/-/g, &quot;/&quot;));\n</code></pre><h5 id=\"setMonth溢出问题\"><a href=\"#setMonth溢出问题\" class=\"headerlink\" title=\"setMonth溢出问题\"></a>setMonth溢出问题</h5><p>实例化一个Date对象,通过如下的方式,然后调用该实例的setMonth方法,把当前月份加1,就像下面这样</p>\n<pre><code>var date = new Date(&quot;2016/01/30&quot;);\ndate.setMonth(date.getMonth() + 1);\nconsole.log(date.getMonth());       //  Tue Mar 01 2016 00:00:00 GMT+0800 (CST)\n</code></pre><p>或者</p>\n<pre><code>var date = new Date(&quot;2016/10/31&quot;);\ndate.setMonth(date.getMonth() + 1);\nconsole.log(date);                 //  Thu Dec 01 2016 00:00:00 GMT+0800 (CST)\n</code></pre><p>上面两段我们都希望是返回的是2月和11月,但是真正返回了3月和12月</p>\n<p>出现这种情况的原因是2月没有28/29号以后的日期,而当前日期对象的日期为30号,调用setMonth,就导致溢出,下面的例子同理。</p>\n<p>解决办法也很简单,在调用setMonth之前,拿下个月的最后一天和当前的比较下,再做相应处理就好,或者更简单粗暴的方法,把当前Date对象的date改成1,哈哈。</p>\n","excerpt":"","more":"<h5 id=\"Safri浏览器new-Date-“yyyy-mm-dd”-返回invalid-Date\"><a href=\"#Safri浏览器new-Date-“yyyy-mm-dd”-返回invalid-Date\" class=\"headerlink\" title=\"Safri浏览器new Date(“yyyy-mm-dd”)返回invalid Date\"></a>Safri浏览器new Date(“yyyy-mm-dd”)返回invalid Date</h5><p>许多时候我们需要初始化一个具体某天的日期对象的时候,会用到new Date(),这个方法,我们可以传入一个字符串作为参数来指定具体的日期,而一般我们会传入一个”yyyy-mm-dd hh:ii:ss”这种格式作为一个初始日期,但到了Safri浏览器下,就会返回一个invalid Date,调用该Date实例下的所有方法都会返回NaN值,原因是Safri不能正常解析中间的”-“分隔符,解决办法也很简单,有两种:</p>\n<p>直接</p>\n<pre><code>var myDate1 = Date.parseExact(&quot;29-11-2010&quot;, &quot;dd-MM-yyyy&quot;);\nvar myDate2 = Date.parseExact(&quot;11-29-2010&quot;, &quot;MM-dd-yyyy&quot;);\nvar myDate3 = Date.parseExact(&quot;2010-11-29&quot;, &quot;yyyy-MM-dd&quot;);\nvar myDate4 = Date.parseExact(&quot;2010-29-11&quot;, &quot;yyyy-dd-MM&quot;);\n</code></pre><p>或者</p>\n<pre><code>new Date(&quot;2011-04-12&quot;.replace(/-/g, &quot;/&quot;));\n</code></pre><h5 id=\"setMonth溢出问题\"><a href=\"#setMonth溢出问题\" class=\"headerlink\" title=\"setMonth溢出问题\"></a>setMonth溢出问题</h5><p>实例化一个Date对象,通过如下的方式,然后调用该实例的setMonth方法,把当前月份加1,就像下面这样</p>\n<pre><code>var date = new Date(&quot;2016/01/30&quot;);\ndate.setMonth(date.getMonth() + 1);\nconsole.log(date.getMonth());       //  Tue Mar 01 2016 00:00:00 GMT+0800 (CST)\n</code></pre><p>或者</p>\n<pre><code>var date = new Date(&quot;2016/10/31&quot;);\ndate.setMonth(date.getMonth() + 1);\nconsole.log(date);                 //  Thu Dec 01 2016 00:00:00 GMT+0800 (CST)\n</code></pre><p>上面两段我们都希望是返回的是2月和11月,但是真正返回了3月和12月</p>\n<p>出现这种情况的原因是2月没有28/29号以后的日期,而当前日期对象的日期为30号,调用setMonth,就导致溢出,下面的例子同理。</p>\n<p>解决办法也很简单,在调用setMonth之前,拿下个月的最后一天和当前的比较下,再做相应处理就好,或者更简单粗暴的方法,把当前Date对象的date改成1,哈哈。</p>\n"},{"layout":"post","title":"javascript中的序列化","date":"2016-09-16T16:00:00.000Z","_content":"在用jQuery发送ajax(POST)请求的时候,最常见的提交方式就是\"application/x-www-form-urlencoded\",通常都会传入一个data属性作为传输给后端的数据,在ajax发送之前,那么我们直接如果直接传入把这个对象传递给后端,后端就不能对该对象进行解析,因为对象会被转成字符串\"[object Object]\",所以就需要我们对该对象进行url编码,并且转换成字符串,再传给后端。\n\n假设我们先传递一个简单的对象(所有的key对应的value都不是引用类型[Array、Object]),就像下面这样:\n\n    {\n        string: \"string\",\n        number: 1\n    }\n    \n用jQuery中的$.ajax方法,POST提交,打开请求面板,在form data那边,点击view source,可以看到下面这一串字符串,就像下面的样子:\n\n    string=string&number=1\n\n在jQuery中,$.param这个方法可以实现进行url编码的作用。\n\n现在可以自己实现一个:\n\n    //  获取对象上的类名\n    function _typeOf(obj) {\n        return {}.toString.call(obj).slice(8, -1);\n    }\n\n    //  encodeURIComponent简写\n    function _encode(data) {\n        data = data || \"\";\n        return encodeURIComponent(data);\n    }\n\n    //  序列化主函数\n    function _serializenData(data) {\n        var res = data,\n            typeIn;\n            \n        //  判断传入的是否是一个Object类型的数据\n        if (_typeOf(data) === \"Object\") {\n            res = [];\n            for (var i in data) {\n                typeIn = _typeOf(data[i]);\n                switch (typeIn) {\n\n                    //  遇到Object、Array时需要进行遍历或者枚举,对其内部元素、属性做处理后再放到结果集数组中\n                    case \"Object\":\n                        res.push(_loopObject(data[i], i));\n                        break;\n\n                    case \"Array\":\n                        res.push(_loopArray(data[i], i));\n                        break;\n\n                    //  其他类型直接推到结果集数组\n                    default:\n                        res.push(_encode(i) + \"=\" + _encode(data[i]));\n                        break;\n\n                }\n            }\n            //  把结果集数组转换成\"xxx=111&yyy=333&zzz=444\"的形式\n            res = res.join(\"&\").replace(\"%20\", \"+\")\n        }\n        return (\"\" + res);\n    }\n\n    /**\n     * 深层遍历一个数组\n     * @param  {[type]} array [description]\n     * @param  {[type]} key   [description]\n     * @return {[type]}       [description]\n     */\n    function _loopArray(array, key) {\n        var res = [],\n            typeIn;\n        for (var i = 0, len = array.length; i < len; i++) {\n        \n            //  获取每一项的类名,如果是Object/则递归调用_loopArray/_loopObject,传入当前项和属性名,处理子项,再放到结果集中\n            typeIn = _typeOf(array[i]);\n            switch (typeIn) {\n\n                case \"Array\":\n                    res.push(_loopArray(array[i], (key + \"[\" + i + \"]\")));\n                    break;\n\n                case \"Object\":\n                    res.push(_loopObject(array[i], (key + \"[\" + i + \"]\")));\n                    break;\n\n                //\t其他类型的直接推到结果集数组\n                default:\n                    res.push(_encode(key + \"[]\") + \"=\" + _encode((\"\" + array[i])));\n                    break;\n\n            }\n        }\n        \n        //  把结果集转换成\"xxx=111&yyy=333&zzz=444\"的形式\n        return res.join(\"&\");\n    }\n\n    /**\n     * 深层遍历一个对象\n     * @param  {[type]} object [description]\n     * @param  {[type]} key    [description]\n     * @return {[type]}        [description]\n     */\n    function _loopObject(object, key) {\n        var res = [],\n            typeIn;\n        for (var i in object) {\n            //  取得一个当前key对应value的类名,如果是Object/Array,则进行递归调用\n            typeIn = _typeOf(object[i]);\n            switch (typeIn) {\n                case \"Array\":\n                    res.push(_loopArray(object[i], key + \"[\" + i + \"]\"));\n                    break;\n\n                case \"Object\":\n                    res.push(_loopObject(object[i], key + \"[\" + i + \"]\"));\n                    break;\n\n                //\t其他类型的直接推到结果集数组中\n                default:\n                    res.push(_encode(key + \"[\" + i + \"]\") + \"=\" + _encode((\"\" + object[i])));\n                    break;\n            }\n        }\n        \n        //  把结果集转换成\"xxx=111&yyy=333&zzz=444\"的形式\n        return res.join(\"&\");\n    }\n\n下面我们模拟几个复杂点的对象,调用封装的序列化方法,和$.param进行对比:\n\n    var obj = {\n        string: \"string\",\n        number: 1,\n        array: [1, 2, 3, 4, 5]\n    };\n\n    var obj2 = {\n        string: \"string\",\n        number: 1,\n        array: [\n            1, 2, 3, 4, 5, {\n                key1: \"value1\",\n                key2: \"value2\",\n                key3: \"value3\"\n            }\n        ]\n    };\n\n    var obj3 = {\n        array: [1, 2, 3, 4, 5],\n        arrayobject: [{\n            key1: \"value1\",\n            key2: \"value2\",\n            key3: \"value3\"\n        }, {\n            key1: \"value1\",\n            key2: \"value2\",\n            key3: \"value3\"\n        }, {\n            key1: \"value1\",\n            key2: \"value2\",\n            key3: \"value3\"\n        }]\n    };\n\n    var deepObj1 = {\n        arr: [{\n            string: \"string\",\n            number: 1,\n            arr: [1, 2, 3, 4],\n            mixArr: [{\n                key1: \"value1\",\n                key2: \"value2\"\n            }, {\n                key1: \"value1\",\n                key2: \"value2\"\n            }, {\n                key1: \"value1\",\n                key2: \"value2\"\n            }]\n        }]\n    };\n\n    var deepObj2 = {\n        obj: {\n            key1: \"value1\",\n            key2: \"value2\",\n            key3: \"value3\"\n        },\n        array: [1, 2, 3, 4, 5],\n        objectArray: {\n            array: [1, 2, 3, 4, 5, {\n                key1: \"value1\",\n                key2: \"value2\",\n                key3: \"value3\"\n            }]\n        },\n        arrayObj: [{\n            key1: \"value1\",\n            key2: \"value2\",\n            key3: \"value3\"\n        }, {\n            key1: \"value1\",\n            key2: \"value2\",\n            key3: \"value3\"\n        }, {\n            key1: \"value1\",\n            key2: \"value2\",\n            key3: \"value3\"\n        }]\n    };\n\n    //  打开控制台的console面板,查看输出\n\n    console.group(\"serialize obj\");\n    console.log(_serializenData(obj));  //  ...\n    console.log($.param(obj));  //  ...\n    console.log(_serializenData(obj) === $.param(obj)); //  true\n    console.groupEnd();\n\n\tconsole.group(\"serialize obj2\");\n    console.log(_serializenData(obj2)); //  ...\n    console.log($.param(obj2)); //  ...\n    console.log(_serializenData(obj2) === $.param(obj2));   //  true\n    console.groupEnd();    \n\n\tconsole.group(\"serialize obj3\");\n    console.log(_serializenData(obj3)); //  ...\n    console.log($.param(obj3)); //  ...\n    console.log(_serializenData(obj3) === $.param(obj3));   //  true\n    console.groupEnd();\n\n\tconsole.group(\"serialize deepObj1\");\n    console.log(_serializenData(deepObj1)); //  ...\n    console.log($.param(deepObj1)); //  ...\n    console.log(_serializenData(deepObj1) === $.param(deepObj1));   //  true\n    console.groupEnd();\n\n\tconsole.group(\"serialize deepObj2\");\n    console.log(_serializenData(deepObj2)); //  ...\n    console.log($.param(deepObj2)); //  ...\n    console.log(_serializenData(deepObj2) === $.param(deepObj2));   //  true\n    console.groupEnd();\n","source":"_posts/2016-09-17-javascript-serialize.md","raw":"---\nlayout: post\ntitle: javascript中的序列化\ndate: 2016-09-17\ncategories: [javascript, 序列化]\n---\n在用jQuery发送ajax(POST)请求的时候,最常见的提交方式就是\"application/x-www-form-urlencoded\",通常都会传入一个data属性作为传输给后端的数据,在ajax发送之前,那么我们直接如果直接传入把这个对象传递给后端,后端就不能对该对象进行解析,因为对象会被转成字符串\"[object Object]\",所以就需要我们对该对象进行url编码,并且转换成字符串,再传给后端。\n\n假设我们先传递一个简单的对象(所有的key对应的value都不是引用类型[Array、Object]),就像下面这样:\n\n    {\n        string: \"string\",\n        number: 1\n    }\n    \n用jQuery中的$.ajax方法,POST提交,打开请求面板,在form data那边,点击view source,可以看到下面这一串字符串,就像下面的样子:\n\n    string=string&number=1\n\n在jQuery中,$.param这个方法可以实现进行url编码的作用。\n\n现在可以自己实现一个:\n\n    //  获取对象上的类名\n    function _typeOf(obj) {\n        return {}.toString.call(obj).slice(8, -1);\n    }\n\n    //  encodeURIComponent简写\n    function _encode(data) {\n        data = data || \"\";\n        return encodeURIComponent(data);\n    }\n\n    //  序列化主函数\n    function _serializenData(data) {\n        var res = data,\n            typeIn;\n            \n        //  判断传入的是否是一个Object类型的数据\n        if (_typeOf(data) === \"Object\") {\n            res = [];\n            for (var i in data) {\n                typeIn = _typeOf(data[i]);\n                switch (typeIn) {\n\n                    //  遇到Object、Array时需要进行遍历或者枚举,对其内部元素、属性做处理后再放到结果集数组中\n                    case \"Object\":\n                        res.push(_loopObject(data[i], i));\n                        break;\n\n                    case \"Array\":\n                        res.push(_loopArray(data[i], i));\n                        break;\n\n                    //  其他类型直接推到结果集数组\n                    default:\n                        res.push(_encode(i) + \"=\" + _encode(data[i]));\n                        break;\n\n                }\n            }\n            //  把结果集数组转换成\"xxx=111&yyy=333&zzz=444\"的形式\n            res = res.join(\"&\").replace(\"%20\", \"+\")\n        }\n        return (\"\" + res);\n    }\n\n    /**\n     * 深层遍历一个数组\n     * @param  {[type]} array [description]\n     * @param  {[type]} key   [description]\n     * @return {[type]}       [description]\n     */\n    function _loopArray(array, key) {\n        var res = [],\n            typeIn;\n        for (var i = 0, len = array.length; i < len; i++) {\n        \n            //  获取每一项的类名,如果是Object/则递归调用_loopArray/_loopObject,传入当前项和属性名,处理子项,再放到结果集中\n            typeIn = _typeOf(array[i]);\n            switch (typeIn) {\n\n                case \"Array\":\n                    res.push(_loopArray(array[i], (key + \"[\" + i + \"]\")));\n                    break;\n\n                case \"Object\":\n                    res.push(_loopObject(array[i], (key + \"[\" + i + \"]\")));\n                    break;\n\n                //\t其他类型的直接推到结果集数组\n                default:\n                    res.push(_encode(key + \"[]\") + \"=\" + _encode((\"\" + array[i])));\n                    break;\n\n            }\n        }\n        \n        //  把结果集转换成\"xxx=111&yyy=333&zzz=444\"的形式\n        return res.join(\"&\");\n    }\n\n    /**\n     * 深层遍历一个对象\n     * @param  {[type]} object [description]\n     * @param  {[type]} key    [description]\n     * @return {[type]}        [description]\n     */\n    function _loopObject(object, key) {\n        var res = [],\n            typeIn;\n        for (var i in object) {\n            //  取得一个当前key对应value的类名,如果是Object/Array,则进行递归调用\n            typeIn = _typeOf(object[i]);\n            switch (typeIn) {\n                case \"Array\":\n                    res.push(_loopArray(object[i], key + \"[\" + i + \"]\"));\n                    break;\n\n                case \"Object\":\n                    res.push(_loopObject(object[i], key + \"[\" + i + \"]\"));\n                    break;\n\n                //\t其他类型的直接推到结果集数组中\n                default:\n                    res.push(_encode(key + \"[\" + i + \"]\") + \"=\" + _encode((\"\" + object[i])));\n                    break;\n            }\n        }\n        \n        //  把结果集转换成\"xxx=111&yyy=333&zzz=444\"的形式\n        return res.join(\"&\");\n    }\n\n下面我们模拟几个复杂点的对象,调用封装的序列化方法,和$.param进行对比:\n\n    var obj = {\n        string: \"string\",\n        number: 1,\n        array: [1, 2, 3, 4, 5]\n    };\n\n    var obj2 = {\n        string: \"string\",\n        number: 1,\n        array: [\n            1, 2, 3, 4, 5, {\n                key1: \"value1\",\n                key2: \"value2\",\n                key3: \"value3\"\n            }\n        ]\n    };\n\n    var obj3 = {\n        array: [1, 2, 3, 4, 5],\n        arrayobject: [{\n            key1: \"value1\",\n            key2: \"value2\",\n            key3: \"value3\"\n        }, {\n            key1: \"value1\",\n            key2: \"value2\",\n            key3: \"value3\"\n        }, {\n            key1: \"value1\",\n            key2: \"value2\",\n            key3: \"value3\"\n        }]\n    };\n\n    var deepObj1 = {\n        arr: [{\n            string: \"string\",\n            number: 1,\n            arr: [1, 2, 3, 4],\n            mixArr: [{\n                key1: \"value1\",\n                key2: \"value2\"\n            }, {\n                key1: \"value1\",\n                key2: \"value2\"\n            }, {\n                key1: \"value1\",\n                key2: \"value2\"\n            }]\n        }]\n    };\n\n    var deepObj2 = {\n        obj: {\n            key1: \"value1\",\n            key2: \"value2\",\n            key3: \"value3\"\n        },\n        array: [1, 2, 3, 4, 5],\n        objectArray: {\n            array: [1, 2, 3, 4, 5, {\n                key1: \"value1\",\n                key2: \"value2\",\n                key3: \"value3\"\n            }]\n        },\n        arrayObj: [{\n            key1: \"value1\",\n            key2: \"value2\",\n            key3: \"value3\"\n        }, {\n            key1: \"value1\",\n            key2: \"value2\",\n            key3: \"value3\"\n        }, {\n            key1: \"value1\",\n            key2: \"value2\",\n            key3: \"value3\"\n        }]\n    };\n\n    //  打开控制台的console面板,查看输出\n\n    console.group(\"serialize obj\");\n    console.log(_serializenData(obj));  //  ...\n    console.log($.param(obj));  //  ...\n    console.log(_serializenData(obj) === $.param(obj)); //  true\n    console.groupEnd();\n\n\tconsole.group(\"serialize obj2\");\n    console.log(_serializenData(obj2)); //  ...\n    console.log($.param(obj2)); //  ...\n    console.log(_serializenData(obj2) === $.param(obj2));   //  true\n    console.groupEnd();    \n\n\tconsole.group(\"serialize obj3\");\n    console.log(_serializenData(obj3)); //  ...\n    console.log($.param(obj3)); //  ...\n    console.log(_serializenData(obj3) === $.param(obj3));   //  true\n    console.groupEnd();\n\n\tconsole.group(\"serialize deepObj1\");\n    console.log(_serializenData(deepObj1)); //  ...\n    console.log($.param(deepObj1)); //  ...\n    console.log(_serializenData(deepObj1) === $.param(deepObj1));   //  true\n    console.groupEnd();\n\n\tconsole.group(\"serialize deepObj2\");\n    console.log(_serializenData(deepObj2)); //  ...\n    console.log($.param(deepObj2)); //  ...\n    console.log(_serializenData(deepObj2) === $.param(deepObj2));   //  true\n    console.groupEnd();\n","slug":"2016-09-17-javascript-serialize","published":1,"updated":"2016-11-09T14:02:44.000Z","_id":"civ7fseg1001wt95fdzpr3210","comments":1,"photos":[],"link":"","content":"<p>在用jQuery发送ajax(POST)请求的时候,最常见的提交方式就是”application/x-www-form-urlencoded”,通常都会传入一个data属性作为传输给后端的数据,在ajax发送之前,那么我们直接如果直接传入把这个对象传递给后端,后端就不能对该对象进行解析,因为对象会被转成字符串”[object Object]”,所以就需要我们对该对象进行url编码,并且转换成字符串,再传给后端。</p>\n<p>假设我们先传递一个简单的对象(所有的key对应的value都不是引用类型[Array、Object]),就像下面这样:</p>\n<pre><code>{\n    string: &quot;string&quot;,\n    number: 1\n}\n</code></pre><p>用jQuery中的$.ajax方法,POST提交,打开请求面板,在form data那边,点击view source,可以看到下面这一串字符串,就像下面的样子:</p>\n<pre><code>string=string&amp;number=1\n</code></pre><p>在jQuery中,$.param这个方法可以实现进行url编码的作用。</p>\n<p>现在可以自己实现一个:</p>\n<pre><code>//  获取对象上的类名\nfunction _typeOf(obj) {\n    return {}.toString.call(obj).slice(8, -1);\n}\n\n//  encodeURIComponent简写\nfunction _encode(data) {\n    data = data || &quot;&quot;;\n    return encodeURIComponent(data);\n}\n\n//  序列化主函数\nfunction _serializenData(data) {\n    var res = data,\n        typeIn;\n\n    //  判断传入的是否是一个Object类型的数据\n    if (_typeOf(data) === &quot;Object&quot;) {\n        res = [];\n        for (var i in data) {\n            typeIn = _typeOf(data[i]);\n            switch (typeIn) {\n\n                //  遇到Object、Array时需要进行遍历或者枚举,对其内部元素、属性做处理后再放到结果集数组中\n                case &quot;Object&quot;:\n                    res.push(_loopObject(data[i], i));\n                    break;\n\n                case &quot;Array&quot;:\n                    res.push(_loopArray(data[i], i));\n                    break;\n\n                //  其他类型直接推到结果集数组\n                default:\n                    res.push(_encode(i) + &quot;=&quot; + _encode(data[i]));\n                    break;\n\n            }\n        }\n        //  把结果集数组转换成&quot;xxx=111&amp;yyy=333&amp;zzz=444&quot;的形式\n        res = res.join(&quot;&amp;&quot;).replace(&quot;%20&quot;, &quot;+&quot;)\n    }\n    return (&quot;&quot; + res);\n}\n\n/**\n * 深层遍历一个数组\n * @param  {[type]} array [description]\n * @param  {[type]} key   [description]\n * @return {[type]}       [description]\n */\nfunction _loopArray(array, key) {\n    var res = [],\n        typeIn;\n    for (var i = 0, len = array.length; i &lt; len; i++) {\n\n        //  获取每一项的类名,如果是Object/则递归调用_loopArray/_loopObject,传入当前项和属性名,处理子项,再放到结果集中\n        typeIn = _typeOf(array[i]);\n        switch (typeIn) {\n\n            case &quot;Array&quot;:\n                res.push(_loopArray(array[i], (key + &quot;[&quot; + i + &quot;]&quot;)));\n                break;\n\n            case &quot;Object&quot;:\n                res.push(_loopObject(array[i], (key + &quot;[&quot; + i + &quot;]&quot;)));\n                break;\n\n            //    其他类型的直接推到结果集数组\n            default:\n                res.push(_encode(key + &quot;[]&quot;) + &quot;=&quot; + _encode((&quot;&quot; + array[i])));\n                break;\n\n        }\n    }\n\n    //  把结果集转换成&quot;xxx=111&amp;yyy=333&amp;zzz=444&quot;的形式\n    return res.join(&quot;&amp;&quot;);\n}\n\n/**\n * 深层遍历一个对象\n * @param  {[type]} object [description]\n * @param  {[type]} key    [description]\n * @return {[type]}        [description]\n */\nfunction _loopObject(object, key) {\n    var res = [],\n        typeIn;\n    for (var i in object) {\n        //  取得一个当前key对应value的类名,如果是Object/Array,则进行递归调用\n        typeIn = _typeOf(object[i]);\n        switch (typeIn) {\n            case &quot;Array&quot;:\n                res.push(_loopArray(object[i], key + &quot;[&quot; + i + &quot;]&quot;));\n                break;\n\n            case &quot;Object&quot;:\n                res.push(_loopObject(object[i], key + &quot;[&quot; + i + &quot;]&quot;));\n                break;\n\n            //    其他类型的直接推到结果集数组中\n            default:\n                res.push(_encode(key + &quot;[&quot; + i + &quot;]&quot;) + &quot;=&quot; + _encode((&quot;&quot; + object[i])));\n                break;\n        }\n    }\n\n    //  把结果集转换成&quot;xxx=111&amp;yyy=333&amp;zzz=444&quot;的形式\n    return res.join(&quot;&amp;&quot;);\n}\n</code></pre><p>下面我们模拟几个复杂点的对象,调用封装的序列化方法,和$.param进行对比:</p>\n<pre><code>var obj = {\n    string: &quot;string&quot;,\n    number: 1,\n    array: [1, 2, 3, 4, 5]\n};\n\nvar obj2 = {\n    string: &quot;string&quot;,\n    number: 1,\n    array: [\n        1, 2, 3, 4, 5, {\n            key1: &quot;value1&quot;,\n            key2: &quot;value2&quot;,\n            key3: &quot;value3&quot;\n        }\n    ]\n};\n\nvar obj3 = {\n    array: [1, 2, 3, 4, 5],\n    arrayobject: [{\n        key1: &quot;value1&quot;,\n        key2: &quot;value2&quot;,\n        key3: &quot;value3&quot;\n    }, {\n        key1: &quot;value1&quot;,\n        key2: &quot;value2&quot;,\n        key3: &quot;value3&quot;\n    }, {\n        key1: &quot;value1&quot;,\n        key2: &quot;value2&quot;,\n        key3: &quot;value3&quot;\n    }]\n};\n\nvar deepObj1 = {\n    arr: [{\n        string: &quot;string&quot;,\n        number: 1,\n        arr: [1, 2, 3, 4],\n        mixArr: [{\n            key1: &quot;value1&quot;,\n            key2: &quot;value2&quot;\n        }, {\n            key1: &quot;value1&quot;,\n            key2: &quot;value2&quot;\n        }, {\n            key1: &quot;value1&quot;,\n            key2: &quot;value2&quot;\n        }]\n    }]\n};\n\nvar deepObj2 = {\n    obj: {\n        key1: &quot;value1&quot;,\n        key2: &quot;value2&quot;,\n        key3: &quot;value3&quot;\n    },\n    array: [1, 2, 3, 4, 5],\n    objectArray: {\n        array: [1, 2, 3, 4, 5, {\n            key1: &quot;value1&quot;,\n            key2: &quot;value2&quot;,\n            key3: &quot;value3&quot;\n        }]\n    },\n    arrayObj: [{\n        key1: &quot;value1&quot;,\n        key2: &quot;value2&quot;,\n        key3: &quot;value3&quot;\n    }, {\n        key1: &quot;value1&quot;,\n        key2: &quot;value2&quot;,\n        key3: &quot;value3&quot;\n    }, {\n        key1: &quot;value1&quot;,\n        key2: &quot;value2&quot;,\n        key3: &quot;value3&quot;\n    }]\n};\n\n//  打开控制台的console面板,查看输出\n\nconsole.group(&quot;serialize obj&quot;);\nconsole.log(_serializenData(obj));  //  ...\nconsole.log($.param(obj));  //  ...\nconsole.log(_serializenData(obj) === $.param(obj)); //  true\nconsole.groupEnd();\n\nconsole.group(&quot;serialize obj2&quot;);\nconsole.log(_serializenData(obj2)); //  ...\nconsole.log($.param(obj2)); //  ...\nconsole.log(_serializenData(obj2) === $.param(obj2));   //  true\nconsole.groupEnd();    \n\nconsole.group(&quot;serialize obj3&quot;);\nconsole.log(_serializenData(obj3)); //  ...\nconsole.log($.param(obj3)); //  ...\nconsole.log(_serializenData(obj3) === $.param(obj3));   //  true\nconsole.groupEnd();\n\nconsole.group(&quot;serialize deepObj1&quot;);\nconsole.log(_serializenData(deepObj1)); //  ...\nconsole.log($.param(deepObj1)); //  ...\nconsole.log(_serializenData(deepObj1) === $.param(deepObj1));   //  true\nconsole.groupEnd();\n\nconsole.group(&quot;serialize deepObj2&quot;);\nconsole.log(_serializenData(deepObj2)); //  ...\nconsole.log($.param(deepObj2)); //  ...\nconsole.log(_serializenData(deepObj2) === $.param(deepObj2));   //  true\nconsole.groupEnd();\n</code></pre>","excerpt":"","more":"<p>在用jQuery发送ajax(POST)请求的时候,最常见的提交方式就是”application/x-www-form-urlencoded”,通常都会传入一个data属性作为传输给后端的数据,在ajax发送之前,那么我们直接如果直接传入把这个对象传递给后端,后端就不能对该对象进行解析,因为对象会被转成字符串”[object Object]”,所以就需要我们对该对象进行url编码,并且转换成字符串,再传给后端。</p>\n<p>假设我们先传递一个简单的对象(所有的key对应的value都不是引用类型[Array、Object]),就像下面这样:</p>\n<pre><code>{\n    string: &quot;string&quot;,\n    number: 1\n}\n</code></pre><p>用jQuery中的$.ajax方法,POST提交,打开请求面板,在form data那边,点击view source,可以看到下面这一串字符串,就像下面的样子:</p>\n<pre><code>string=string&amp;number=1\n</code></pre><p>在jQuery中,$.param这个方法可以实现进行url编码的作用。</p>\n<p>现在可以自己实现一个:</p>\n<pre><code>//  获取对象上的类名\nfunction _typeOf(obj) {\n    return {}.toString.call(obj).slice(8, -1);\n}\n\n//  encodeURIComponent简写\nfunction _encode(data) {\n    data = data || &quot;&quot;;\n    return encodeURIComponent(data);\n}\n\n//  序列化主函数\nfunction _serializenData(data) {\n    var res = data,\n        typeIn;\n\n    //  判断传入的是否是一个Object类型的数据\n    if (_typeOf(data) === &quot;Object&quot;) {\n        res = [];\n        for (var i in data) {\n            typeIn = _typeOf(data[i]);\n            switch (typeIn) {\n\n                //  遇到Object、Array时需要进行遍历或者枚举,对其内部元素、属性做处理后再放到结果集数组中\n                case &quot;Object&quot;:\n                    res.push(_loopObject(data[i], i));\n                    break;\n\n                case &quot;Array&quot;:\n                    res.push(_loopArray(data[i], i));\n                    break;\n\n                //  其他类型直接推到结果集数组\n                default:\n                    res.push(_encode(i) + &quot;=&quot; + _encode(data[i]));\n                    break;\n\n            }\n        }\n        //  把结果集数组转换成&quot;xxx=111&amp;yyy=333&amp;zzz=444&quot;的形式\n        res = res.join(&quot;&amp;&quot;).replace(&quot;%20&quot;, &quot;+&quot;)\n    }\n    return (&quot;&quot; + res);\n}\n\n/**\n * 深层遍历一个数组\n * @param  {[type]} array [description]\n * @param  {[type]} key   [description]\n * @return {[type]}       [description]\n */\nfunction _loopArray(array, key) {\n    var res = [],\n        typeIn;\n    for (var i = 0, len = array.length; i &lt; len; i++) {\n\n        //  获取每一项的类名,如果是Object/则递归调用_loopArray/_loopObject,传入当前项和属性名,处理子项,再放到结果集中\n        typeIn = _typeOf(array[i]);\n        switch (typeIn) {\n\n            case &quot;Array&quot;:\n                res.push(_loopArray(array[i], (key + &quot;[&quot; + i + &quot;]&quot;)));\n                break;\n\n            case &quot;Object&quot;:\n                res.push(_loopObject(array[i], (key + &quot;[&quot; + i + &quot;]&quot;)));\n                break;\n\n            //    其他类型的直接推到结果集数组\n            default:\n                res.push(_encode(key + &quot;[]&quot;) + &quot;=&quot; + _encode((&quot;&quot; + array[i])));\n                break;\n\n        }\n    }\n\n    //  把结果集转换成&quot;xxx=111&amp;yyy=333&amp;zzz=444&quot;的形式\n    return res.join(&quot;&amp;&quot;);\n}\n\n/**\n * 深层遍历一个对象\n * @param  {[type]} object [description]\n * @param  {[type]} key    [description]\n * @return {[type]}        [description]\n */\nfunction _loopObject(object, key) {\n    var res = [],\n        typeIn;\n    for (var i in object) {\n        //  取得一个当前key对应value的类名,如果是Object/Array,则进行递归调用\n        typeIn = _typeOf(object[i]);\n        switch (typeIn) {\n            case &quot;Array&quot;:\n                res.push(_loopArray(object[i], key + &quot;[&quot; + i + &quot;]&quot;));\n                break;\n\n            case &quot;Object&quot;:\n                res.push(_loopObject(object[i], key + &quot;[&quot; + i + &quot;]&quot;));\n                break;\n\n            //    其他类型的直接推到结果集数组中\n            default:\n                res.push(_encode(key + &quot;[&quot; + i + &quot;]&quot;) + &quot;=&quot; + _encode((&quot;&quot; + object[i])));\n                break;\n        }\n    }\n\n    //  把结果集转换成&quot;xxx=111&amp;yyy=333&amp;zzz=444&quot;的形式\n    return res.join(&quot;&amp;&quot;);\n}\n</code></pre><p>下面我们模拟几个复杂点的对象,调用封装的序列化方法,和$.param进行对比:</p>\n<pre><code>var obj = {\n    string: &quot;string&quot;,\n    number: 1,\n    array: [1, 2, 3, 4, 5]\n};\n\nvar obj2 = {\n    string: &quot;string&quot;,\n    number: 1,\n    array: [\n        1, 2, 3, 4, 5, {\n            key1: &quot;value1&quot;,\n            key2: &quot;value2&quot;,\n            key3: &quot;value3&quot;\n        }\n    ]\n};\n\nvar obj3 = {\n    array: [1, 2, 3, 4, 5],\n    arrayobject: [{\n        key1: &quot;value1&quot;,\n        key2: &quot;value2&quot;,\n        key3: &quot;value3&quot;\n    }, {\n        key1: &quot;value1&quot;,\n        key2: &quot;value2&quot;,\n        key3: &quot;value3&quot;\n    }, {\n        key1: &quot;value1&quot;,\n        key2: &quot;value2&quot;,\n        key3: &quot;value3&quot;\n    }]\n};\n\nvar deepObj1 = {\n    arr: [{\n        string: &quot;string&quot;,\n        number: 1,\n        arr: [1, 2, 3, 4],\n        mixArr: [{\n            key1: &quot;value1&quot;,\n            key2: &quot;value2&quot;\n        }, {\n            key1: &quot;value1&quot;,\n            key2: &quot;value2&quot;\n        }, {\n            key1: &quot;value1&quot;,\n            key2: &quot;value2&quot;\n        }]\n    }]\n};\n\nvar deepObj2 = {\n    obj: {\n        key1: &quot;value1&quot;,\n        key2: &quot;value2&quot;,\n        key3: &quot;value3&quot;\n    },\n    array: [1, 2, 3, 4, 5],\n    objectArray: {\n        array: [1, 2, 3, 4, 5, {\n            key1: &quot;value1&quot;,\n            key2: &quot;value2&quot;,\n            key3: &quot;value3&quot;\n        }]\n    },\n    arrayObj: [{\n        key1: &quot;value1&quot;,\n        key2: &quot;value2&quot;,\n        key3: &quot;value3&quot;\n    }, {\n        key1: &quot;value1&quot;,\n        key2: &quot;value2&quot;,\n        key3: &quot;value3&quot;\n    }, {\n        key1: &quot;value1&quot;,\n        key2: &quot;value2&quot;,\n        key3: &quot;value3&quot;\n    }]\n};\n\n//  打开控制台的console面板,查看输出\n\nconsole.group(&quot;serialize obj&quot;);\nconsole.log(_serializenData(obj));  //  ...\nconsole.log($.param(obj));  //  ...\nconsole.log(_serializenData(obj) === $.param(obj)); //  true\nconsole.groupEnd();\n\nconsole.group(&quot;serialize obj2&quot;);\nconsole.log(_serializenData(obj2)); //  ...\nconsole.log($.param(obj2)); //  ...\nconsole.log(_serializenData(obj2) === $.param(obj2));   //  true\nconsole.groupEnd();    \n\nconsole.group(&quot;serialize obj3&quot;);\nconsole.log(_serializenData(obj3)); //  ...\nconsole.log($.param(obj3)); //  ...\nconsole.log(_serializenData(obj3) === $.param(obj3));   //  true\nconsole.groupEnd();\n\nconsole.group(&quot;serialize deepObj1&quot;);\nconsole.log(_serializenData(deepObj1)); //  ...\nconsole.log($.param(deepObj1)); //  ...\nconsole.log(_serializenData(deepObj1) === $.param(deepObj1));   //  true\nconsole.groupEnd();\n\nconsole.group(&quot;serialize deepObj2&quot;);\nconsole.log(_serializenData(deepObj2)); //  ...\nconsole.log($.param(deepObj2)); //  ...\nconsole.log(_serializenData(deepObj2) === $.param(deepObj2));   //  true\nconsole.groupEnd();\n</code></pre>"},{"layout":"post","title":"IE下AngularJs中的ajax缓存","date":"2016-11-01T16:00:00.000Z","_content":"\n在单页应用越来越普及的今天,越来越多的项目都会采用这种方案,这几天用AngularJs做了一个PC端应用,有登录注册的功能,登录注册的功能是通过ajax实现的,在登录注册以后页面不刷新,只修改$rootScope下的某些属性值,然后在页面里面通过ng-if之类的指令来控制相关元素的显示隐藏。\n\n之前的大概实现如下:\n\n    //  js\n    var app = angular.module(\"app\", []);\n    app.run([\"$rootScope\", \"$http\", function($rootScope, $http) {\n        $rootScope.isLogin = false;\n        $rootScope.$on(\"$routeChangeStart\", function (event, next, current) {\n        $http.get(\"xxxx\")\n            .success(function(res) {\n                $rootScope.isLogin = !!(res.isLogin);\n                //  ...\n            })\n            .error(function() {\n                //  ...\n            });\n        });\n    }]);\n\n    //  HTML\n    <div class=\"container\">\n        <a href=\"/user/center\" ng-if=\"isLogin\">用户中心</a>\n        <a href=\"javascript:;\" ng-click=\"logout()\" ng-if=\"isLogin\">登出</a>\n        <a href=\"/login\" ng-if=\"!isLogin\">登录</a>\n    </div>\n\n后来发现在Chrome/Firefox下都是好的,到了IE下登录以后不刷新就显示不对。原来以为是ng-if在IE下重新渲染过慢的问题,改成ng-show以后还是不行,然后看http状态码,发现是304,想到可能和缓存有关系,后来改了配置中关键ajax请求那边的东西,发现可以了,核心代码如下:\n\n\n    app.config([\"$routeProvider\", \"$httpProvider\", function($routeProvider, $httpProvider){\n        //  ...\n        \n        if (!$httpProvider.defaults.headers.get) {\n            $httpProvider.defaults.headers.get = {};\n        }\n        $httpProvider.defaults.headers.common[\"X-Requested-With\"] = \"XMLHttpRequest\";\n        $httpProvider.defaults.headers.get[\"Cache-Control\"] = \"no-cache\";\n        $httpProvider.defaults.headers.get[\"Pragma\"] = \"no-cache\";\n    }]);\n\n","source":"_posts/2016-11-02-ie-ajax-cache.md","raw":"---\nlayout: post\ntitle: IE下AngularJs中的ajax缓存\ndate: 2016-11-02\ncategories: [javascript, AngularJs, ajax]\n---\n\n在单页应用越来越普及的今天,越来越多的项目都会采用这种方案,这几天用AngularJs做了一个PC端应用,有登录注册的功能,登录注册的功能是通过ajax实现的,在登录注册以后页面不刷新,只修改$rootScope下的某些属性值,然后在页面里面通过ng-if之类的指令来控制相关元素的显示隐藏。\n\n之前的大概实现如下:\n\n    //  js\n    var app = angular.module(\"app\", []);\n    app.run([\"$rootScope\", \"$http\", function($rootScope, $http) {\n        $rootScope.isLogin = false;\n        $rootScope.$on(\"$routeChangeStart\", function (event, next, current) {\n        $http.get(\"xxxx\")\n            .success(function(res) {\n                $rootScope.isLogin = !!(res.isLogin);\n                //  ...\n            })\n            .error(function() {\n                //  ...\n            });\n        });\n    }]);\n\n    //  HTML\n    <div class=\"container\">\n        <a href=\"/user/center\" ng-if=\"isLogin\">用户中心</a>\n        <a href=\"javascript:;\" ng-click=\"logout()\" ng-if=\"isLogin\">登出</a>\n        <a href=\"/login\" ng-if=\"!isLogin\">登录</a>\n    </div>\n\n后来发现在Chrome/Firefox下都是好的,到了IE下登录以后不刷新就显示不对。原来以为是ng-if在IE下重新渲染过慢的问题,改成ng-show以后还是不行,然后看http状态码,发现是304,想到可能和缓存有关系,后来改了配置中关键ajax请求那边的东西,发现可以了,核心代码如下:\n\n\n    app.config([\"$routeProvider\", \"$httpProvider\", function($routeProvider, $httpProvider){\n        //  ...\n        \n        if (!$httpProvider.defaults.headers.get) {\n            $httpProvider.defaults.headers.get = {};\n        }\n        $httpProvider.defaults.headers.common[\"X-Requested-With\"] = \"XMLHttpRequest\";\n        $httpProvider.defaults.headers.get[\"Cache-Control\"] = \"no-cache\";\n        $httpProvider.defaults.headers.get[\"Pragma\"] = \"no-cache\";\n    }]);\n\n","slug":"2016-11-02-ie-ajax-cache","published":1,"updated":"2016-11-09T14:02:49.000Z","_id":"civ7fseg2001yt95fs48maore","comments":1,"photos":[],"link":"","content":"<p>在单页应用越来越普及的今天,越来越多的项目都会采用这种方案,这几天用AngularJs做了一个PC端应用,有登录注册的功能,登录注册的功能是通过ajax实现的,在登录注册以后页面不刷新,只修改$rootScope下的某些属性值,然后在页面里面通过ng-if之类的指令来控制相关元素的显示隐藏。</p>\n<p>之前的大概实现如下:</p>\n<pre><code>//  js\nvar app = angular.module(&quot;app&quot;, []);\napp.run([&quot;$rootScope&quot;, &quot;$http&quot;, function($rootScope, $http) {\n    $rootScope.isLogin = false;\n    $rootScope.$on(&quot;$routeChangeStart&quot;, function (event, next, current) {\n    $http.get(&quot;xxxx&quot;)\n        .success(function(res) {\n            $rootScope.isLogin = !!(res.isLogin);\n            //  ...\n        })\n        .error(function() {\n            //  ...\n        });\n    });\n}]);\n\n//  HTML\n&lt;div class=&quot;container&quot;&gt;\n    &lt;a href=&quot;/user/center&quot; ng-if=&quot;isLogin&quot;&gt;用户中心&lt;/a&gt;\n    &lt;a href=&quot;javascript:;&quot; ng-click=&quot;logout()&quot; ng-if=&quot;isLogin&quot;&gt;登出&lt;/a&gt;\n    &lt;a href=&quot;/login&quot; ng-if=&quot;!isLogin&quot;&gt;登录&lt;/a&gt;\n&lt;/div&gt;\n</code></pre><p>后来发现在Chrome/Firefox下都是好的,到了IE下登录以后不刷新就显示不对。原来以为是ng-if在IE下重新渲染过慢的问题,改成ng-show以后还是不行,然后看http状态码,发现是304,想到可能和缓存有关系,后来改了配置中关键ajax请求那边的东西,发现可以了,核心代码如下:</p>\n<pre><code>app.config([&quot;$routeProvider&quot;, &quot;$httpProvider&quot;, function($routeProvider, $httpProvider){\n    //  ...\n\n    if (!$httpProvider.defaults.headers.get) {\n        $httpProvider.defaults.headers.get = {};\n    }\n    $httpProvider.defaults.headers.common[&quot;X-Requested-With&quot;] = &quot;XMLHttpRequest&quot;;\n    $httpProvider.defaults.headers.get[&quot;Cache-Control&quot;] = &quot;no-cache&quot;;\n    $httpProvider.defaults.headers.get[&quot;Pragma&quot;] = &quot;no-cache&quot;;\n}]);\n</code></pre>","excerpt":"","more":"<p>在单页应用越来越普及的今天,越来越多的项目都会采用这种方案,这几天用AngularJs做了一个PC端应用,有登录注册的功能,登录注册的功能是通过ajax实现的,在登录注册以后页面不刷新,只修改$rootScope下的某些属性值,然后在页面里面通过ng-if之类的指令来控制相关元素的显示隐藏。</p>\n<p>之前的大概实现如下:</p>\n<pre><code>//  js\nvar app = angular.module(&quot;app&quot;, []);\napp.run([&quot;$rootScope&quot;, &quot;$http&quot;, function($rootScope, $http) {\n    $rootScope.isLogin = false;\n    $rootScope.$on(&quot;$routeChangeStart&quot;, function (event, next, current) {\n    $http.get(&quot;xxxx&quot;)\n        .success(function(res) {\n            $rootScope.isLogin = !!(res.isLogin);\n            //  ...\n        })\n        .error(function() {\n            //  ...\n        });\n    });\n}]);\n\n//  HTML\n&lt;div class=&quot;container&quot;&gt;\n    &lt;a href=&quot;/user/center&quot; ng-if=&quot;isLogin&quot;&gt;用户中心&lt;/a&gt;\n    &lt;a href=&quot;javascript:;&quot; ng-click=&quot;logout()&quot; ng-if=&quot;isLogin&quot;&gt;登出&lt;/a&gt;\n    &lt;a href=&quot;/login&quot; ng-if=&quot;!isLogin&quot;&gt;登录&lt;/a&gt;\n&lt;/div&gt;\n</code></pre><p>后来发现在Chrome/Firefox下都是好的,到了IE下登录以后不刷新就显示不对。原来以为是ng-if在IE下重新渲染过慢的问题,改成ng-show以后还是不行,然后看http状态码,发现是304,想到可能和缓存有关系,后来改了配置中关键ajax请求那边的东西,发现可以了,核心代码如下:</p>\n<pre><code>app.config([&quot;$routeProvider&quot;, &quot;$httpProvider&quot;, function($routeProvider, $httpProvider){\n    //  ...\n\n    if (!$httpProvider.defaults.headers.get) {\n        $httpProvider.defaults.headers.get = {};\n    }\n    $httpProvider.defaults.headers.common[&quot;X-Requested-With&quot;] = &quot;XMLHttpRequest&quot;;\n    $httpProvider.defaults.headers.get[&quot;Cache-Control&quot;] = &quot;no-cache&quot;;\n    $httpProvider.defaults.headers.get[&quot;Pragma&quot;] = &quot;no-cache&quot;;\n}]);\n</code></pre>"},{"layout":"post","title":"async/await学习","date":"2016-11-08T16:00:00.000Z","_content":"\n在处理javascript中异步的时候,回调往往是最让人恶心的,之前介绍过用[Promise](http://123.207.98.169:81/2016/05/04/2016-05-04-es6-promise/)来处理异步的问题,但是即使用上了Promise,在处理回调上还是会有各种嵌套,今天来介绍下ES7中的async/await,由于在Nodejs中还未得到支持,所以需要借助一些npm包来实践,在这里用的是[asyncawait](https://github.com/yortus/asyncawait)。\n\n先来个原生文件读取的例子:\n\n    const fs = require(\"fs\");\n    fs.readFile(\"test.txt\", (ex, res) => {\n       console.log(res.toString()); \n       \n       //   do something...\n       \n       fs.readFile(\"test2.txt\", (ex, res) => {\n            console.log(res.toString());\n            \n            //  do something\n       });\n    });\n    \n    //  控制台输出\n    xxxxx\n    yyyyy\n    \n    \n下面我们再用async/await实现一遍:\n\n    const async = require(\"asyncawait\").async;\n    const await = require(\"asyncawait\").await;\n    let readFile = function(path) {\n        return new Promise((resolve, reject) => {\n            fs.readFile(path, (ex, res) => {\n                if (ex) {\n                    reject(ex);\n                }\n                resolve(res);\n            });\n        });\n    }\n    \n    let asyncReadFile = async(() => {\n        \n        let fs = await (readFile(\"test.txt\"));\n        let fs2 = await (readFile(\"test2.txt\"));\n        \n        console.log(fs.toString());\n        console.log(fs2.toString());\n    });\n    \n    asyncReadFile();\n    \n虽然代码可能比上面的多了一点,但是已经完全看不到回调嵌套的影子了,也能完成同样的功能,何乐而不为。😉\n\n下面我们再来模拟一个异步请求的例子:\n\n    const async = require(\"asyncawait\").async;\n    const await = require(\"asyncawait\").await;\n    const http = require(\"http\");\n    \n    http.createServer((req, res) => {\n\n        switch (req.url) {\n    \n            case \"/async-await\":\n                setTimeout(() => {\n                    res.writeHead(200, { \"Content-Type\": \"text/plain\" });\n                    res.end(\"request end\");\n                }, 5000);\n                break;\n    \n            case \"/async-await2\":\n            \tsetTimeout(() => {\n            \t\tres.writeHead(200, { \"Content-Type\": \"text/plain\" });\n                    res.end(\"request end2\");\n            \t}, 8000);\n            \tbreak;\n    \n        \tdefault:\n        \t\tbreak;\n    \n        }\n    }).listen(3000, \"127.0.0.1\");\n\n    let requestUrl = function(path) {\n        return new Promise((resolve, reject) => {\n            http.get({\n                hostname: 'localhost',\n                port: 3000,\n                path: path,\n                agent: false\n            }, (res) => {\n                res.on(\"data\", (data) => {\n                    resolve(data);\n                });\n                res.on(\"error\", (ex) => {\n                    reject(ex);\n                })\n            });\n        });\n    }\n    \n    let asyncRequest = async(() => {\n        let resp, resp2;\n        await (requestUrl(\"/async-await\").then((res) => {\n        \tconsole.log(res.toString());\n            resp = res.toString();\n        }).catch((ex) => {\n            resp = \"发生错误!\";\n        }));\n    \n        await (requestUrl(\"/async-await2\").then((res) => {\n            resp2 = res.toString();\n        }).catch((ex) => {\n            resp = \"发生错误!\";\n        }));\n        console.log(resp);\n        console.log(resp2);\n    });\n    \n    asyncRequest();\n    \n    //  控制台输出\n    request end\n    request end2\n\n由此我们可以将async/await用在很多地方,比如例子中的文件读取、异步请求、nodejs中的查询数据库等等。\n","source":"_posts/2016-11-09-async:await-tourial.md","raw":"---\nlayout: post\ntitle: async/await学习\ndate: 2016-11-09\ncategories: [javascript, ES7, async/await]\n---\n\n在处理javascript中异步的时候,回调往往是最让人恶心的,之前介绍过用[Promise](http://123.207.98.169:81/2016/05/04/2016-05-04-es6-promise/)来处理异步的问题,但是即使用上了Promise,在处理回调上还是会有各种嵌套,今天来介绍下ES7中的async/await,由于在Nodejs中还未得到支持,所以需要借助一些npm包来实践,在这里用的是[asyncawait](https://github.com/yortus/asyncawait)。\n\n先来个原生文件读取的例子:\n\n    const fs = require(\"fs\");\n    fs.readFile(\"test.txt\", (ex, res) => {\n       console.log(res.toString()); \n       \n       //   do something...\n       \n       fs.readFile(\"test2.txt\", (ex, res) => {\n            console.log(res.toString());\n            \n            //  do something\n       });\n    });\n    \n    //  控制台输出\n    xxxxx\n    yyyyy\n    \n    \n下面我们再用async/await实现一遍:\n\n    const async = require(\"asyncawait\").async;\n    const await = require(\"asyncawait\").await;\n    let readFile = function(path) {\n        return new Promise((resolve, reject) => {\n            fs.readFile(path, (ex, res) => {\n                if (ex) {\n                    reject(ex);\n                }\n                resolve(res);\n            });\n        });\n    }\n    \n    let asyncReadFile = async(() => {\n        \n        let fs = await (readFile(\"test.txt\"));\n        let fs2 = await (readFile(\"test2.txt\"));\n        \n        console.log(fs.toString());\n        console.log(fs2.toString());\n    });\n    \n    asyncReadFile();\n    \n虽然代码可能比上面的多了一点,但是已经完全看不到回调嵌套的影子了,也能完成同样的功能,何乐而不为。😉\n\n下面我们再来模拟一个异步请求的例子:\n\n    const async = require(\"asyncawait\").async;\n    const await = require(\"asyncawait\").await;\n    const http = require(\"http\");\n    \n    http.createServer((req, res) => {\n\n        switch (req.url) {\n    \n            case \"/async-await\":\n                setTimeout(() => {\n                    res.writeHead(200, { \"Content-Type\": \"text/plain\" });\n                    res.end(\"request end\");\n                }, 5000);\n                break;\n    \n            case \"/async-await2\":\n            \tsetTimeout(() => {\n            \t\tres.writeHead(200, { \"Content-Type\": \"text/plain\" });\n                    res.end(\"request end2\");\n            \t}, 8000);\n            \tbreak;\n    \n        \tdefault:\n        \t\tbreak;\n    \n        }\n    }).listen(3000, \"127.0.0.1\");\n\n    let requestUrl = function(path) {\n        return new Promise((resolve, reject) => {\n            http.get({\n                hostname: 'localhost',\n                port: 3000,\n                path: path,\n                agent: false\n            }, (res) => {\n                res.on(\"data\", (data) => {\n                    resolve(data);\n                });\n                res.on(\"error\", (ex) => {\n                    reject(ex);\n                })\n            });\n        });\n    }\n    \n    let asyncRequest = async(() => {\n        let resp, resp2;\n        await (requestUrl(\"/async-await\").then((res) => {\n        \tconsole.log(res.toString());\n            resp = res.toString();\n        }).catch((ex) => {\n            resp = \"发生错误!\";\n        }));\n    \n        await (requestUrl(\"/async-await2\").then((res) => {\n            resp2 = res.toString();\n        }).catch((ex) => {\n            resp = \"发生错误!\";\n        }));\n        console.log(resp);\n        console.log(resp2);\n    });\n    \n    asyncRequest();\n    \n    //  控制台输出\n    request end\n    request end2\n\n由此我们可以将async/await用在很多地方,比如例子中的文件读取、异步请求、nodejs中的查询数据库等等。\n","slug":"2016-11-09-async:await-tourial","published":1,"updated":"2016-11-09T14:03:14.000Z","comments":1,"photos":[],"link":"","_id":"civb0mxh300005m5f43pcrv3h","content":"<p>在处理javascript中异步的时候,回调往往是最让人恶心的,之前介绍过用<a href=\"http://123.207.98.169:81/2016/05/04/2016-05-04-es6-promise/\" target=\"_blank\" rel=\"external\">Promise</a>来处理异步的问题,但是即使用上了Promise,在处理回调上还是会有各种嵌套,今天来介绍下ES7中的async/await,由于在Nodejs中还未得到支持,所以需要借助一些npm包来实践,在这里用的是<a href=\"https://github.com/yortus/asyncawait\" target=\"_blank\" rel=\"external\">asyncawait</a>。</p>\n<p>先来个原生文件读取的例子:</p>\n<pre><code>const fs = require(&quot;fs&quot;);\nfs.readFile(&quot;test.txt&quot;, (ex, res) =&gt; {\n   console.log(res.toString()); \n\n   //   do something...\n\n   fs.readFile(&quot;test2.txt&quot;, (ex, res) =&gt; {\n        console.log(res.toString());\n\n        //  do something\n   });\n});\n\n//  控制台输出\nxxxxx\nyyyyy\n</code></pre><p>下面我们再用async/await实现一遍:</p>\n<pre><code>const async = require(&quot;asyncawait&quot;).async;\nconst await = require(&quot;asyncawait&quot;).await;\nlet readFile = function(path) {\n    return new Promise((resolve, reject) =&gt; {\n        fs.readFile(path, (ex, res) =&gt; {\n            if (ex) {\n                reject(ex);\n            }\n            resolve(res);\n        });\n    });\n}\n\nlet asyncReadFile = async(() =&gt; {\n\n    let fs = await (readFile(&quot;test.txt&quot;));\n    let fs2 = await (readFile(&quot;test2.txt&quot;));\n\n    console.log(fs.toString());\n    console.log(fs2.toString());\n});\n\nasyncReadFile();\n</code></pre><p>虽然代码可能比上面的多了一点,但是已经完全看不到回调嵌套的影子了,也能完成同样的功能,何乐而不为。😉</p>\n<p>下面我们再来模拟一个异步请求的例子:</p>\n<pre><code>const async = require(&quot;asyncawait&quot;).async;\nconst await = require(&quot;asyncawait&quot;).await;\nconst http = require(&quot;http&quot;);\n\nhttp.createServer((req, res) =&gt; {\n\n    switch (req.url) {\n\n        case &quot;/async-await&quot;:\n            setTimeout(() =&gt; {\n                res.writeHead(200, { &quot;Content-Type&quot;: &quot;text/plain&quot; });\n                res.end(&quot;request end&quot;);\n            }, 5000);\n            break;\n\n        case &quot;/async-await2&quot;:\n            setTimeout(() =&gt; {\n                res.writeHead(200, { &quot;Content-Type&quot;: &quot;text/plain&quot; });\n                res.end(&quot;request end2&quot;);\n            }, 8000);\n            break;\n\n        default:\n            break;\n\n    }\n}).listen(3000, &quot;127.0.0.1&quot;);\n\nlet requestUrl = function(path) {\n    return new Promise((resolve, reject) =&gt; {\n        http.get({\n            hostname: &apos;localhost&apos;,\n            port: 3000,\n            path: path,\n            agent: false\n        }, (res) =&gt; {\n            res.on(&quot;data&quot;, (data) =&gt; {\n                resolve(data);\n            });\n            res.on(&quot;error&quot;, (ex) =&gt; {\n                reject(ex);\n            })\n        });\n    });\n}\n\nlet asyncRequest = async(() =&gt; {\n    let resp, resp2;\n    await (requestUrl(&quot;/async-await&quot;).then((res) =&gt; {\n        console.log(res.toString());\n        resp = res.toString();\n    }).catch((ex) =&gt; {\n        resp = &quot;发生错误!&quot;;\n    }));\n\n    await (requestUrl(&quot;/async-await2&quot;).then((res) =&gt; {\n        resp2 = res.toString();\n    }).catch((ex) =&gt; {\n        resp = &quot;发生错误!&quot;;\n    }));\n    console.log(resp);\n    console.log(resp2);\n});\n\nasyncRequest();\n\n//  控制台输出\nrequest end\nrequest end2\n</code></pre><p>由此我们可以将async/await用在很多地方,比如例子中的文件读取、异步请求、nodejs中的查询数据库等等。</p>\n","excerpt":"","more":"<p>在处理javascript中异步的时候,回调往往是最让人恶心的,之前介绍过用<a href=\"http://123.207.98.169:81/2016/05/04/2016-05-04-es6-promise/\">Promise</a>来处理异步的问题,但是即使用上了Promise,在处理回调上还是会有各种嵌套,今天来介绍下ES7中的async/await,由于在Nodejs中还未得到支持,所以需要借助一些npm包来实践,在这里用的是<a href=\"https://github.com/yortus/asyncawait\">asyncawait</a>。</p>\n<p>先来个原生文件读取的例子:</p>\n<pre><code>const fs = require(&quot;fs&quot;);\nfs.readFile(&quot;test.txt&quot;, (ex, res) =&gt; {\n   console.log(res.toString()); \n\n   //   do something...\n\n   fs.readFile(&quot;test2.txt&quot;, (ex, res) =&gt; {\n        console.log(res.toString());\n\n        //  do something\n   });\n});\n\n//  控制台输出\nxxxxx\nyyyyy\n</code></pre><p>下面我们再用async/await实现一遍:</p>\n<pre><code>const async = require(&quot;asyncawait&quot;).async;\nconst await = require(&quot;asyncawait&quot;).await;\nlet readFile = function(path) {\n    return new Promise((resolve, reject) =&gt; {\n        fs.readFile(path, (ex, res) =&gt; {\n            if (ex) {\n                reject(ex);\n            }\n            resolve(res);\n        });\n    });\n}\n\nlet asyncReadFile = async(() =&gt; {\n\n    let fs = await (readFile(&quot;test.txt&quot;));\n    let fs2 = await (readFile(&quot;test2.txt&quot;));\n\n    console.log(fs.toString());\n    console.log(fs2.toString());\n});\n\nasyncReadFile();\n</code></pre><p>虽然代码可能比上面的多了一点,但是已经完全看不到回调嵌套的影子了,也能完成同样的功能,何乐而不为。😉</p>\n<p>下面我们再来模拟一个异步请求的例子:</p>\n<pre><code>const async = require(&quot;asyncawait&quot;).async;\nconst await = require(&quot;asyncawait&quot;).await;\nconst http = require(&quot;http&quot;);\n\nhttp.createServer((req, res) =&gt; {\n\n    switch (req.url) {\n\n        case &quot;/async-await&quot;:\n            setTimeout(() =&gt; {\n                res.writeHead(200, { &quot;Content-Type&quot;: &quot;text/plain&quot; });\n                res.end(&quot;request end&quot;);\n            }, 5000);\n            break;\n\n        case &quot;/async-await2&quot;:\n            setTimeout(() =&gt; {\n                res.writeHead(200, { &quot;Content-Type&quot;: &quot;text/plain&quot; });\n                res.end(&quot;request end2&quot;);\n            }, 8000);\n            break;\n\n        default:\n            break;\n\n    }\n}).listen(3000, &quot;127.0.0.1&quot;);\n\nlet requestUrl = function(path) {\n    return new Promise((resolve, reject) =&gt; {\n        http.get({\n            hostname: &apos;localhost&apos;,\n            port: 3000,\n            path: path,\n            agent: false\n        }, (res) =&gt; {\n            res.on(&quot;data&quot;, (data) =&gt; {\n                resolve(data);\n            });\n            res.on(&quot;error&quot;, (ex) =&gt; {\n                reject(ex);\n            })\n        });\n    });\n}\n\nlet asyncRequest = async(() =&gt; {\n    let resp, resp2;\n    await (requestUrl(&quot;/async-await&quot;).then((res) =&gt; {\n        console.log(res.toString());\n        resp = res.toString();\n    }).catch((ex) =&gt; {\n        resp = &quot;发生错误!&quot;;\n    }));\n\n    await (requestUrl(&quot;/async-await2&quot;).then((res) =&gt; {\n        resp2 = res.toString();\n    }).catch((ex) =&gt; {\n        resp = &quot;发生错误!&quot;;\n    }));\n    console.log(resp);\n    console.log(resp2);\n});\n\nasyncRequest();\n\n//  控制台输出\nrequest end\nrequest end2\n</code></pre><p>由此我们可以将async/await用在很多地方,比如例子中的文件读取、异步请求、nodejs中的查询数据库等等。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"civ7fsee40004t95fepka52b5","category_id":"civ7fsedz0002t95fu2i945ao","_id":"civ7fseeb0008t95fm3oael7a"},{"post_id":"civ7fseds0000t95fh0xw92a6","category_id":"civ7fsedz0002t95fu2i945ao","_id":"civ7fseef000bt95fr5fzx9k8"},{"post_id":"civ7fsee70005t95fhb73b0t7","category_id":"civ7fsedz0002t95fu2i945ao","_id":"civ7fseeg000dt95fn3jbeb8x"},{"post_id":"civ7fsee90007t95f5nprobu2","category_id":"civ7fsedz0002t95fu2i945ao","_id":"civ7fseei000ft95frg5nh8zo"},{"post_id":"civ7fsedx0001t95fb2a3monz","category_id":"civ7fsedz0002t95fu2i945ao","_id":"civ7fseej000ht95ft5dxvejy"},{"post_id":"civ7fseeb0009t95f2h2381ab","category_id":"civ7fsedz0002t95fu2i945ao","_id":"civ7fseel000jt95fh9kqr2j2"},{"post_id":"civ7fseef000ct95fxbhf80y0","category_id":"civ7fsedz0002t95fu2i945ao","_id":"civ7fseen000lt95fkbq0epfg"},{"post_id":"civ7fsee20003t95fxkj5j186","category_id":"civ7fsedz0002t95fu2i945ao","_id":"civ7fseeq000nt95fr1ffql62"},{"post_id":"civ7fseeg000et95fbvvtd990","category_id":"civ7fsedz0002t95fu2i945ao","_id":"civ7fseet000pt95fwiv9hyt2"},{"post_id":"civ7fseei000gt95fqforx0s2","category_id":"civ7fsedz0002t95fu2i945ao","_id":"civ7fseew000rt95fsph56545"},{"post_id":"civ7fseek000it95fo6i1w4ae","category_id":"civ7fsedz0002t95fu2i945ao","_id":"civ7fsef1000tt95fw6vwapok"},{"post_id":"civ7fseem000kt95fg2rsxyss","category_id":"civ7fsedz0002t95fu2i945ao","_id":"civ7fsef4000wt95fj3xy6dmz"},{"post_id":"civ7fseeo000mt95f23426zvn","category_id":"civ7fsedz0002t95fu2i945ao","_id":"civ7fsef6000yt95fq19zifvd"},{"post_id":"civ7fseeq000ot95f2enhdc8q","category_id":"civ7fsedz0002t95fu2i945ao","_id":"civ7fsef80010t95fm22irrdi"},{"post_id":"civ7fseeu000qt95fa01hlx0o","category_id":"civ7fsedz0002t95fu2i945ao","_id":"civ7fsef90013t95fmau2i6go"},{"post_id":"civ7fseew000st95f1fzy7rwz","category_id":"civ7fsef4000vt95fiy6yixzc","_id":"civ7fsefb0015t95fisaag44o"},{"post_id":"civ7fsef3000ut95far88il9c","category_id":"civ7fsef4000vt95fiy6yixzc","_id":"civ7fsefd0019t95f8oeadpay"},{"post_id":"civ7fsefd0018t95fbmp3ktpx","category_id":"civ7fsefc0017t95f6bngbmde","_id":"civ7fsefh001dt95fa6fu6u7b"},{"post_id":"civ7fsef5000xt95fdivc681e","category_id":"civ7fsefc0017t95f6bngbmde","_id":"civ7fsefk001gt95fc8dlhhec"},{"post_id":"civ7fsefe001at95fsqz7yqa3","category_id":"civ7fsefc0017t95f6bngbmde","_id":"civ7fseft001it95fiyi1tfie"},{"post_id":"civ7fsefg001ct95fupm2pdjw","category_id":"civ7fsedz0002t95fu2i945ao","_id":"civ7fsefu001lt95fi28dydeu"},{"post_id":"civ7fsef7000zt95f1yhc8uls","category_id":"civ7fsefc0017t95f6bngbmde","_id":"civ7fsefv001nt95frraoqer1"},{"post_id":"civ7fsefi001et95fzh4a14pu","category_id":"civ7fsedz0002t95fu2i945ao","_id":"civ7fsefw001qt95fwgrj5it2"},{"post_id":"civ7fsefl001ht95f3tdsh34o","category_id":"civ7fsedz0002t95fu2i945ao","_id":"civ7fsefx001st95fmp4amgjn"},{"post_id":"civ7fsef80011t95fe231tn1q","category_id":"civ7fsefc0017t95f6bngbmde","_id":"civ7fseg1001vt95f90gicee0"},{"post_id":"civ7fsefu001mt95f4bbtir1b","category_id":"civ7fsedz0002t95fu2i945ao","_id":"civ7fseg2001xt95fe1o2b9sv"},{"post_id":"civ7fsef90014t95fv1vu4vnf","category_id":"civ7fsefc0017t95f6bngbmde","_id":"civ7fseg30020t95f189oagi6"},{"post_id":"civ7fsefx001rt95fj8o2dieg","category_id":"civ7fsedz0002t95fu2i945ao","_id":"civ7fseg40021t95f5fu4u4qy"},{"post_id":"civ7fsefb0016t95fogjxoimi","category_id":"civ7fsefc0017t95f6bngbmde","_id":"civ7fseg50023t95fkwsdm059"},{"post_id":"civ7fsefx001tt95fj2ul7s13","category_id":"civ7fsedz0002t95fu2i945ao","_id":"civ7fseg50024t95fuiqx5sji"},{"post_id":"civ7fseg1001wt95fdzpr3210","category_id":"civ7fsedz0002t95fu2i945ao","_id":"civ7fseg60025t95fpumd4t7o"},{"post_id":"civ7fseft001jt95ffb41ghaq","category_id":"civ7fseg1001ut95fje04c3b6","_id":"civ7fseg60026t95fznr7udxu"},{"post_id":"civ7fsefv001ot95fwnd44f2z","category_id":"civ7fseg1001ut95fje04c3b6","_id":"civ7fseg60027t95fwpk9a0wx"},{"post_id":"civ7fseg2001yt95fs48maore","category_id":"civ7fsedz0002t95fu2i945ao","_id":"civ7fseg70028t95fx3rxdm4j"},{"post_id":"civ7fseg2001yt95fs48maore","category_id":"civ7gks3p002at95fk4hy4mj6","_id":"civ7gks3q002ct95fhscnclkh"},{"post_id":"civ7fseg2001yt95fs48maore","category_id":"civ7gks3q002bt95f3wnyuk41","_id":"civ7gks3r002dt95fbfcrvp4g"},{"post_id":"civb0mxh300005m5f43pcrv3h","category_id":"civ7fsedz0002t95fu2i945ao","_id":"civb0mxiu00035m5frqoizhfl"},{"post_id":"civb0mxh300005m5f43pcrv3h","category_id":"civb0mxha00015m5f12g95r7r","_id":"civb0mxiu00045m5f8xjb3d0i"},{"post_id":"civb0mxh300005m5f43pcrv3h","category_id":"civb0mxit00025m5f9s7oiemt","_id":"civb0mxiu00055m5fmbvoyw7r"},{"post_id":"civ7fseds0000t95fh0xw92a6","category_id":"civb0mxjv00065m5fzt1m9dyd","_id":"civb0mxk800085m5fm69mcm1u"},{"post_id":"civ7fsee40004t95fepka52b5","category_id":"civb0mxk200075m5f7augdekd","_id":"civb0mxka000a5m5fboco0fb7"},{"post_id":"civ7fsee70005t95fhb73b0t7","category_id":"civb0mxk800095m5fb5cg6a2n","_id":"civb0mxke000c5m5fg42r66jt"},{"post_id":"civ7fsedx0001t95fb2a3monz","category_id":"civb0mxkb000b5m5fkonycz4h","_id":"civb0mxki000e5m5fjv0u8ouv"},{"post_id":"civ7fsee20003t95fxkj5j186","category_id":"civb0mxkf000d5m5f0eeei09p","_id":"civb0mxkn000g5m5fgcqcq049"},{"post_id":"civ7fseeg000et95fbvvtd990","category_id":"civb0mxkj000f5m5fzsxmmg4b","_id":"civb0mxkr000i5m5fzciqrar6"},{"post_id":"civ7fseef000ct95fxbhf80y0","category_id":"civb0mxkj000f5m5fzsxmmg4b","_id":"civb0mxkt000k5m5fgnspuu4l"},{"post_id":"civ7fseeb0009t95f2h2381ab","category_id":"civb0mxkn000h5m5flaeqwj6q","_id":"civb0mxkw000l5m5fivsnktse"},{"post_id":"civ7fseek000it95fo6i1w4ae","category_id":"civb0mxkj000f5m5fzsxmmg4b","_id":"civb0mxl0000n5m5fovfb3vcb"},{"post_id":"civ7fseeo000mt95f23426zvn","category_id":"civb0mxkj000f5m5fzsxmmg4b","_id":"civb0mxl3000p5m5fqnubdz2j"},{"post_id":"civ7fseem000kt95fg2rsxyss","category_id":"civb0mxkj000f5m5fzsxmmg4b","_id":"civb0mxl6000r5m5ffgjef11y"},{"post_id":"civ7fsee90007t95f5nprobu2","category_id":"civb0mxl3000q5m5f6rlcqp5m","_id":"civb0mxla000t5m5f7rbwaax0"},{"post_id":"civ7fseei000gt95fqforx0s2","category_id":"civb0mxkj000f5m5fzsxmmg4b","_id":"civb0mxlc000v5m5fnis1icfe"},{"post_id":"civ7fseeu000qt95fa01hlx0o","category_id":"civb0mxlb000u5m5fqjae3ews","_id":"civb0mxle000x5m5fe47h5gql"},{"post_id":"civ7fsefi001et95fzh4a14pu","category_id":"civb0mxl3000q5m5f6rlcqp5m","_id":"civb0mxlf000z5m5fdykfnko9"},{"post_id":"civ7fseeq000ot95f2enhdc8q","category_id":"civb0mxle000y5m5fzjgofre4","_id":"civb0mxlg00115m5fodkp7z5i"},{"post_id":"civ7fsefg001ct95fupm2pdjw","category_id":"civb0mxlf00105m5f7i7ic20c","_id":"civb0mxlh00135m5fch2tkoph"},{"post_id":"civ7fsefl001ht95f3tdsh34o","category_id":"civb0mxl3000q5m5f6rlcqp5m","_id":"civb0mxli00155m5faocqen6l"},{"post_id":"civ7fsefv001ot95fwnd44f2z","category_id":"civb0mxlh00145m5f8spzkp0l","_id":"civb0mxlj00175m5f7uuerpnq"},{"post_id":"civ7fseft001jt95ffb41ghaq","category_id":"civb0mxli00165m5fqp4tht0d","_id":"civb0mxlk00195m5fbqkufw1q"},{"post_id":"civ7fsefx001rt95fj8o2dieg","category_id":"civb0mxlj00185m5f0ohwy16t","_id":"civb0mxln001b5m5florg1tr3"},{"post_id":"civ7fsefx001tt95fj2ul7s13","category_id":"civb0mxlk001a5m5fwrokdy4x","_id":"civb0mxlq001d5m5feq4ly34c"},{"post_id":"civ7fseg1001wt95fdzpr3210","category_id":"civb0mxln001c5m5fvp0hv9ie","_id":"civb0mxlq001e5m5f7xhmkkri"}],"PostTag":[],"Tag":[]}}