<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小宋</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-11-09T08:54:04.187Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>rwson</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue中computed计算属性和watch观察者原理</title>
    <link href="http://yoursite.com/2017/11/09/2017-11-09-vue-computed/"/>
    <id>http://yoursite.com/2017/11/09/2017-11-09-vue-computed/</id>
    <published>2017-11-08T16:00:00.000Z</published>
    <updated>2017-11-09T08:54:04.187Z</updated>
    
    <content type="html"><![CDATA[<p>在用<code>Vue</code>做开发中, 我们多多少少都会用到里面两个比较重要的东西: <code>computed</code>和<code>watch</code>, 接下来我们一起分析并简单实现下这两个属性。</p><h4 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h4><p><code>computed</code>名为计算属性, 目的就是让我们在模板里面只关注简单的绑定, 不做复杂操作, 拿官网的代码做例子,下面就是一个相对复杂的操作:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></div><div class="line">  &#123;&#123; message.split('').reverse().join('') &#125;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>先来看下用法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">    data() &#123;</div><div class="line">      <span class="keyword">return</span> &#123;</div><div class="line">        firstName: <span class="string">"rw"</span>,</div><div class="line">        lastName: <span class="string">"son"</span>,</div><div class="line">        age: <span class="number">25</span></div><div class="line">      &#125;;</div><div class="line">    &#125;,</div><div class="line">    computed: &#123;</div><div class="line">      <span class="comment">//  指定计算属性的getter</span></div><div class="line">      info() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">`info content: my name is <span class="subst">$&#123;<span class="keyword">this</span>.firstName&#125;</span><span class="subst">$&#123;<span class="keyword">this</span>.lastName&#125;</span>, I'm <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span> years old`</span>;</div><div class="line">      &#125;,</div><div class="line">      <span class="comment">//  同时提供getter和setter, setter中可以操作其他数据</span></div><div class="line">      fullName: &#123;</div><div class="line">        get() &#123;</div><div class="line">          <span class="keyword">return</span> <span class="string">`my fullName is: <span class="subst">$&#123;<span class="keyword">this</span>.firstName&#125;</span><span class="subst">$&#123;<span class="keyword">this</span>.lastName&#125;</span>`</span>;</div><div class="line">        &#125;,</div><div class="line">        set(value) &#123;</div><div class="line">          value = value.split(<span class="string">" "</span>);</div><div class="line">          <span class="keyword">this</span>.firstName = value[<span class="number">0</span>];</div><div class="line">          <span class="keyword">this</span>.lastName = value[value.length - <span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">      &#125;,</div><div class="line">  text: <span class="string">"just a test case"</span></div><div class="line">    &#125;,</div><div class="line">    created() &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.info);</div><div class="line">      <span class="comment">//  info content: my name is rwson, I'm 25 years old</span></div><div class="line"></div><div class="line">      <span class="keyword">this</span>.fullName = <span class="string">"son rw"</span>;</div><div class="line"></div><div class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.info);</div><div class="line">      <span class="comment">//  info content: my name is sonrw, I'm 25 years old</span></div><div class="line"></div><div class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.fullName);</div><div class="line">      <span class="comment">//  my fullName is: sonrw</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p><code>computed</code>的用法就是上面例子中的两种, 下面我们一起来模拟实现下:</p><p>首先我们模拟封装一个<code>Vm</code>函数作为构造器, 然后去调用它,</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vm(&#123;</div><div class="line">data() &#123;</div><div class="line"><span class="keyword">return</span> &#123;</div><div class="line">firstName: <span class="string">"rw"</span>,</div><div class="line">lastName: <span class="string">"son"</span>,</div><div class="line">age: <span class="number">25</span></div><div class="line">&#125;;</div><div class="line">&#125;,</div><div class="line">computed: &#123;</div><div class="line">info() &#123;</div><div class="line"><span class="keyword">return</span> <span class="string">`info content: my name is <span class="subst">$&#123;<span class="keyword">this</span>.firstName&#125;</span><span class="subst">$&#123;<span class="keyword">this</span>.lastName&#125;</span>, I'm <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span> years old`</span>;</div><div class="line">&#125;,</div><div class="line">fullName: &#123;</div><div class="line">get() &#123;</div><div class="line"><span class="keyword">return</span> <span class="string">`my fullName is: <span class="subst">$&#123;<span class="keyword">this</span>.firstName&#125;</span><span class="subst">$&#123;<span class="keyword">this</span>.lastName&#125;</span>`</span>;</div><div class="line">&#125;,</div><div class="line">set(value) &#123;</div><div class="line">value = value.split(<span class="string">" "</span>);</div><div class="line"><span class="keyword">this</span>.firstName = value[<span class="number">0</span>];</div><div class="line"><span class="keyword">this</span>.lastName = value[value.length - <span class="number">1</span>];</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line">text: <span class="string">"just a test case"</span></div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(vm.text);</div><div class="line"><span class="comment">//just a test case</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(vm.info);</div><div class="line"><span class="comment">//info content: my name is rwson, I'm 25 years old</span></div><div class="line"></div><div class="line">vm.fullName = <span class="string">"song rw"</span>;</div><div class="line"><span class="built_in">console</span>.log(vm.info);</div><div class="line"><span class="comment">//info content: my name is songrw, I'm 25 years old</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(vm.firstName);</div><div class="line"><span class="comment">//song</span></div></pre></td></tr></table></figure><p>上面是运行结果和调用, 下面我们一起实现下<code>Vm</code>这个函数:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//vm构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vm</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line"><span class="keyword">const</span> data = obj.data();</div><div class="line"></div><div class="line"><span class="comment">//处理data执行的返回结果</span></div><div class="line">handleData(<span class="keyword">this</span>, data);</div><div class="line"></div><div class="line"><span class="comment">//处理compoted对象</span></div><div class="line">handleComputed(<span class="keyword">this</span>, obj.computed);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//hasOwnProperty简写</span></div><div class="line"><span class="keyword">const</span> hasOwnProp = <span class="function">(<span class="params">obj, prop</span>) =&gt;</span> obj.hasOwnProperty(prop);</div><div class="line"></div><div class="line"><span class="comment">//获取prototype类名</span></div><div class="line"><span class="keyword">const</span> typeOf = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</div><div class="line"><span class="keyword">return</span> &#123;&#125;.toString.call(obj).slice(<span class="number">8</span>, <span class="number">-1</span>).toLowerCase();</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//枚举对象</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">loopObj</span>(<span class="params">obj, callback</span>) </span>&#123;</div><div class="line"> <span class="built_in">Object</span>.keys(obj).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</div><div class="line">callback(key, obj[key], obj);</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//给data用Object.defineProperty绑定</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleData</span>(<span class="params">context, data</span>) </span>&#123;</div><div class="line">loopObj(data, (key, val, data) =&gt; &#123;</div><div class="line">defineProp(context, key, val);</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//处理computed属性</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleComputed</span>(<span class="params">context, obj</span>) </span>&#123;</div><div class="line"><span class="keyword">let</span> type;</div><div class="line">loopObj(obj, (key, val, obj) =&gt; &#123;</div><div class="line">defineProp(context, key, val);</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineProp</span>(<span class="params">obj, key, val</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> _val = val, type;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</div><div class="line">        enumerable: <span class="literal">true</span>,</div><div class="line">        configable: <span class="literal">true</span>,</div><div class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            type = typeOf(_val);</div><div class="line">            <span class="keyword">switch</span> (type) &#123;</div><div class="line">            <span class="comment">/**</span></div><div class="line"><span class="comment">             * 属性值对应一个函数, 也就是computed里面只声明了getter</span></div><div class="line"><span class="comment">             * eg.</span></div><div class="line"><span class="comment">             * ...</span></div><div class="line"><span class="comment">             * computed: &#123;</span></div><div class="line"><span class="comment">             * info() &#123;</span></div><div class="line"><span class="comment">             * return `info content: my name is $&#123;this.firstName&#125;$&#123;this.lastName&#125;, I'm $&#123;this.age&#125; years old`;</span></div><div class="line"><span class="comment">             * &#125;</span></div><div class="line"><span class="comment">             * ...</span></div><div class="line"><span class="comment">             * &#125;</span></div><div class="line"><span class="comment">             * ...</span></div><div class="line"><span class="comment">             */</span></div><div class="line">            <span class="keyword">case</span> <span class="string">"function"</span>:</div><div class="line">            <span class="keyword">return</span> _val.call(obj);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="comment">/**</span></div><div class="line"><span class="comment">             * 属性值对应一个对象, 也就是computed里面同时声明了getter/setter</span></div><div class="line"><span class="comment">             * eg.</span></div><div class="line"><span class="comment">             * ...</span></div><div class="line"><span class="comment">             * computed: &#123;</span></div><div class="line"><span class="comment">             * fullName: &#123;</span></div><div class="line"><span class="comment">             * get() &#123;</span></div><div class="line"><span class="comment">             * return `my fullName is: $&#123;this.firstName&#125;$&#123;this.lastName&#125;`;</span></div><div class="line"><span class="comment">             * &#125;,</span></div><div class="line"><span class="comment">             * set() &#123;</span></div><div class="line"><span class="comment">             * value = value.split(" ");</span></div><div class="line"><span class="comment">             * this.firstName = value[0];</span></div><div class="line"><span class="comment">             * this.lastName = value[value.length - 1];</span></div><div class="line"><span class="comment">             * &#125;</span></div><div class="line"><span class="comment">             * &#125;</span></div><div class="line"><span class="comment">             * &#125;</span></div><div class="line"><span class="comment">             * ...</span></div><div class="line"><span class="comment">             */</span></div><div class="line">            <span class="keyword">case</span> <span class="string">"object"</span>:</div><div class="line">            <span class="keyword">return</span> _val.get.call(obj);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="comment">//其他类型默认</span></div><div class="line">            <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">return</span> _val;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        set: <span class="function"><span class="keyword">function</span>(<span class="params">newV</span>) </span>&#123;</div><div class="line">        type = typeOf(_val);</div><div class="line">        <span class="keyword">switch</span> (type) &#123;</div><div class="line">        <span class="comment">//属性值对应一个对象, 也就是computed里面同时声明了getter/setter</span></div><div class="line">        <span class="keyword">case</span> <span class="string">"object"</span>:</div><div class="line">        _val.set.call(obj, newV);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="comment">//其他类型的默认</span></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">if</span> (newV !== _val) &#123;</div><div class="line">        _val = newV;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面就是我们一个实现了, 其中<code>defineProp</code>这个函数中, 我们做了下面几步:</p><ol><li>缓存当前属性值</li><li>调用Object.defineProperty方法在obj上定义属性key</li><li>在<code>descriptor</code>中的<code>getter</code>/<code>setter</code>里面判断属性值类型(如果是函数或者对象, 那该属性就是在<code>computed</code>[先不谈<code>watch</code>]里面声明的, <code>getter</code>里面返回该函数的执行结果、<code>setter</code>里面执行<code>computed</code>中指定的<code>set</code>函数[如果有的话], 否则作为普通的<code>data</code>处理)</li></ol><h4 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h4><p><code>watch</code>名为观察者, 通过监听组件内某个属性来执行某些操作, 最常用的就是组件中某个属性值发生变化之后, 向后端发送一个异步请求, 比如一些商品网站上有顶部tab栏, 每个tab都是一个类目, 这时候我们可以给这些tab绑定<code>click</code>事件, 然后在事件处理中处理顶部tab栏绑定的属性值, watch中去监听它的变化来发送异步请求等等, 比如下面的例子:</p><p>先来看模板部分:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">li</span> @<span class="attr">click</span>=<span class="string">"setFilter('1')"</span>&gt;</span>男装<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">li</span> @<span class="attr">click</span>=<span class="string">"setFilter('2')"</span>&gt;</span>女装<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">li</span> @<span class="attr">click</span>=<span class="string">"setFilter('3')"</span>&gt;</span>童装<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">li</span> @<span class="attr">click</span>=<span class="string">"setFilter('4')"</span>&gt;</span>美食<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">...</div></pre></td></tr></table></figure><p>然后我们看看js部分实现:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span>() &#123;</div><div class="line">data() &#123;</div><div class="line"><span class="keyword">return</span> &#123;</div><div class="line">page: <span class="number">1</span>,</div><div class="line">filter: <span class="string">"1"</span>,</div><div class="line">goodsList: []</div><div class="line">&#125;;</div><div class="line">&#125;,</div><div class="line">watch: &#123;</div><div class="line"><span class="keyword">async</span> filter() &#123;</div><div class="line"><span class="keyword">const</span> &#123; filter, page &#125; = <span class="keyword">this</span>,</div><div class="line">res = <span class="keyword">await</span> <span class="keyword">this</span>.queryGoods(filter, page);</div><div class="line"><span class="keyword">if</span> (res.success) &#123;</div><div class="line"><span class="keyword">this</span>.goodsList = res.goods;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line">methods: &#123;</div><div class="line">setFilter(filter) &#123;</div><div class="line"><span class="keyword">this</span>.filter = filter;</div><div class="line"><span class="keyword">this</span>.page = <span class="number">1</span>;</div><div class="line"><span class="keyword">this</span>.goodsList = [];</div><div class="line">&#125;,</div><div class="line"><span class="keyword">async</span> queryGoods(filter, page) &#123;</div><div class="line"><span class="comment">//...</span></div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line"><span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当然这个例子可能有点极端, 因为<code>queryGoods</code>完全可以放在<code>setFilter</code>里面去调用, 但是为了演示效果, 只能这么做了😂</p><p>下面一起看看看看<code>watch</code>部分的实现, 有了刚才的分析, 我们知道<code>watch</code>中声明的肯定是在<code>setter</code>部分进行调用的, 所以我们需要在处理<code>data</code>的时候就把<code>watch</code>对应的加上:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//首先我们需要在构造函数里面, 改下handleData这个函数的调用, 给它把obj.watch也传进去</span></div><div class="line"><span class="comment">// handleData(this, data);</span></div><div class="line">handleData(<span class="keyword">this</span>, data, obj.watch);</div><div class="line"></div><div class="line"><span class="comment">//接下来我们改写handleData这个函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleData</span>(<span class="params">context, data, watch</span>) </span>&#123;</div><div class="line"><span class="keyword">let</span> inWatch, watchVal;</div><div class="line">loopObj(data, (key, val, data) =&gt; &#123;</div><div class="line"><span class="comment">//判断在watch中是否也声明了该属性值</span></div><div class="line">inWatch = hasOwnProp(watch, key);</div><div class="line"><span class="comment">//如果有取出来, 作为defineProp的第五个参数给传进去</span></div><div class="line">watchVal = inWatch ? watch[key] : <span class="literal">null</span>;</div><div class="line">defineProp(context, key, val, inWatch, watchVal);</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//下面就是我们说到的在setter部分调用声明的watch观察者</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineProp</span>(<span class="params">obj, key, val, inWatch = false, watchVal = (</span>) =&gt; </span>&#123;&#125;) &#123;</div><div class="line">    <span class="keyword">let</span> _val = val, type;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</div><div class="line">        enumerable: <span class="literal">true</span>,</div><div class="line">        configable: <span class="literal">true</span>,</div><div class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            type = typeOf(_val);</div><div class="line">            <span class="keyword">switch</span> (type) &#123;</div><div class="line">            <span class="comment">/**</span></div><div class="line"><span class="comment">             * 属性值对应一个函数, 也就是computed里面只声明了getter</span></div><div class="line"><span class="comment">             * eg.</span></div><div class="line"><span class="comment">             * ...</span></div><div class="line"><span class="comment">             * computed: &#123;</span></div><div class="line"><span class="comment">             * info() &#123;</span></div><div class="line"><span class="comment">             * return `info content: my name is $&#123;this.firstName&#125;$&#123;this.lastName&#125;, I'm $&#123;this.age&#125; years old`;</span></div><div class="line"><span class="comment">             * &#125;</span></div><div class="line"><span class="comment">             * ...</span></div><div class="line"><span class="comment">             * &#125;</span></div><div class="line"><span class="comment">             * ...</span></div><div class="line"><span class="comment">             */</span></div><div class="line">            <span class="keyword">case</span> <span class="string">"function"</span>:</div><div class="line">            <span class="keyword">return</span> _val.call(obj);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="comment">/**</span></div><div class="line"><span class="comment">             * 属性值对应一个对象, 也就是computed里面同时声明了getter/setter</span></div><div class="line"><span class="comment">             * eg.</span></div><div class="line"><span class="comment">             * ...</span></div><div class="line"><span class="comment">             * computed: &#123;</span></div><div class="line"><span class="comment">             * fullName: &#123;</span></div><div class="line"><span class="comment">             * get() &#123;</span></div><div class="line"><span class="comment">             * return `my fullName is: $&#123;this.firstName&#125;$&#123;this.lastName&#125;`;</span></div><div class="line"><span class="comment">             * &#125;,</span></div><div class="line"><span class="comment">             * set() &#123;</span></div><div class="line"><span class="comment">             * value = value.split(" ");</span></div><div class="line"><span class="comment">             * this.firstName = value[0];</span></div><div class="line"><span class="comment">             * this.lastName = value[value.length - 1];</span></div><div class="line"><span class="comment">             * &#125;</span></div><div class="line"><span class="comment">             * &#125;</span></div><div class="line"><span class="comment">             * &#125;</span></div><div class="line"><span class="comment">             * ...</span></div><div class="line"><span class="comment">             */</span></div><div class="line">            <span class="keyword">case</span> <span class="string">"object"</span>:</div><div class="line">            <span class="keyword">return</span> _val.get.call(obj);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="comment">//其他类型默认</span></div><div class="line">            <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">return</span> _val;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        set: <span class="function"><span class="keyword">function</span>(<span class="params">newV</span>) </span>&#123;</div><div class="line">        type = typeOf(_val);</div><div class="line">        <span class="keyword">switch</span> (type) &#123;</div><div class="line">        <span class="comment">//属性值对应一个对象, 也就是computed里面同时声明了getter/setter</span></div><div class="line">        <span class="keyword">case</span> <span class="string">"object"</span>:</div><div class="line">        _val.set.call(obj, newV);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="comment">//其他类型的默认</span></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">if</span> (newV !== _val) &#123;</div><div class="line">        _val = newV;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"><span class="comment">//如果watch观察者存在, 并且对应一个回调函数, 在值发生改变的时候调用该回调, 并修改this指向到当前vm实例</span></div><div class="line">            <span class="keyword">if</span> (inWatch &amp;&amp; typeOf(watchVal) === <span class="string">"function"</span>) &#123;</div><div class="line">            watchVal.call(obj);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>再来看下用法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vm(&#123;</div><div class="line">data() &#123;</div><div class="line"><span class="keyword">return</span> &#123;</div><div class="line">firstName: <span class="string">"rw"</span>,</div><div class="line">lastName: <span class="string">"son"</span>,</div><div class="line">age: <span class="number">25</span></div><div class="line">&#125;;</div><div class="line">&#125;,</div><div class="line">computed: &#123;</div><div class="line">info() &#123;</div><div class="line"><span class="keyword">return</span> <span class="string">`info content: my name is <span class="subst">$&#123;<span class="keyword">this</span>.firstName&#125;</span><span class="subst">$&#123;<span class="keyword">this</span>.lastName&#125;</span>, I'm <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span> years old`</span>;</div><div class="line">&#125;,</div><div class="line">fullName: &#123;</div><div class="line">get() &#123;</div><div class="line"><span class="keyword">return</span> <span class="string">`my fullName is: <span class="subst">$&#123;<span class="keyword">this</span>.firstName&#125;</span><span class="subst">$&#123;<span class="keyword">this</span>.lastName&#125;</span>`</span>;</div><div class="line">&#125;,</div><div class="line">set(value) &#123;</div><div class="line">value = value.split(<span class="string">" "</span>);</div><div class="line"><span class="keyword">this</span>.firstName = value[<span class="number">0</span>];</div><div class="line"><span class="keyword">this</span>.lastName = value[value.length - <span class="number">1</span>];</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line">text: <span class="string">"just a test case"</span></div><div class="line">&#125;,</div><div class="line">watch: &#123;</div><div class="line">firstName() &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">`%c now firstName's value is: <span class="subst">$&#123;<span class="keyword">this</span>.firstName&#125;</span>`</span>, <span class="string">"color: red"</span>);</div><div class="line"><span class="comment">//走到vm.fullName = "song rw";就会输出</span></div><div class="line">&#125;,</div><div class="line">lastName() &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">`%c now lastName's value is: <span class="subst">$&#123;<span class="keyword">this</span>.lastName&#125;</span>`</span>, <span class="string">"color: green"</span>);</div><div class="line"><span class="comment">//走到vm.fullName = "song rw";就会输出</span></div><div class="line">&#125;,</div><div class="line">age() &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">`%c now age's value is: <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span>`</span>, <span class="string">"color: yellow"</span>);</div><div class="line"><span class="comment">//走到vm.fullName = "song rw";就会输出</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(vm.text);</div><div class="line"><span class="built_in">console</span>.log(vm.info);</div><div class="line">vm.fullName = <span class="string">"song rw"</span>;</div><div class="line"><span class="built_in">console</span>.log(vm.info);</div><div class="line"><span class="built_in">console</span>.log(vm.firstName);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在用&lt;code&gt;Vue&lt;/code&gt;做开发中, 我们多多少少都会用到里面两个比较重要的东西: &lt;code&gt;computed&lt;/code&gt;和&lt;code&gt;watch&lt;/code&gt;, 接下来我们一起分析并简单实现下这两个属性。&lt;/p&gt;
&lt;h4 id=&quot;computed&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
      <category term="Vue" scheme="http://yoursite.com/categories/JavaScript/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>用NodeJs和Python开发一个Sublime插件</title>
    <link href="http://yoursite.com/2017/10/24/2017-10-24-write-a-sublime-plugin-by-python-nodejs/"/>
    <id>http://yoursite.com/2017/10/24/2017-10-24-write-a-sublime-plugin-by-python-nodejs/</id>
    <published>2017-10-23T16:00:00.000Z</published>
    <updated>2017-10-24T07:38:04.404Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.sublimetext.com/" target="_blank" rel="external">Sublime Text</a>著有最性感的编辑器之称,它轻量,易于拓展,通过插件的方式可使它变得很强大,而我更是把它作为自己的主要编辑器使用。</p><p>有一次逛<a href="https://packagecontrol.io" target="_blank" rel="external">package control</a>的时候,发现一个用<code>NodeJs</code>来写插件的脚手架: <a href="https://github.com/akira-cn/SublimeJS_Samples" target="_blank" rel="external">SublimeJS_Samples</a>,才发现用<code>NodeJs</code>结合<code>Python</code>也可以来开发插件,这对于对<code>Python</code>不是特别了解的人可能很吃力,然后就研究了几个常用插件的源码,拿<a href="https://github.com/luozhihua/sublime-vue-formatter" target="_blank" rel="external">sublime-vue-formatter</a>这个插件详细看了下,总结出原理大概是这样的:</p><ol><li>在<code>Python</code>中拿到当前正在编辑的文件或者选中的内容</li><li>用<code>Python</code>子进程<code>subprocess</code>去执行一段cmd命令并接受输出,<code>Node</code>路径为我们电脑上装的<code>Node</code>绝对路径(用户事先配置好), 再去执行一个<code>NodeJs</code>脚本, 以Mac为例, 最后要执行的命令大概是这样的<code>/usr/local/bin/node script/run.js --arg1=argVal1  --arg2=argVal2</code>(其实和我们平时在Terminal里运行的一样)</li><li><code>Python</code>接收到<code>NodeJs</code>的执行返回的时候, 替换文件中的相关内容</li></ol><p>抱着试试看的心理,我也决定自己用这个模式写个图片压缩相关的插件,先简单介绍下我想写的插件的功能:</p><ol><li>用户在项目根目录下新建配置文件, 指定压缩目录和释放目录, 调用<a href="http://tinypng.com" target="_blank" rel="external">tinypng</a>的开发者API进行压缩</li><li>当压缩完的图片小于多少字节时把css中的引用转换成<code>Base64</code>编码,也是通过配置项</li><li>用户可以通过一些快捷键或者命令(子命令)在项目根目录新建配置文件、修改全局<code>NodeJs</code>路径配置等等</li></ol><p>现在知道了我们想做什么, 下一步就是根据这个需求开始写代码, 因为是图片压缩插件, 所以我把它命名成<code>sublime-image-compressor</code></p><h4 id="命令、子命令"><a href="#命令、子命令" class="headerlink" title="命令、子命令"></a>命令、子命令</h4><p>在插件配置中, 命令都是通过配置文件写入的, 下面贴下我们这个插件支持命令的一个配置并做介绍</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//ImageCompressor.sublime-commands</div><div class="line"></div><div class="line">[&#123;</div><div class="line">  <span class="attr">"caption"</span>: <span class="string">"ImageCompress"</span>,</div><div class="line">  <span class="attr">"command"</span>: <span class="string">"image_compress"</span></div><div class="line">&#125;, &#123;</div><div class="line">  <span class="attr">"caption"</span>: <span class="string">"ImageCompress: Init Project Config File"</span>,</div><div class="line">  <span class="attr">"command"</span>: <span class="string">"imagecompress_config_project"</span></div><div class="line">&#125;, &#123;</div><div class="line">  <span class="attr">"caption"</span>: <span class="string">"ImageCompress: Set Global Config"</span>,</div><div class="line">  <span class="attr">"command"</span>: <span class="string">"imagecompress_set_global_plugin_options"</span></div><div class="line">&#125;]</div></pre></td></tr></table></figure><p><code>.sublime-commands</code>是用来指定插件支持的命令的, 里面指定一个对象型数组, 数组有<code>caption</code>和<code>command</code>两项, 需要注意的是, <code>command</code>的值和<code>Python</code>的类是对应的, 且<code>Python</code>中用驼峰命名法来定义类名, 以第一项为例, 比如<code>command</code>的值为<code>image_compress</code>, 我们的<code>Python</code>中就需要像类似下面的样子定义一个类:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageCompressCommand</span><span class="params">(sublime_plugin.TextCommand)</span>:</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, edit)</span>:</span></div></pre></td></tr></table></figure><p>其他类似</p><h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><p>在插件配置中, 快捷键都是通过配置文件写入的, 下面贴下我们这个插件快捷键的一个配置并做介绍, 需要注意的是, 如果需要兼容多平台, 因为每个平台的键可能都不太一样, 则需要多份配置文件, <code>Windows</code>/<code>Mac</code>/<code>Linux</code>的命名分别是<code>Default (Windows).sublime-keymap</code>/<code>Default (OSX).sublime-keymap</code>/<code>Default (Linux).sublime-keymap</code>, 下面我们把<code>Default (OSX).sublime-keymap</code>这个文件的内容贴出来看下:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[&#123;</div><div class="line">  <span class="attr">"keys"</span>: [<span class="string">"ctrl+shift+i"</span>, <span class="string">"c"</span>],</div><div class="line">  <span class="attr">"command"</span>: <span class="string">"image_compress"</span></div><div class="line">&#125;, &#123;</div><div class="line">  <span class="attr">"keys"</span>: [<span class="string">"ctrl+alt+i"</span>, <span class="string">"f"</span>],</div><div class="line">  <span class="attr">"command"</span>: <span class="string">"image_compress_config_project"</span></div><div class="line">&#125;, &#123;</div><div class="line">  <span class="attr">"keys"</span>: [<span class="string">"ctrl+alt+i"</span>, <span class="string">"g"</span>],</div><div class="line">  <span class="attr">"command"</span>: <span class="string">"image_compress_set_global_plugin_options"</span></div><div class="line">&#125;]</div></pre></td></tr></table></figure><p><code>.sublime-keymap</code>也是指定一个对象型数组, 每个对象有<code>keys</code>和<code>command</code>两个属性, <code>keys</code>是指定按哪几个键生效的, <code>command</code>的配置和之前的命令配置一样</p><p>当然我们也可以通过添加其他配置文件比如<code>Context.sublime-menu</code>或者<code>Main.sublime-menu</code>来指定插件的右键菜单或者在<code>Toolbar</code>上的菜单配置</p><p>说完了几个配置, 我们一起来写<code>Python</code>和<code>NodeJs</code>, 先写<code>Python</code>吧</p><p>在<code>Python</code>中我们需要完成大概下面几个任务:</p><ol><li>首先获取用户当前项目的根目录</li><li>获取根目录下的配置文件, 如果用户没有新建配置文件, 就读取一份默认的配置文件, 拼出命令行参数(–arg1=argVal1 –arg2=argVal2)</li><li>获取用户装的<code>NodeJs</code>全路径, 结合上一步拼好的命令行参数再拼出一个可执行命令(类似刚才分析流程那边那条)</li><li>用<code>subprocess</code>模块来运行该命令</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 写插件必须引入这两个模块</span></div><div class="line"><span class="keyword">import</span> sublime, sublime_plugin</div><div class="line"></div><div class="line"><span class="comment"># Python内置模块的引入</span></div><div class="line"><span class="keyword">import</span> os, sys, subprocess, codecs, webbrowser, platform, json</div><div class="line"></div><div class="line"><span class="comment"># 当前插件, 配置文件, 快捷键配置, 执行任务的js路径配置</span></div><div class="line">PLUGIN_FOLDER = os.path.dirname(os.path.realpath(__file__))</div><div class="line">CONFIG_FILE = <span class="string">"image-compressor.config.json"</span></div><div class="line">SETTINGS_FILE = <span class="string">"ImageCompressor.sublime-settings"</span></div><div class="line">KEYMAP_FILE = <span class="string">"Default ($PLATFORM).sublime-keymap"</span></div><div class="line"><span class="comment"># 这里JS_PATH必须为绝对路径, 否则会去$&#123;nodepath&#125;找/scripts/index.js,找不到肯定会报错</span></div><div class="line">JS_PATH = PLUGIN_FOLDER.replace(<span class="string">" "</span>, <span class="string">"\\ "</span>) + <span class="string">"/scripts/index.js"</span></div><div class="line"></div><div class="line">//引入commands模块, 并catch异常</div><div class="line"><span class="keyword">try</span>:</div><div class="line">  <span class="keyword">import</span> commands</div><div class="line"><span class="keyword">except</span> ImportError:</div><div class="line">  <span class="keyword">pass</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageCompressCommand</span><span class="params">(sublime_plugin.TextCommand)</span>:</span></div><div class="line">  </div><div class="line">  <span class="string">"""</span></div><div class="line"><span class="string">    插件需要一个run方法, 该方法接收self和edit两个参数</span></div><div class="line"><span class="string">    def run(self, run[, args])</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">    self: 代表当前类</span></div><div class="line"><span class="string">    view: 代表当前编辑的tab</span></div><div class="line"><span class="string">    args: 其他参数, 可以在配置中指定</span></div><div class="line"><span class="string">      比如 &#123; "caption": "xxx", "command": "xxxx", "args": &#123;"by": "abc"&#125; &#125;</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">      class Xxxx(sublime_plugin.TextCommand):</span></div><div class="line"><span class="string">        def run(self, edit, by):</span></div><div class="line"><span class="string">          print("by=" + by)</span></div><div class="line"><span class="string">          # by=file</span></div><div class="line"><span class="string">  """</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, edit)</span>:</span></div><div class="line">    <span class="comment"># 拿到项目根路径的绝对路径</span></div><div class="line">    currentDir = PluginUtils.get_active_project_path()</div><div class="line">    <span class="comment"># 从.sublime-settings配置文件中获取当前平台的node_path</span></div><div class="line">    nodepath = PluginUtils.get_node_path()</div><div class="line">    <span class="comment"># 获取根路径</span></div><div class="line">    configs = PluginUtils.load_config()</div><div class="line"></div><div class="line">    configs += <span class="string">" --currentDir='"</span> + currentDir + <span class="string">"'"</span></div><div class="line"></div><div class="line">    <span class="comment"># 空格替换</span></div><div class="line">    nodepath = nodepath.replace(<span class="string">" "</span>, <span class="string">"\\ "</span>);</div><div class="line"></div><div class="line">    <span class="comment"># 拼一个cmd数组</span></div><div class="line">    cmd = [nodepath, JS_PATH]</div><div class="line">    cmd.append(configs)</div><div class="line"></div><div class="line">    <span class="comment"># 执行命令</span></div><div class="line">    PluginUtils.exec_cmd(cmd)</div></pre></td></tr></table></figure><p>上面我们完成了一个<code>ImageCompressCommand</code>这个类的封装,并且在<code>run</code>里面好几个地方都调用了<code>PluginUtils</code>下的静态方法, 下面我们看看<code>PluginUtils</code>的定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#在python用staticmethod Decorator表示静态方法</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PluginUtils</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line"><span class="string">      读取配置文件</span></div><div class="line"><span class="string">      这里的逻辑有点不对, 应该先去项目根目录下找配置文件</span></div><div class="line"><span class="string">      找不到再找默认的配置</span></div><div class="line"><span class="string">    '''</span></div><div class="line"></div><div class="line"><span class="meta">    @staticmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_config</span><span class="params">(base)</span>:</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            args = <span class="string">""</span></div><div class="line">            <span class="comment"># 以读取的模式打开配置文件</span></div><div class="line">            fs = open(CONFIG_FILE, <span class="string">"r"</span>)</div><div class="line">            stream = fs.read()</div><div class="line">            <span class="comment"># steam读出来是个json字符串, 所以需要用json.loads转换成dict</span></div><div class="line">            <span class="comment"># http://python3-cookbook.readthedocs.io/zh_CN/latest/c06/p02_read-write_json_data.html</span></div><div class="line">            data = json.loads(stream)</div><div class="line">            <span class="comment"># 获取dict下的key变成一个list</span></div><div class="line">            keys = data.keys()</div><div class="line">            <span class="comment"># 关闭文件</span></div><div class="line">            fs.close()</div><div class="line"></div><div class="line">            <span class="comment"># 枚举所有key</span></div><div class="line">            <span class="keyword">for</span> key <span class="keyword">in</span> keys:</div><div class="line">                val = data[key]</div><div class="line">                <span class="comment"># 数组类型参数转换成字符串</span></div><div class="line">                <span class="keyword">if</span> isinstance(val, list):</div><div class="line">                    val = <span class="string">"-compress-config-split-"</span>.join(val)</div><div class="line">                args += <span class="string">" --"</span> + key + <span class="string">"="</span> + str(val)</div><div class="line">            <span class="keyword">return</span> args</div><div class="line">        <span class="keyword">except</span>:</div><div class="line">            <span class="keyword">return</span> <span class="string">""</span></div><div class="line"></div><div class="line">    <span class="comment">#从.sublime-settings里面获取相关配置项</span></div><div class="line"><span class="meta">    @staticmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_pref</span><span class="params">(key)</span>:</span></div><div class="line">        <span class="keyword">return</span> sublime.load_settings(SETTINGS_FILE).get(key)</div><div class="line"></div><div class="line">    <span class="string">'''</span></div><div class="line"><span class="string">        从.sublime-settings里面获取当前平台下nodejs的路径</span></div><div class="line"><span class="string">    '''</span></div><div class="line"><span class="meta">    @staticmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_node_path</span><span class="params">()</span>:</span></div><div class="line">        platform = sublime.platform()</div><div class="line">        node = PluginUtils.get_pref(<span class="string">"node_path"</span>).get(platform)</div><div class="line">        <span class="keyword">return</span> node</div><div class="line"></div><div class="line">    <span class="string">'''</span></div><div class="line"><span class="string">        获取当前激活项目的根路径</span></div><div class="line"><span class="string">        参考https://github.com/fyneworks/sublime-TortoiseGIT/blob/master/TortoiseGIT.py#L8实现</span></div><div class="line"><span class="string">    '''</span></div><div class="line"><span class="meta">    @staticmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_active_project_path</span><span class="params">()</span>:</span></div><div class="line">        window = sublime.active_window()</div><div class="line">        folders = window.folders()</div><div class="line">        <span class="keyword">if</span> len(folders) == <span class="number">1</span>:</div><div class="line">            <span class="keyword">return</span> folders[<span class="number">0</span>]</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            active_view = window.active_view()</div><div class="line">            active_file_name = active_view.file_name() <span class="keyword">if</span> active_view <span class="keyword">else</span> <span class="keyword">None</span></div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> active_file_name:</div><div class="line">                <span class="keyword">return</span> folders[<span class="number">0</span>] <span class="keyword">if</span> len(folders) <span class="keyword">else</span> os.path.expanduser(<span class="string">"~"</span>)</div><div class="line">            <span class="keyword">for</span> folder <span class="keyword">in</span> folders:</div><div class="line">                <span class="keyword">if</span> active_file_name.startswith(folder):</div><div class="line">                    <span class="keyword">return</span> folder</div><div class="line">            <span class="keyword">return</span> os.path.dirname(active_file_name)</div><div class="line"></div><div class="line">    <span class="string">'''</span></div><div class="line"><span class="string">        执行命令</span></div><div class="line"><span class="string">        参考https://github.com/luozhihua/sublime-vue-formatter/blob/master/vue-next-formatter.py#L196实现</span></div><div class="line"><span class="string">    '''</span></div><div class="line"><span class="meta">    @staticmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exec_cmd</span><span class="params">(cmd)</span>:</span></div><div class="line">        <span class="keyword">if</span> int(sublime.version()) &lt; <span class="number">3000</span>:</div><div class="line">            <span class="keyword">if</span> sublime.platform() != <span class="string">"windows"</span>:</div><div class="line">                run = <span class="string">'"'</span> + <span class="string">'" "'</span>.join(cmd) + <span class="string">'"'</span></div><div class="line">                <span class="keyword">return</span> commands.getoutput(run)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                startupinfo = subprocess.STARTUPINFO()</div><div class="line">                startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW</div><div class="line">                <span class="keyword">return</span> subprocess.Popen(cmd, \</div><div class="line">                                        stdout=subprocess.PIPE, \</div><div class="line">                                        startupinfo=startupinfo).communicate()[<span class="number">0</span>]</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            run = <span class="string">" "</span>.join(cmd)</div><div class="line">            res = subprocess.check_output(run, stderr=subprocess.STDOUT, shell=<span class="keyword">True</span>, env=os.environ)</div><div class="line">            print(res)</div></pre></td></tr></table></figure><p>上面我们就完成了对<code>PluginUtils</code>这个类的封装, 在最后一个方法中, 我们用了<code>subprocess</code>下面的几个方法, <code>subprocess</code>下面还有很多其他方法, 这些在<a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c13/p06_executing_external_command_and_get_its_output.html" target="_blank" rel="external">文档</a>里面都能找到, 下面再看看<code>NodeJs</code>部分实现:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> dir = <span class="built_in">require</span>(<span class="string">"node-dir"</span>),</div><div class="line">    co = <span class="built_in">require</span>(<span class="string">"co"</span>),</div><div class="line">    tinify = <span class="built_in">require</span>(<span class="string">"tinify"</span>),</div><div class="line">    mkdirp = <span class="built_in">require</span>(<span class="string">"mkdirp"</span>),</div><div class="line">    <span class="built_in">Promise</span> = <span class="built_in">require</span>(<span class="string">"bluebird"</span>),</div><div class="line">    fs = <span class="built_in">require</span>(<span class="string">"fs"</span>),</div><div class="line">    path = <span class="built_in">require</span>(<span class="string">"path"</span>);</div><div class="line"></div><div class="line"><span class="comment">//缓存Object.prototype</span></div><div class="line"><span class="keyword">const</span> obj2 = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">//参数解析</span></div><div class="line"><span class="keyword">const</span> parseArgs = <span class="function"><span class="params">arr</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> res = &#123;&#125;,</div><div class="line">        tmp = <span class="literal">null</span>;</div><div class="line">    arr.map(<span class="function"><span class="params">item</span> =&gt;</span> item.replace(<span class="regexp">/^-&#123;2&#125;/</span>, <span class="string">""</span>))</div><div class="line">        .forEach(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</div><div class="line">            tmp = val.split(<span class="string">"="</span>);</div><div class="line">            <span class="comment">//Python中布尔值转换成True/False, 数字转换成'123'</span></div><div class="line">            <span class="keyword">if</span> (<span class="regexp">/^[\d]+$/</span>.test(tmp[<span class="number">1</span>])) &#123;</div><div class="line">                tmp[<span class="number">1</span>] = <span class="built_in">Number</span>(tmp[<span class="number">1</span>]);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (<span class="regexp">/^True$/</span>.test(tmp[<span class="number">1</span>])) &#123;</div><div class="line">                tmp[<span class="number">1</span>] = <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (<span class="regexp">/^False/</span>.test(tmp[<span class="number">1</span>])) &#123;</div><div class="line">                tmp[<span class="number">1</span>] = <span class="literal">false</span>;</div><div class="line">            &#125;</div><div class="line">            res[tmp[<span class="number">0</span>]] = tmp[<span class="number">1</span>];</div><div class="line">        &#125;);</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//判断是否为一个图片文件</span></div><div class="line"><span class="keyword">const</span> isImageFile = <span class="function"><span class="params">file</span> =&gt;</span> /\.(jpe?g|png|gif)$/i.test(file);</div><div class="line"></div><div class="line"><span class="comment">//判断是否为一个css文件</span></div><div class="line"><span class="keyword">const</span> isCssFile = <span class="function"><span class="params">file</span> =&gt;</span> /\.css$/i.test(file);</div><div class="line"></div><div class="line"><span class="comment">//目标目录</span></div><div class="line"><span class="keyword">const</span> distDir = <span class="function">(<span class="params">prefix, folder</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (!folder) &#123;</div><div class="line">        folder = prefix;</div><div class="line">        prefix = __dirname;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//拼路径</span></div><div class="line">    <span class="keyword">return</span> path.join(prefix, folder);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//同步读取一个文件的状态</span></div><div class="line"><span class="keyword">const</span> fstat = <span class="function"><span class="params">filePath</span> =&gt;</span> fs.fstatSync(filePath);</div><div class="line"></div><div class="line"><span class="comment">//把文件转换成base64编码</span></div><div class="line"><span class="keyword">const</span> toBase64 = <span class="function"><span class="params">filePath</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">const</span> buffer = fs.readFileSync(filePath);</div><div class="line">    <span class="keyword">return</span> buffer.toString(<span class="string">"base64"</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//把一个数组按照20个每项做子项目拆分成二级数组</span></div><div class="line"><span class="keyword">const</span> splitArray = <span class="function"><span class="params">array</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">const</span> length = array.length;</div><div class="line">    <span class="keyword">let</span> res = [];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i += <span class="number">20</span>) &#123;</div><div class="line">        res.push(array.slice(i, i + <span class="number">20</span>));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//判断目录是否存在</span></div><div class="line"><span class="keyword">const</span> folderExist = <span class="function"><span class="params">folder</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        fs.readdirSync(folder);</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//读取目录下的css并且转换成AST对象</span></div><div class="line"><span class="keyword">const</span> listCssAST = <span class="function"><span class="params">cssdir</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> list = [],</div><div class="line">        fullPath = <span class="literal">null</span>,</div><div class="line">        basename = <span class="literal">null</span>,</div><div class="line">        stream = <span class="literal">null</span>;</div><div class="line">    files = fs.readFileSync(cssdir);</div><div class="line">    list = files.filter(<span class="function"><span class="params">file</span> =&gt;</span> isCssFile).map(<span class="function"><span class="params">file</span> =&gt;</span> &#123;</div><div class="line">        fullPath = path.join(cssdir, file);</div><div class="line">        stream = fs.readFileSync(fullPath);</div><div class="line">        basename = path.basename(fullPath);</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            ast: stream.parse(stream.toString()),</div><div class="line">            sourcePath: fullPath,</div><div class="line">            distPath: path.join(</div><div class="line">                cssdir,</div><div class="line">                <span class="string">`<span class="subst">$&#123;basename.replace(<span class="regexp">/\.css$/i</span>, <span class="string">""</span>)&#125;</span>.css`</span></div><div class="line">            )</div><div class="line">        &#125;;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> list;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//替换css中的background: url(xxx) 为 background: url(base64: xxxx)</span></div><div class="line"><span class="keyword">const</span> replaceCss = <span class="function">(<span class="params">cssdir, files</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (!files || files.length === <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">const</span> csses = listCssAST(cssdir);</div><div class="line">    <span class="keyword">if</span> (csses.length === <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    files = files.map(<span class="function"><span class="params">file</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            source: file,</div><div class="line">            encoded: toBase64(file)</div><div class="line">        &#125;;</div><div class="line">    &#125;);</div><div class="line">    <span class="comment">//<span class="doctag">TODO:</span>遍历CSS AST并替换引用</span></div><div class="line">    <span class="comment">// csses.forEach((&#123; ast, distPath &#125;) =&gt; &#123;&#125;);</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * promiseifyToFile -&gt; source = yield promiseifyToFile("a/b/c/d.jpg");</span></div><div class="line"><span class="comment"> * @param  &#123;String&#125; file 源文件路径</span></div><div class="line"><span class="comment"> * @param  &#123;String&#125; dist 目标文件路径</span></div><div class="line"><span class="comment"> * 在调用tinypng API异常后, 直接拷贝源文件到相关目录</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">const</span> promiseifyToFile = <span class="function">(<span class="params">file, dist</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">const</span> fileUp = tinify.fromFile(file);</div><div class="line">            fileUp._url</div><div class="line">                .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</div><div class="line">                    fileUp</div><div class="line">                        .toFile(dist)</div><div class="line">                        .then(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</div><div class="line">                            <span class="keyword">if</span> (e) &#123;</div><div class="line">                                reject(e);</div><div class="line">                                <span class="keyword">return</span>;</div><div class="line">                            &#125;</div><div class="line">                            resolve();</div><div class="line">                        &#125;)</div><div class="line">                        .catch(reject);</div><div class="line">                &#125;)</div><div class="line">                .catch(reject);</div><div class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">            fs.copyFileSync(file, dist);</div><div class="line">            resolve();</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//获取类型名</span></div><div class="line"><span class="keyword">const</span> typeOf = <span class="function"><span class="params">obj</span> =&gt;</span> obj2.toString.call(obj).slice(<span class="number">8</span>, <span class="number">-1</span>).toLowerCase();</div><div class="line"></div><div class="line"><span class="keyword">let</span> args;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (process.argv.length &gt; <span class="number">2</span>) &#123;</div><div class="line"><span class="comment">//参数读取和处理</span></div><div class="line">args = parseArgs(process.argv.slice(<span class="number">2</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (args) &#123;</div><div class="line"><span class="comment">//prefix处理</span></div><div class="line">args.prefix = args.prefix || <span class="string">""</span>;</div><div class="line"></div><div class="line"><span class="comment">//源文件目录和css文件目录的绝度路径处理</span></div><div class="line">args.source = args.source.split(<span class="string">"-compress-config-split-"</span>).map(<span class="function"><span class="params">item</span> =&gt;</span> path.join(args.currentDir, item));</div><div class="line">args.cssDir = args.cssDir.split(<span class="string">"-compress-config-split-"</span>).map(<span class="function"><span class="params">item</span> =&gt;</span> path.join(args.currentDir, item));</div><div class="line"></div><div class="line"><span class="comment">//tinypng的API Key</span></div><div class="line">tinify.key = args.key;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 入口函数</span></div><div class="line"><span class="comment"> * @param  options.source</span></div><div class="line"><span class="comment"> * @param  options.outputDir</span></div><div class="line"><span class="comment"> * @param  options.prefix</span></div><div class="line"><span class="comment"> * @param  options.injectCssUrl</span></div><div class="line"><span class="comment"> * @param  options.injectMaxSize</span></div><div class="line"><span class="comment"> * @param  options.cssDir</span></div><div class="line"><span class="comment"> * @param  options.currentDir</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">&#123;</span></span></div><div class="line"><span class="function"><span class="params">    source,</span></span></div><div class="line"><span class="function"><span class="params">    outputDir,</span></span></div><div class="line"><span class="function"><span class="params">    prefix,</span></span></div><div class="line"><span class="function"><span class="params">    injectCssUrl,</span></span></div><div class="line"><span class="function"><span class="params">    injectMaxSize,</span></span></div><div class="line"><span class="function"><span class="params">    cssDir,</span></span></div><div class="line"><span class="function"><span class="params">    currentDir</span></span></div><div class="line"><span class="function"><span class="params">&#125;</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> distPath = distDir(currentDir, outputDir),</div><div class="line">        filesList = [],</div><div class="line">        tmp = <span class="literal">null</span>,</div><div class="line">        basename;</div><div class="line"></div><div class="line">    mkdirp.sync(distPath);</div><div class="line"></div><div class="line">    <span class="comment">//异步上传, 并且放到具体的目录</span></div><div class="line">    co(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> dirs) &#123;</div><div class="line">                tmp = <span class="keyword">yield</span> dir.promiseFiles(i);</div><div class="line">                filesList = [].concat.call(filesList, tmp.filter(<span class="function"><span class="params">file</span> =&gt;</span> isImageFile(file)));</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (tmp <span class="keyword">of</span> filesList) &#123;</div><div class="line">                basename = path.basename(tmp);</div><div class="line">                <span class="keyword">const</span> res = <span class="keyword">yield</span> promiseifyToFile(</div><div class="line">                    tmp,</div><div class="line">                    path.join(distPath, basename)</div><div class="line">                );</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">init(args);</div></pre></td></tr></table></figure><p>到这里, 我们的第一个命令就实现好了, 如果想测试, 可以直接在<code>Sublime Text</code>按下<code>ctrl + &#39;</code>(数字1前面那个键), 然后在<code>console</code>中运行<code>view.run_command(&quot;image_compress&quot;)</code>, <code>view.run_command</code>接收的参数和我们在<code>keyMap</code>或者<code>command</code>里面定义的一致。</p><p>至此, 我们插件的第一个功能就完成了, 后面还有两个需要做, 相对简单, 不再做介绍, 用法和代码请移步<a href="https://github.com/rwson/sublime-image-compressor" target="_blank" rel="external">GitHub</a>。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>我们可以用这种模式开发很多插件, 比如代码压缩类、 代码格式化类、 代码语法检测类等等, 关于这些, <a href="https://www.npmjs.com/" target="_blank" rel="external">npm</a>上面有很多现成的包, <code>NodeJs</code>端需要做的只有处理输入, 再返回结果就好。</p><p>这种模式方便了很多人去自己开发插件, 但是也有一些缺点, 首先开发的时候很痛苦, 不易调试, 而且在用<code>Node</code>和<code>Python</code>通信的时候, 数据多的时候可能会有些延迟等等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.sublimetext.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Sublime Text&lt;/a&gt;著有最性感的编辑器之称,它轻量,易于拓展,通过插件的方式可使它变得很强大,而我更是把它作为自己的主要编
      
    
    </summary>
    
      <category term="NodeJs" scheme="http://yoursite.com/categories/NodeJs/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/NodeJs/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>webpack源码阅读</title>
    <link href="http://yoursite.com/2017/09/25/2017-09-25-read-webpack-source/"/>
    <id>http://yoursite.com/2017/09/25/2017-09-25-read-webpack-source/</id>
    <published>2017-09-24T16:00:00.000Z</published>
    <updated>2017-09-26T13:12:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>在前端工程化越来越普及的今天，我们几乎每个项目都需要用到构建工具，从一开始的<code>grunt</code>，到<code>gulp</code>，再到现在的<code>webpack</code>。<br>我们在使用<code>webpack</code>时，可以通过配置一些命令行参数来让<code>webpack</code>完成一些编译打包的任务，那么当我们执行<code>webpack</code>这个命令的时候，<code>webpack</code>究竟做了哪些事情? 我们一起来读读<code>webpack</code>的相关源码。</p><p>注：本文阅读的版本为<a href="https://github.com/webpack/webpack/tree/webpack-1" target="_blank" rel="external">webpack1.15.0</a>，从入口开始分析再拿到我们的命令之后执行的的流程，所以有些个人认为不重要的可能会省略。</p><p>通过<code>package.json</code>中的<code>bin</code>的指向可以知道首先会走到<code>./bin/webpack.js</code>这个文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/usr/bin/env node</span></div><div class="line"></div><div class="line"><span class="comment">//引入nodejs path模块</span></div><div class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</div><div class="line"></div><div class="line"><span class="comment">// require.resolve获取/bin/webpack.js的绝对路径(从项目根目录下的node_modules里面找)</span></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line"><span class="keyword">var</span> localWebpack = <span class="built_in">require</span>.resolve(path.join(process.cwd(), <span class="string">"node_modules"</span>, <span class="string">"webpack"</span>, <span class="string">"bin"</span>, <span class="string">"webpack.js"</span>));</div><div class="line"><span class="keyword">if</span>(__filename !== localWebpack) &#123;</div><div class="line"><span class="keyword">return</span> <span class="built_in">require</span>(localWebpack);</div><div class="line">&#125;</div><div class="line">&#125; <span class="keyword">catch</span>(e) &#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> optimist = <span class="built_in">require</span>(<span class="string">"optimist"</span>)</div><div class="line">.usage(<span class="string">"webpack "</span> + <span class="built_in">require</span>(<span class="string">"../package.json"</span>).version + <span class="string">"\n"</span> +</div><div class="line"><span class="string">"Usage: https://webpack.github.io/docs/cli.html"</span>);</div><div class="line"></div><div class="line"><span class="built_in">require</span>(<span class="string">"./config-optimist"</span>)(optimist);</div><div class="line"></div><div class="line"><span class="comment">//对在命令行传入的参数进行解析</span></div><div class="line"><span class="comment">//--colors、--json、 ...</span></div><div class="line">optimist</div><div class="line">.boolean(<span class="string">"json"</span>).alias(<span class="string">"json"</span>, <span class="string">"j"</span>).describe(<span class="string">"json"</span>)</div><div class="line">.boolean(<span class="string">"colors"</span>).alias(<span class="string">"colors"</span>, <span class="string">"c"</span>).describe(<span class="string">"colors"</span>)</div><div class="line"><span class="comment">//其他参数解析, 略;</span></div><div class="line"></div><div class="line"><span class="comment">//获取解析后的参数并转换格式</span></div><div class="line"><span class="keyword">var</span> argv = optimist.argv;</div><div class="line"><span class="keyword">var</span> options = <span class="built_in">require</span>(<span class="string">"./convert-argv"</span>)(optimist, argv);</div><div class="line"></div><div class="line"><span class="comment">//如果有符合argv里面的参数</span></div><div class="line"><span class="comment">//就执行相关的回调函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ifArg</span>(<span class="params">name, fn, init</span>) </span>&#123;</div><div class="line"><span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(argv[name])) &#123;</div><div class="line"><span class="keyword">if</span>(init) init();</div><div class="line">argv[name].forEach(fn);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> argv[name] !== <span class="string">"undefined"</span>) &#123;</div><div class="line"><span class="keyword">if</span>(init) init();</div><div class="line">fn(argv[name], <span class="number">-1</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> *  处理输出相关（output）的配置参数，并执行编译函数</span></div><div class="line"><span class="comment"> *  @param   &#123;[type]&#125;  options  [description]</span></div><div class="line"><span class="comment"> *  @return  &#123;[type]&#125;           [description]</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">processOptions</span>(<span class="params">options</span>) </span>&#123;</div><div class="line"><span class="comment">//如果options下面的then是个函数(options是个Promise示例)</span></div><div class="line"><span class="comment">//把processOptions作为参数传到options.then中</span></div><div class="line"><span class="comment">//并且中断下面代码的执行</span></div><div class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> options.then === <span class="string">"function"</span>) &#123;</div><div class="line">options.then(processOptions).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line"><span class="built_in">console</span>.error(err.stack || err);</div><div class="line">process.exit();</div><div class="line">&#125;);</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//如果传入的options是一个数组, 取数组的第一项</span></div><div class="line"><span class="keyword">var</span> firstOptions = <span class="built_in">Array</span>.isArray(options) ? options[<span class="number">0</span>] : options;</div><div class="line"></div><div class="line"><span class="comment">//输出的配置</span></div><div class="line"><span class="keyword">var</span> outputOptions = <span class="built_in">Object</span>.create(options.stats || firstOptions.stats || &#123;&#125;);</div><div class="line"></div><div class="line"><span class="comment">//如果outputOptions中本身没有context</span></div><div class="line"><span class="comment">//就把配置项中的context给它</span></div><div class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> outputOptions.context === <span class="string">"undefined"</span>)</div><div class="line">outputOptions.context = firstOptions.context;</div><div class="line"></div><div class="line"><span class="comment">//各种命令行参数处理</span></div><div class="line">ifArg(<span class="string">"json"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">bool</span>) </span>&#123;</div><div class="line"><span class="keyword">if</span>(bool)</div><div class="line">outputOptions.json = bool;</div><div class="line">&#125;);</div><div class="line"><span class="comment">//还有很多ifArg，略</span></div><div class="line"></div><div class="line"><span class="comment">//引入webpack入口文件</span></div><div class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">"../lib/webpack.js"</span>);</div><div class="line"></div><div class="line"><span class="comment">//错误堆栈追踪上限</span></div><div class="line"><span class="built_in">Error</span>.stackTraceLimit = <span class="number">30</span>;</div><div class="line"><span class="keyword">var</span> lastHash = <span class="literal">null</span>;</div><div class="line"></div><div class="line"><span class="comment">//执行编译</span></div><div class="line"><span class="keyword">var</span> compiler = webpack(options);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compilerCallback</span>(<span class="params">err, stats</span>) </span>&#123;</div><div class="line">      <span class="comment">//命令行参数中没有带有--watch</span></div><div class="line"><span class="keyword">if</span>(!options.watch) &#123;</div><div class="line">compiler.purgeInputFileSystem();</div><div class="line">&#125;</div><div class="line">      </div><div class="line">      <span class="comment">//出错</span></div><div class="line"><span class="keyword">if</span>(err) &#123;</div><div class="line">lastHash = <span class="literal">null</span>;</div><div class="line"><span class="built_in">console</span>.error(err.stack || err);</div><div class="line"><span class="keyword">if</span>(err.details) <span class="built_in">console</span>.error(err.details);</div><div class="line"><span class="keyword">if</span>(!options.watch) &#123;</div><div class="line">process.on(<span class="string">"exit"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">process.exit(<span class="number">1</span>);</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>(outputOptions.json) &#123;</div><div class="line">process.stdout.write(<span class="built_in">JSON</span>.stringify(stats.toJson(outputOptions), <span class="literal">null</span>, <span class="number">2</span>) + <span class="string">"\n"</span>);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(stats.hash !== lastHash) &#123;</div><div class="line">lastHash = stats.hash;</div><div class="line">process.stdout.write(stats.toString(outputOptions) + <span class="string">"\n"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="comment">//命令行参数中带有--watch</span></div><div class="line"><span class="keyword">if</span>(options.watch) &#123;</div><div class="line"><span class="keyword">var</span> primaryOptions = !<span class="built_in">Array</span>.isArray(options) ? options : options[<span class="number">0</span>];</div><div class="line"><span class="keyword">var</span> watchOptions = primaryOptions.watchOptions || primaryOptions.watch || &#123;&#125;;</div><div class="line"><span class="keyword">if</span>(watchOptions.stdin) &#123;</div><div class="line">process.stdin.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">process.exit(<span class="number">0</span>); <span class="comment">// eslint-disable-line</span></div><div class="line">&#125;);</div><div class="line">process.stdin.resume();</div><div class="line">&#125;</div><div class="line">      </div><div class="line">      <span class="comment">//调用compiler下面的watch来监听文件变化</span></div><div class="line">compiler.watch(watchOptions, compilerCallback);</div><div class="line">&#125; <span class="keyword">else</span></div><div class="line">compiler.run(compilerCallback);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//执行processOptions并且传入解析出来的参数</span></div><div class="line">processOptions(options);</div></pre></td></tr></table></figure><p>在上面定义的<code>processOptions</code>方法中可以看到引入了<code>../lib/webpack.js</code>这个文件，下面我们一起看看<code>../lib/webpack.js</code>这个文件。</p><p>在<code>../lib/webpack.js</code>中，<code>webpack</code>作为入口函数，我们一起看下它的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> *  webpack入口</span></div><div class="line"><span class="comment"> *  @param   &#123;Object&#125;    options   webpack.config.js中module.exports出来的对象</span></div><div class="line"><span class="comment"> *  @param   &#123;Function&#125;  callback  回调函数</span></div><div class="line"><span class="comment"> *  @return  &#123;Object&#125;              webpack Compiler Object/multi compiler object Collection</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">webpack</span>(<span class="params">options, callback</span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> compiler;</div><div class="line"><span class="comment">//options是一个数组时, 实例化一个MultiCompiler, 去map这个数组, 针对每个配置项返回一个webpack实例, 最后用compiler接收</span></div><div class="line"><span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(options)) &#123;</div><div class="line">compiler = <span class="keyword">new</span> MultiCompiler(options.map(<span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> webpack(options);</div><div class="line">&#125;));</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> options === <span class="string">"object"</span>) &#123;</div><div class="line"></div><div class="line"><span class="comment">// 实例化一个WebpackOptionsDefaulter来处理默认配置项</span></div><div class="line"><span class="keyword">new</span> WebpackOptionsDefaulter().process(options);</div><div class="line"></div><div class="line"><span class="comment">//实例化一个Compiler, Compiler继承自Tapable(https://doc.webpack-china.org/api/plugins/tapable/)</span></div><div class="line"><span class="comment">//Compiler实例化后会继承到apply、plugin等调用和绑定插件的方法</span></div><div class="line">compiler = <span class="keyword">new</span> Compiler();</div><div class="line"></div><div class="line"><span class="comment">//配置项</span></div><div class="line">compiler.options = options;</div><div class="line"></div><div class="line"><span class="comment">//对传入的options进行逐个编译,并且把options作为返回值重赋值到compiler.options</span></div><div class="line">compiler.options = <span class="keyword">new</span> WebpackOptionsApply().process(options, compiler);</div><div class="line"></div><div class="line"><span class="comment">//应用node环境插件(给compiler设置resolvers、watchFileSystem、outputFileSystem)</span></div><div class="line"><span class="keyword">new</span> NodeEnvironmentPlugin().apply(compiler);</div><div class="line"></div><div class="line"><span class="comment">//触发environment和after-environment事件</span></div><div class="line">compiler.applyPlugins(<span class="string">"environment"</span>);</div><div class="line">compiler.applyPlugins(<span class="string">"after-environment"</span>);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="comment">//options既不是数组也不是对象时, 抛出异常</span></div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Invalid argument: options"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//存在回调函数</span></div><div class="line"><span class="keyword">if</span>(callback) &#123;</div><div class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> callback !== <span class="string">"function"</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Invalid argument: callback"</span>);</div><div class="line"></div><div class="line"><span class="comment">//命令行里面带watch, 或者options是个数组(并且数组中有一项的watch为true)</span></div><div class="line"><span class="keyword">if</span>(options.watch === <span class="literal">true</span> || (<span class="built_in">Array</span>.isArray(options) &amp;&amp;</div><div class="line">options.some(<span class="function"><span class="keyword">function</span>(<span class="params">o</span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> o.watch;</div><div class="line">&#125;))) &#123;</div><div class="line"></div><div class="line"><span class="comment">//根据参数类型拿到watchOptions</span></div><div class="line"><span class="keyword">var</span> watchOptions = (!<span class="built_in">Array</span>.isArray(options) ? options : options[<span class="number">0</span>]).watchOptions || &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">//watchDelay属性应该被options.watchOptions.aggregateTimeout代替</span></div><div class="line"><span class="keyword">var</span> watchDelay = (!<span class="built_in">Array</span>.isArray(options) ? options : options[<span class="number">0</span>]).watchDelay;</div><div class="line"><span class="keyword">if</span>(watchDelay) &#123;</div><div class="line"><span class="built_in">console</span>.warn(<span class="string">"options.watchDelay is deprecated: Use 'options.watchOptions.aggregateTimeout' instead"</span>);</div><div class="line">watchOptions.aggregateTimeout = watchDelay;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//实例化并返回一个watch对象</span></div><div class="line"><span class="keyword">return</span> compiler.watch(watchOptions, callback);</div><div class="line">&#125;</div><div class="line">compiler.run(callback);</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> compiler;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> *  在对象下用Object.defineProperty的方法添加插件</span></div><div class="line"><span class="comment"> *  @param   &#123;Object&#125;  exports  被添加的对象</span></div><div class="line"><span class="comment"> *  @param   &#123;String&#125;  path     在get中返回require</span></div><div class="line"><span class="comment"> *  @param   &#123;Array&#125;   plugins  插件数组</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">exportPlugins</span>(<span class="params">exports, path, plugins</span>) </span>&#123;</div><div class="line">plugins.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line"><span class="built_in">Object</span>.defineProperty(exports, name, &#123;</div><div class="line">configurable: <span class="literal">false</span>,</div><div class="line">enumerable: <span class="literal">true</span>,</div><div class="line">get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="built_in">require</span>(path + <span class="string">"/"</span> + name);</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在这个文件最后，通过上面的<code>exportPlugins</code>在<code>webpack</code>下面挂载了一些插件做属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//暴露插件到webpack下面</span></div><div class="line"><span class="comment">//new webpack.DefinePlugin()</span></div><div class="line"><span class="comment">//...</span></div><div class="line">exportPlugins(exports, <span class="string">"."</span>, [</div><div class="line"><span class="string">"DefinePlugin"</span>,</div><div class="line"><span class="comment">//...</span></div><div class="line">]);</div><div class="line">exportPlugins(exports.optimize = &#123;&#125;, <span class="string">"./optimize"</span>, [</div><div class="line"><span class="string">"AggressiveMergingPlugin"</span>,</div><div class="line"><span class="string">"CommonsChunkPlugin"</span>,</div><div class="line"><span class="string">"DedupePlugin"</span>,</div><div class="line"><span class="string">"LimitChunkCountPlugin"</span>,</div><div class="line"><span class="string">"MinChunkSizePlugin"</span>,</div><div class="line"><span class="string">"OccurenceOrderPlugin"</span>,</div><div class="line"><span class="string">"OccurrenceOrderPlugin"</span>,</div><div class="line"><span class="string">"UglifyJsPlugin"</span></div><div class="line">]);</div><div class="line">exportPlugins(exports.dependencies = &#123;&#125;, <span class="string">"./dependencies"</span>, [</div><div class="line"><span class="string">"LabeledModulesPlugin"</span></div><div class="line">]);</div></pre></td></tr></table></figure><p>刚才在对<code>webpack</code>进行标注的时候，实例化了<code>WebpackOptionsApply</code>对象并且调用了<code>process</code>方法，这个方法将会对我们传进去的<code>options</code>和<code>compiler</code>编译对象进行逐个编译，下面我们一起看下<code>WebpackOptionsApply</code>这个模块的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">WebpackOptionsApply</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="comment">//OptionsApply构造函数的继承</span></div><div class="line">OptionsApply.call(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">module</span>.exports = WebpackOptionsApply;</div><div class="line"></div><div class="line"><span class="comment">//继承OptionsApply的原型</span></div><div class="line">WebpackOptionsApply.prototype = <span class="built_in">Object</span>.create(OptionsApply.prototype);</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> *  对我们传进去的options和compiler编译对象进行逐个编译</span></div><div class="line"><span class="comment"> *  @param   &#123;[type]&#125;  options   [description]</span></div><div class="line"><span class="comment"> *  @param   &#123;[type]&#125;  compiler  [description]</span></div><div class="line"><span class="comment"> *  @return  &#123;[type]&#125;            [description]</span></div><div class="line"><span class="comment"> */</span></div><div class="line">WebpackOptionsApply.prototype.process = <span class="function"><span class="keyword">function</span>(<span class="params">options, compiler</span>) </span>&#123;</div><div class="line"><span class="comment">//context处理</span></div><div class="line">compiler.context = options.context;</div><div class="line"></div><div class="line"><span class="comment">//plugins的处理, 调用compiler.apply.apply</span></div><div class="line"><span class="keyword">if</span>(options.plugins &amp;&amp; <span class="built_in">Array</span>.isArray(options.plugins)) &#123;</div><div class="line">compiler.apply.apply(compiler, options.plugins);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//缓存输入输出的路径</span></div><div class="line">compiler.outputPath = options.output.path;</div><div class="line">compiler.recordsInputPath = options.recordsInputPath || options.recordsPath;</div><div class="line">compiler.recordsOutputPath = options.recordsOutputPath || options.recordsPath;</div><div class="line">compiler.name = options.name;</div><div class="line"></div><div class="line"><span class="comment">//如果options.target是个字符串,根据options.target判断具体应用哪些插件(compiler.apply)</span></div><div class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> options.target === <span class="string">"string"</span>) &#123;</div><div class="line"><span class="comment">//这边本来有个switch...case来根据options.target的具体值应用</span></div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(options.target !== <span class="literal">false</span>) &#123;</div><div class="line">options.target(compiler);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Unsupported target '"</span> + options.target + <span class="string">"'."</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//output.library相关配置</span></div><div class="line"><span class="keyword">if</span>(options.output.library || options.output.libraryTarget !== <span class="string">"var"</span>) &#123;</div><div class="line"><span class="keyword">var</span> LibraryTemplatePlugin = <span class="built_in">require</span>(<span class="string">"./LibraryTemplatePlugin"</span>);</div><div class="line">compiler.apply(<span class="keyword">new</span> LibraryTemplatePlugin(options.output.library, options.output.libraryTarget, options.output.umdNamedDefine));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//处理externals属性,告诉webpack不要打包这些模块,而是在运行时从环境中请求他们</span></div><div class="line"><span class="keyword">if</span>(options.externals) &#123;</div><div class="line"><span class="keyword">var</span> ExternalsPlugin = <span class="built_in">require</span>(<span class="string">"./ExternalsPlugin"</span>);</div><div class="line">compiler.apply(<span class="keyword">new</span> ExternalsPlugin(options.output.libraryTarget, options.externals));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//处理hot属性,devServer相关</span></div><div class="line"><span class="keyword">if</span>(options.hot) &#123;</div><div class="line">compiler.apply(<span class="keyword">new</span> MovedToPluginWarningPlugin(<span class="string">"hot"</span>, <span class="string">"HotModuleReplacementPlugin"</span>));</div><div class="line"><span class="keyword">var</span> HotModuleReplacementPlugin = <span class="built_in">require</span>(<span class="string">"./HotModuleReplacementPlugin"</span>);</div><div class="line">compiler.apply(<span class="keyword">new</span> HotModuleReplacementPlugin(options.output));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//devtool和sourceMap相关配置</span></div><div class="line"><span class="keyword">if</span>(options.devtool &amp;&amp; (options.devtool.indexOf(<span class="string">"sourcemap"</span>) &gt;= <span class="number">0</span> || options.devtool.indexOf(<span class="string">"source-map"</span>) &gt;= <span class="number">0</span>)) &#123;</div><div class="line"><span class="keyword">var</span> hidden = options.devtool.indexOf(<span class="string">"hidden"</span>) &gt;= <span class="number">0</span>;</div><div class="line"><span class="keyword">var</span> inline = options.devtool.indexOf(<span class="string">"inline"</span>) &gt;= <span class="number">0</span>;</div><div class="line"><span class="keyword">var</span> evalWrapped = options.devtool.indexOf(<span class="string">"eval"</span>) &gt;= <span class="number">0</span>;</div><div class="line"><span class="keyword">var</span> cheap = options.devtool.indexOf(<span class="string">"cheap"</span>) &gt;= <span class="number">0</span>;</div><div class="line"><span class="keyword">var</span> moduleMaps = options.devtool.indexOf(<span class="string">"module"</span>) &gt;= <span class="number">0</span>;</div><div class="line"><span class="keyword">var</span> noSources = options.devtool.indexOf(<span class="string">"nosources"</span>) &gt;= <span class="number">0</span>;</div><div class="line"><span class="keyword">var</span> legacy = options.devtool.indexOf(<span class="string">"@"</span>) &gt;= <span class="number">0</span>;</div><div class="line"><span class="keyword">var</span> modern = options.devtool.indexOf(<span class="string">"#"</span>) &gt;= <span class="number">0</span>;</div><div class="line"><span class="keyword">var</span> comment = legacy &amp;&amp; modern ? <span class="string">"\n/*\n//@ sourceMappingURL=[url]\n//# sourceMappingURL=[url]\n*/"</span> :</div><div class="line">legacy ? <span class="string">"\n/*\n//@ sourceMappingURL=[url]\n*/"</span> :</div><div class="line">modern ? <span class="string">"\n//# sourceMappingURL=[url]"</span> :</div><div class="line"><span class="literal">null</span>;</div><div class="line"><span class="keyword">var</span> Plugin = evalWrapped ? EvalSourceMapDevToolPlugin : SourceMapDevToolPlugin;</div><div class="line">compiler.apply(<span class="keyword">new</span> Plugin(&#123;</div><div class="line">filename: inline ? <span class="literal">null</span> : options.output.sourceMapFilename,</div><div class="line">moduleFilenameTemplate: options.output.devtoolModuleFilenameTemplate,</div><div class="line">fallbackModuleFilenameTemplate: options.output.devtoolFallbackModuleFilenameTemplate,</div><div class="line">append: hidden ? <span class="literal">false</span> : comment,</div><div class="line"><span class="built_in">module</span>: moduleMaps ? <span class="literal">true</span> : cheap ? <span class="literal">false</span> : <span class="literal">true</span>,</div><div class="line">columns: cheap ? <span class="literal">false</span> : <span class="literal">true</span>,</div><div class="line">lineToLine: options.output.devtoolLineToLine,</div><div class="line">noSources: noSources,</div><div class="line">&#125;));</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(options.devtool &amp;&amp; options.devtool.indexOf(<span class="string">"eval"</span>) &gt;= <span class="number">0</span>) &#123;</div><div class="line"><span class="keyword">var</span> legacy = options.devtool.indexOf(<span class="string">"@"</span>) &gt;= <span class="number">0</span>;</div><div class="line"><span class="keyword">var</span> modern = options.devtool.indexOf(<span class="string">"#"</span>) &gt;= <span class="number">0</span>;</div><div class="line"><span class="keyword">var</span> comment = legacy &amp;&amp; modern ? <span class="string">"//@ sourceURL=[url]\n//# sourceURL=[url]"</span> :</div><div class="line">legacy ? <span class="string">"//@ sourceURL=[url]"</span> :</div><div class="line">modern ? <span class="string">"//# sourceURL=[url]"</span> :</div><div class="line"><span class="literal">null</span>;</div><div class="line">compiler.apply(<span class="keyword">new</span> EvalDevToolModulePlugin(comment, options.output.devtoolModuleFilenameTemplate));</div><div class="line">&#125;</div><div class="line"></div><div class="line">compiler.apply(<span class="keyword">new</span> EntryOptionPlugin());</div><div class="line">compiler.applyPluginsBailResult(<span class="string">"entry-option"</span>, options.context, options.entry);</div><div class="line"></div><div class="line"><span class="keyword">if</span>(options.prefetch) &#123;</div><div class="line">compiler.apply(<span class="keyword">new</span> MovedToPluginWarningPlugin(<span class="string">"prefetch"</span>, <span class="string">"PrefetchPlugin"</span>));</div><div class="line"><span class="keyword">var</span> PrefetchPlugin = <span class="built_in">require</span>(<span class="string">"./PrefetchPlugin"</span>);</div><div class="line">options.prefetch.map(<span class="function"><span class="keyword">function</span>(<span class="params">request</span>) </span>&#123;</div><div class="line">compiler.apply(<span class="keyword">new</span> PrefetchPlugin(options.context, request));</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line">compiler.apply(</div><div class="line"><span class="keyword">new</span> CompatibilityPlugin(),</div><div class="line"><span class="keyword">new</span> LoaderPlugin(),<span class="comment">//loader插件</span></div><div class="line"><span class="keyword">new</span> NodeStuffPlugin(options.node),<span class="comment">//nodejs环境相关的插件</span></div><div class="line"><span class="keyword">new</span> RequireJsStuffPlugin(),<span class="comment">//RequireJs的插件</span></div><div class="line"><span class="keyword">new</span> APIPlugin(),<span class="comment">//变量名的替换,编译后的文件里随处可见的__webpack_require__变量名就是在此处理</span></div><div class="line"><span class="keyword">new</span> ConstPlugin(),<span class="comment">//转换一些if, 三目表达式等等</span></div><div class="line"><span class="keyword">new</span> RequireIncludePlugin(),<span class="comment">//require.include函数的转换</span></div><div class="line"><span class="keyword">new</span> RequireEnsurePlugin(),<span class="comment">//require.ensure函数的转换</span></div><div class="line"><span class="keyword">new</span> RequireContextPlugin(options.resolve.modulesDirectories, options.resolve.extensions),</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">new</span> AMDPlugin(options.module, options.amd || &#123;&#125;),</div><div class="line"><span class="comment">//AMD规范插件</span></div><div class="line"><span class="keyword">new</span> CommonJsPlugin(options.module)<span class="comment">//commonJs规范插件</span></div><div class="line">);</div><div class="line"></div><div class="line">compiler.apply(</div><div class="line"><span class="keyword">new</span> RemoveParentModulesPlugin(),<span class="comment">//移除父module的插件</span></div><div class="line"><span class="keyword">new</span> RemoveEmptyChunksPlugin(),<span class="comment">//移除空模块的插件</span></div><div class="line"><span class="keyword">new</span> MergeDuplicateChunksPlugin(),<span class="comment">//移除重复模块的插件</span></div><div class="line"><span class="keyword">new</span> FlagIncludedChunksPlugin()<span class="comment">//output中对于名称的配置([name].[hash].[ext])</span></div><div class="line">);</div><div class="line"></div><div class="line">compiler.apply(<span class="keyword">new</span> TemplatedPathPlugin());</div><div class="line"></div><div class="line">compiler.apply(<span class="keyword">new</span> RecordIdsPlugin());<span class="comment">//记录chunkId的插件</span></div><div class="line"></div><div class="line">compiler.apply(<span class="keyword">new</span> WarnCaseSensitiveModulesPlugin());</div><div class="line"><span class="comment">//大小写敏感的插件</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * webpack.optimize属性下的几个方法</span></div><div class="line"><span class="comment"> * ./webpack.js</span></div><div class="line"><span class="comment"> * exportPlugins(exports.optimize = &#123;&#125;, "./optimize", [</span></div><div class="line"><span class="comment"> * "AggressiveMergingPlugin"</span></div><div class="line"><span class="comment"> * //...</span></div><div class="line"><span class="comment"> * ]);</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">if</span>(options.optimize &amp;&amp; options.optimize.occurenceOrder) &#123;</div><div class="line">compiler.apply(<span class="keyword">new</span> MovedToPluginWarningPlugin(<span class="string">"optimize.occurenceOrder"</span>, <span class="string">"optimize.OccurrenceOrderPlugin"</span>));</div><div class="line"><span class="keyword">var</span> OccurrenceOrderPlugin = <span class="built_in">require</span>(<span class="string">"./optimize/OccurrenceOrderPlugin"</span>);</div><div class="line">compiler.apply(<span class="keyword">new</span> OccurrenceOrderPlugin(options.optimize.occurenceOrderPreferEntry));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 处理minChunkSize, 性能优化相关</span></div><div class="line"><span class="comment"> * 一些小模块会被打包成单独的模块而造成不必要的HTTP请求, 指定minChunkSize会合并这些小模块, 减少HTTP请求</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">if</span>(options.optimize &amp;&amp; options.optimize.minChunkSize) &#123;</div><div class="line">compiler.apply(<span class="keyword">new</span> MovedToPluginWarningPlugin(<span class="string">"optimize.minChunkSize"</span>, <span class="string">"optimize.MinChunkSizePlugin"</span>));</div><div class="line"><span class="keyword">var</span> MinChunkSizePlugin = <span class="built_in">require</span>(<span class="string">"./optimize/MinChunkSizePlugin"</span>);</div><div class="line">compiler.apply(<span class="keyword">new</span> MinChunkSizePlugin(options.optimize));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//和maxChunksSize相反</span></div><div class="line"><span class="keyword">if</span>(options.optimize &amp;&amp; options.optimize.maxChunks) &#123;</div><div class="line">compiler.apply(<span class="keyword">new</span> MovedToPluginWarningPlugin(<span class="string">"optimize.maxChunks"</span>, <span class="string">"optimize.LimitChunkCountPlugin"</span>));</div><div class="line"><span class="keyword">var</span> LimitChunkCountPlugin = <span class="built_in">require</span>(<span class="string">"./optimize/LimitChunkCountPlugin"</span>);</div><div class="line">compiler.apply(<span class="keyword">new</span> LimitChunkCountPlugin(options.optimize));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span>(options.optimize.minimize) &#123;</div><div class="line">compiler.apply(<span class="keyword">new</span> MovedToPluginWarningPlugin(<span class="string">"optimize.minimize"</span>, <span class="string">"optimize.UglifyJsPlugin"</span>));</div><div class="line"><span class="keyword">var</span> UglifyJsPlugin = <span class="built_in">require</span>(<span class="string">"./optimize/UglifyJsPlugin"</span>);</div><div class="line"><span class="keyword">if</span>(options.optimize.minimize === <span class="literal">true</span>)</div><div class="line">compiler.apply(<span class="keyword">new</span> UglifyJsPlugin());</div><div class="line"><span class="keyword">else</span></div><div class="line">compiler.apply(<span class="keyword">new</span> UglifyJsPlugin(options.optimize.minimize));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//缓存,该属性在watch的模式下默认开启缓存</span></div><div class="line"><span class="keyword">if</span>(options.cache === <span class="literal">undefined</span> ? options.watch : options.cache) &#123;</div><div class="line"><span class="keyword">var</span> CachePlugin = <span class="built_in">require</span>(<span class="string">"./CachePlugin"</span>);</div><div class="line">compiler.apply(<span class="keyword">new</span> CachePlugin(<span class="keyword">typeof</span> options.cache === <span class="string">"object"</span> ? options.cache : <span class="literal">null</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 处理provide属性,如果有则调用ProvidePlugin插件,这个插件可以让一个module赋值为一个变量,从而能在每个module中以变量名访问它</span></div><div class="line"><span class="comment"> * new webpack.ProvidePlugin(&#123;</span></div><div class="line"><span class="comment"> * identifier: "module1"</span></div><div class="line"><span class="comment"> * &#125;);</span></div><div class="line"><span class="comment"> * new webpack.ProvidePlugin(&#123;</span></div><div class="line"><span class="comment"> * identifier: ["module1", "property1"]</span></div><div class="line"><span class="comment"> * &#125;);</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> options.provide === <span class="string">"object"</span>) &#123;</div><div class="line">compiler.apply(<span class="keyword">new</span> MovedToPluginWarningPlugin(<span class="string">"provide"</span>, <span class="string">"ProvidePlugin"</span>));</div><div class="line"><span class="keyword">var</span> ProvidePlugin = <span class="built_in">require</span>(<span class="string">"./ProvidePlugin"</span>);</div><div class="line">compiler.apply(<span class="keyword">new</span> ProvidePlugin(options.provide));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 处理define属性,如果有这个属性则调用DefinePlugin插件,这个插件可以定义全局的常量</span></div><div class="line"><span class="comment"> * //define</span></div><div class="line"><span class="comment"> * new webpack.DefinePlugin(&#123;</span></div><div class="line"><span class="comment"> * PRODUCTION: JSON.stringify(true),</span></div><div class="line"><span class="comment"> * BROWSER_SUPPORTS_HTML5: true</span></div><div class="line"><span class="comment"> * &#125;);</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * //use</span></div><div class="line"><span class="comment"> * if(!PRODUCTION) &#123;</span></div><div class="line"><span class="comment"> * console.log("develop mode");</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * if (!BROWSER_SUPPORTS_HTML5) &#123;</span></div><div class="line"><span class="comment"> * require("html5shiv");</span></div><div class="line"><span class="comment"> * &#125; </span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">if</span>(options.define) &#123;</div><div class="line">compiler.apply(<span class="keyword">new</span> MovedToPluginWarningPlugin(<span class="string">"define"</span>, <span class="string">"DefinePlugin"</span>));</div><div class="line"><span class="keyword">var</span> defineObject = &#123;&#125;;</div><div class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> options.define === <span class="string">"object"</span>) &#123;</div><div class="line"><span class="built_in">Object</span>.keys(options.define).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</div><div class="line">defineObject[key] = options.define[key];</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line">compiler.apply(<span class="keyword">new</span> DefinePlugin(defineObject));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//defineDebug不为false,声明一个全局的DEBUG</span></div><div class="line"><span class="keyword">if</span>(options.defineDebug !== <span class="literal">false</span>)</div><div class="line">compiler.apply(<span class="keyword">new</span> DefinePlugin(&#123;</div><div class="line">DEBUG: !!options.debug</div><div class="line">&#125;));</div><div class="line"></div><div class="line"><span class="comment">//触发after-plugins和应用一些其他插件, 最后触发after-resolvers</span></div><div class="line">compiler.applyPlugins(<span class="string">"after-plugins"</span>, compiler);</div><div class="line">compiler.resolvers.normal.apply(</div><div class="line"><span class="keyword">new</span> UnsafeCachePlugin(options.resolve.unsafeCache)</div><div class="line"><span class="comment">//...</span></div><div class="line">);</div><div class="line"><span class="comment">//...</span></div><div class="line">compiler.applyPlugins(<span class="string">"after-resolvers"</span>, compiler);</div><div class="line"></div><div class="line"><span class="comment">//返回options</span></div><div class="line"><span class="keyword">return</span> options;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>看完这一段之后，个人对<code>webpack</code>的了解更深入了一些，熟悉了好几个平常不怎么用到，但是感觉还是很有用的东西，例如<code>externals</code>和<code>define</code>属性。</p><p>到这里，<code>webpack</code>的整体流程算是完了，在<code>webpack</code>中，有各式各样的插件，下面我们一起了解下大家所熟知的<code>UglifyJsPlugin</code>来理解下插件体系和加深对<code>webpack</code>流程的理解。</p><p>首先我们了解下开发<a href="https://doc.webpack-china.org/development/how-to-write-a-plugin" target="_blank" rel="external">webpack插件</a>的一些事项：<br>在中文里面提到：</p><ul><li>一个JavaScript命名函数</li><li>在它的原型上定义一个<code>apply</code>方法</li><li>指定挂载的webpack事件钩子</li><li>处理webpack内部实例的特定数据</li><li>功能完成后调用webpack提供的回调</li></ul><p>基础结构如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 命名函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyExampleWebpackPlugin</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="comment">//...</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 在它的 prototype 上定义一个 apply 方法。</span></div><div class="line">MyExampleWebpackPlugin.prototype.apply = <span class="function"><span class="keyword">function</span>(<span class="params">compiler</span>) </span>&#123;</div><div class="line">  <span class="comment">// 指定挂载的webpack事件钩子</span></div><div class="line">  compiler.plugin(<span class="string">'webpacksEventHook'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">compilation <span class="regexp">/* 处理webpack内部实例的特定数据*/</span>, callback</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"This is an example plugin!!!"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 功能完成后调用webpack提供的回调。</span></div><div class="line">    callback();</div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>了解了插件的基本架构，下面一起看下<code>UglifyJsPlugin</code>的实现，<code>UglifyJsPlugin</code>位于<code>lib/optimize/UglifyJsPlugin.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//一个JavaScript命名函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">UglifyJsPlugin</span>(<span class="params">options</span>) </span>&#123;</div><div class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> options !== <span class="string">"object"</span>) options = &#123;&#125;;</div><div class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> options.compressor !== <span class="string">"undefined"</span>) &#123;</div><div class="line">options.compress = options.compressor;</div><div class="line">&#125;</div><div class="line"><span class="keyword">this</span>.options = options;</div><div class="line">&#125;</div><div class="line"><span class="built_in">module</span>.exports = UglifyJsPlugin;</div><div class="line"></div><div class="line"><span class="comment">//在它的原型上定义一个apply方法</span></div><div class="line">UglifyJsPlugin.prototype.apply = <span class="function"><span class="keyword">function</span>(<span class="params">compiler</span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> options = <span class="keyword">this</span>.options;</div><div class="line"></div><div class="line"><span class="comment">//如果只选指定项中有关于文件后缀的就用指定项中的，否则用默认的(.js结尾)</span></div><div class="line">options.test = options.test || <span class="regexp">/\.js($|\?)/i</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> requestShortener = <span class="keyword">new</span> RequestShortener(compiler.context);</div><div class="line">compiler.plugin(<span class="string">"compilation"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">compilation</span>) </span>&#123;</div><div class="line"><span class="keyword">if</span>(options.sourceMap !== <span class="literal">false</span>) &#123;</div><div class="line">compilation.plugin(<span class="string">"build-module"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">module</span>) </span>&#123;</div><div class="line"><span class="comment">// to get detailed location info about errors</span></div><div class="line"><span class="built_in">module</span>.useSourceMap = <span class="literal">true</span>;</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 指定挂载的webpack事件钩子(optimize-chunk-assets)</span></div><div class="line"><span class="comment"> * @param  &#123;Object&#125;  chunks     被压缩的模块信息</span></div><div class="line"><span class="comment"> * @param  &#123;Object&#125;  callback webpack提供的回调</span></div><div class="line"><span class="comment"> */</span></div><div class="line">compilation.plugin(<span class="string">"optimize-chunk-assets"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunks, callback</span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> files = [];</div><div class="line"></div><div class="line"><span class="comment">//取出模块中的文件</span></div><div class="line">chunks.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</div><div class="line">chunk.files.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">file</span>) </span>&#123;</div><div class="line">files.push(file);</div><div class="line">&#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//compilation.additionalChunkAssets这个队列在lib/HotModuleReplacementPlugin.js这个文件中被加入了新元素</span></div><div class="line"><span class="comment">//也一起合并到files中去</span></div><div class="line">compilation.additionalChunkAssets.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">file</span>) </span>&#123;</div><div class="line">files.push(file);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//提取出符合options中指定的文件后缀的文件</span></div><div class="line">files = files.filter(ModuleFilenameHelpers.matchObject.bind(<span class="literal">undefined</span>, options));</div><div class="line">files.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">file</span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> oldWarnFunction = uglify.AST_Node.warn_function;</div><div class="line"><span class="keyword">var</span> warnings = [];</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line"><span class="keyword">var</span> asset = compilation.assets[file];</div><div class="line"><span class="keyword">if</span>(asset.__UglifyJsPlugin) &#123;</div><div class="line">compilation.assets[file] = asset.__UglifyJsPlugin;</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//sourceMap相关</span></div><div class="line"><span class="keyword">if</span>(options.sourceMap !== <span class="literal">false</span>) &#123;</div><div class="line"><span class="keyword">if</span>(asset.sourceAndMap) &#123;</div><div class="line"><span class="keyword">var</span> sourceAndMap = asset.sourceAndMap();</div><div class="line"><span class="keyword">var</span> inputSourceMap = sourceAndMap.map;</div><div class="line"><span class="keyword">var</span> input = sourceAndMap.source;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="keyword">var</span> inputSourceMap = asset.map();</div><div class="line"><span class="keyword">var</span> input = asset.source();</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> sourceMap = <span class="keyword">new</span> SourceMapConsumer(inputSourceMap);</div><div class="line">uglify.AST_Node.warn_function = <span class="function"><span class="keyword">function</span>(<span class="params">warning</span>) </span>&#123; <span class="comment">// eslint-disable-line camelcase</span></div><div class="line"><span class="keyword">var</span> match = <span class="regexp">/\[.+:([0-9]+),([0-9]+)\]/</span>.exec(warning);</div><div class="line"><span class="keyword">var</span> line = +match[<span class="number">1</span>];</div><div class="line"><span class="keyword">var</span> column = +match[<span class="number">2</span>];</div><div class="line"><span class="keyword">var</span> original = sourceMap.originalPositionFor(&#123;</div><div class="line">line: line,</div><div class="line">column: column</div><div class="line">&#125;);</div><div class="line"><span class="keyword">if</span>(!original || !original.source || original.source === file) <span class="keyword">return</span>;</div><div class="line">warnings.push(warning.replace(<span class="regexp">/\[.+:([0-9]+),([0-9]+)\]/</span>, <span class="string">""</span>) +</div><div class="line"><span class="string">"["</span> + requestShortener.shorten(original.source) + <span class="string">":"</span> + original.line + <span class="string">","</span> + original.column + <span class="string">"]"</span>);</div><div class="line">&#125;;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="keyword">var</span> input = asset.source();</div><div class="line">uglify.AST_Node.warn_function = <span class="function"><span class="keyword">function</span>(<span class="params">warning</span>) </span>&#123; <span class="comment">// eslint-disable-line camelcase</span></div><div class="line">warnings.push(warning);</div><div class="line">&#125;;</div><div class="line">&#125;</div><div class="line">uglify.base54.reset();</div><div class="line"><span class="keyword">var</span> ast = uglify.parse(input, &#123;</div><div class="line">filename: file</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//压缩代码并应用转换</span></div><div class="line"><span class="keyword">if</span>(options.compress !== <span class="literal">false</span>) &#123;</div><div class="line">ast.figure_out_scope();</div><div class="line"><span class="keyword">var</span> compress = uglify.Compressor(options.compress);</div><div class="line">ast = ast.transform(compress);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//在顶级作用域打乱变量名称（默认不开启）</span></div><div class="line"><span class="keyword">if</span>(options.mangle !== <span class="literal">false</span>) &#123;</div><div class="line">ast.figure_out_scope(options.mangle || &#123;&#125;);</div><div class="line">ast.compute_char_frequency(options.mangle || &#123;&#125;);</div><div class="line">ast.mangle_names(options.mangle || &#123;&#125;);</div><div class="line"><span class="keyword">if</span>(options.mangle &amp;&amp; options.mangle.props) &#123;</div><div class="line">uglify.mangle_properties(ast, options.mangle.props);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> output = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">//注释</span></div><div class="line">output.comments = <span class="built_in">Object</span>.prototype.hasOwnProperty.call(options, <span class="string">"comments"</span>) ? options.comments : <span class="regexp">/^\**!|@preserve|@license/</span>;</div><div class="line"></div><div class="line"><span class="comment">//代码美化</span></div><div class="line">output.beautify = options.beautify;</div><div class="line"></div><div class="line"><span class="comment">//把options.output下的每项提取到output</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> options.output) &#123;</div><div class="line">output[k] = options.output[k];</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>(options.sourceMap !== <span class="literal">false</span>) &#123;</div><div class="line"><span class="keyword">var</span> map = uglify.SourceMap(&#123; <span class="comment">// eslint-disable-line new-cap</span></div><div class="line">file: file,</div><div class="line">root: <span class="string">""</span></div><div class="line">&#125;);</div><div class="line">output.source_map = map; <span class="comment">// eslint-disable-line camelcase</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> stream = uglify.OutputStream(output); <span class="comment">// eslint-disable-line new-cap</span></div><div class="line">ast.print(stream);</div><div class="line"><span class="keyword">if</span>(map) map = map + <span class="string">""</span>;</div><div class="line">stream = stream + <span class="string">""</span>;</div><div class="line">asset.__UglifyJsPlugin = compilation.assets[file] = (map ?</div><div class="line"><span class="keyword">new</span> SourceMapSource(stream, file, <span class="built_in">JSON</span>.parse(map), input, inputSourceMap) :</div><div class="line"><span class="keyword">new</span> RawSource(stream));</div><div class="line"><span class="keyword">if</span>(warnings.length &gt; <span class="number">0</span>) &#123;</div><div class="line">compilation.warnings.push(<span class="keyword">new</span> <span class="built_in">Error</span>(file + <span class="string">" from UglifyJs\n"</span> + warnings.join(<span class="string">"\n"</span>)));</div><div class="line">&#125;</div><div class="line">&#125; <span class="keyword">catch</span>(err) &#123;</div><div class="line"><span class="comment">//捕获到压缩出错信息的操作</span></div><div class="line"><span class="keyword">if</span>(err.line) &#123;</div><div class="line"><span class="keyword">var</span> original = sourceMap &amp;&amp; sourceMap.originalPositionFor(&#123;</div><div class="line">line: err.line,</div><div class="line">column: err.col</div><div class="line">&#125;);</div><div class="line"><span class="keyword">if</span>(original &amp;&amp; original.source) &#123;</div><div class="line">compilation.errors.push(<span class="keyword">new</span> <span class="built_in">Error</span>(file + <span class="string">" from UglifyJs\n"</span> + err.message + <span class="string">" ["</span> + requestShortener.shorten(original.source) + <span class="string">":"</span> + original.line + <span class="string">","</span> + original.column + <span class="string">"]"</span>));</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">compilation.errors.push(<span class="keyword">new</span> <span class="built_in">Error</span>(file + <span class="string">" from UglifyJs\n"</span> + err.message + <span class="string">" ["</span> + file + <span class="string">":"</span> + err.line + <span class="string">","</span> + err.col + <span class="string">"]"</span>));</div><div class="line">&#125;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(err.msg) &#123;</div><div class="line">compilation.errors.push(<span class="keyword">new</span> <span class="built_in">Error</span>(file + <span class="string">" from UglifyJs\n"</span> + err.msg));</div><div class="line">&#125; <span class="keyword">else</span></div><div class="line">compilation.errors.push(<span class="keyword">new</span> <span class="built_in">Error</span>(file + <span class="string">" from UglifyJs\n"</span> + err.stack));</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">uglify.AST_Node.warn_function = oldWarnFunction; <span class="comment">// eslint-disable-line camelcase</span></div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//执行回调函数</span></div><div class="line">callback();</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 指定挂载的webpack事件钩子(normal-module-loader)</span></div><div class="line">compilation.plugin(<span class="string">"normal-module-loader"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</div><div class="line">context.minimize = <span class="literal">true</span>;</div><div class="line">&#125;);</div><div class="line">&#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>上面就是我对<code>UglifyJsPlugin</code>的标注，从这个插件的源码分析，我们可以基本看到 webpack 编译时的读写过程大致是怎么样的：实例化插件 –&gt; 读取源文件 –&gt; 编译并输出</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>我们在命令行里输入了<code>webpack [--xxx]</code>之后，<code>webpack</code>内部大概帮我们做了下面几件事情：</p><ul><li>首先会走到<code>bin/webpack.js</code>，解析命令行参数以及开始执行编译</li><li>在<code>bin/webpack.js</code>中调用<code>webpack</code>入口函数， 走到<code>lib/webpack.js</code></li><li>在<code>webpack</code>中实例化一个<code>Compiler</code>对象（继承<code>Tapable</code>，实现插件的注册），调用目录下的<code>lib/WebpackOptionsApply.js</code>模块</li><li>在<code>lib/WebpackOptionsApply.js</code>中根据传入的<code>options</code>和<code>compiler</code>逐个编译并应用不同插件，并且返回文件</li></ul><h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><p><a href="https://zhuanlan.zhihu.com/p/24717349" target="_blank" rel="external">[webpack]源码解读：命令行输入webpack的时候都发生了什么？</a></p><p><a href="http://www.jianshu.com/p/01a606c97d76" target="_blank" rel="external">webpack源码分析（一）— Tapable插件架构</a></p><p><a href="https://juejin.im/entry/576b7aeda633bd0064065c74" target="_blank" rel="external">webpack 源码解析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在前端工程化越来越普及的今天，我们几乎每个项目都需要用到构建工具，从一开始的&lt;code&gt;grunt&lt;/code&gt;，到&lt;code&gt;gulp&lt;/code&gt;，再到现在的&lt;code&gt;webpack&lt;/code&gt;。&lt;br&gt;我们在使用&lt;code&gt;webpack&lt;/code&gt;时，可以通过
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
      <category term="webpack，构建工具" scheme="http://yoursite.com/categories/javascript/webpack%EF%BC%8C%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>从零开始写一个React - setState和生命周期</title>
    <link href="http://yoursite.com/2017/09/14/2017-09-14-write-your-own-react-2/"/>
    <id>http://yoursite.com/2017/09/14/2017-09-14-write-your-own-react-2/</id>
    <published>2017-09-13T16:00:00.000Z</published>
    <updated>2017-09-14T09:26:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>在前面一篇中我们用<code>instantiateReactComponent</code>方法来根据<code>node</code>的不同来返回不同的组件实例，之前的分类可能有些问题，就是当该组件中<code>JSX</code>部分有返回<code>null</code>的情况，<code>instantiateReactComponent</code>就不能返回正确的组件，所以在这里加了一种新的组件类型：<code>ReactEmptyComponent</code>，作用就是返回一段空的注释，标记这是一个空组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">instantiateReactComponent</span>(<span class="params">node</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (lodash.isNull(node) || lodash.isUndefined(node)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReactEmptyComponent(<span class="literal">null</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//  ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//  空组件</span></div><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ReactEmptyComponent</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(node) &#123;</div><div class="line">        <span class="keyword">this</span>.type = <span class="string">"ReactEmptyComponent"</span>;</div><div class="line">        <span class="keyword">this</span>._currentElement = <span class="literal">null</span>;</div><div class="line">        <span class="keyword">this</span>._rootNodeID = <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     *  空组件挂载直接返回一段空注释回去</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    mountComponent(rootID) &#123;</div><div class="line">        <span class="keyword">this</span>._rootNodeID = rootID;</div><div class="line">        <span class="keyword">return</span> <span class="string">`&lt;!-- empty component data-reactid="<span class="subst">$&#123;<span class="keyword">this</span>._rootNodeID&#125;</span>" --&gt;`</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们之前简单实现了一个初始化渲染的过程，现在我们一起实现一个<code>setState</code>方法以及组件后面的更新逻辑。<code>setState</code>是在组件中被调用的，所以我们需要在之前的<code>Component</code>类中加入一个<code>setState</code>方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="comment">//...</span></div><div class="line"></div><div class="line">    setState(newState, callback) &#123;</div><div class="line">        <span class="keyword">const</span> stacks = StackTrace.getSync();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> &#123;functionName, source&#125; <span class="keyword">of</span> stacks) &#123;</div><div class="line">            <span class="keyword">if</span>(RENDER_REG.test(functionName) &amp;&amp; RENDER_REG.test(source)) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"callStack Error: you can't call setState in render method!"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>._reactInternalInstance.receiveComponent(<span class="literal">null</span>, newState);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (lodash.isFunction(callback)) &#123;</div><div class="line">            callback();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>之前一篇我们说到一共可分成文本组件，浏览器标签组件，自定义标签组件，所以我们需要在这三个组件中各实现一个<code>receiveComponent</code>来接收新组件并且实现相应更新：</p><p>对于普通的文本节点，要做的相对简单，就是在<code>receiveComponent</code>中去更新相关<code>DOM</code>的<code>textContent</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ReactDOMTextComponent</span> </span>&#123;</div><div class="line">  <span class="comment">//...</span></div><div class="line">  </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     *  接收到新组件</span></div><div class="line"><span class="comment">     *  @param   &#123;String&#125;  text  [接收到的新组件]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    receiveComponent(text) &#123;</div><div class="line">        <span class="keyword">const</span> nextStringText = (<span class="string">""</span> + text);</div><div class="line">        <span class="keyword">if</span> (nextStringText !== <span class="keyword">this</span>._currentElement) &#123;</div><div class="line">            <span class="keyword">this</span>._currentElement = nextStringText;</div><div class="line">          <span class="comment">//更新相关DOM的textContent</span></div><div class="line">            $(<span class="string">`[data-reactid='<span class="subst">$&#123;<span class="keyword">this</span>._rootNodeID&#125;</span>']`</span>).textContent = nextStringText;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在自定标签组件中，我们需要做的事情大概如下</p><ul><li>如果调用时传入了新的<code>Vnode</code>就把当前的<code>_currentElement</code>改成新传入的<code>Vnode</code></li><li>合并新老<code>state</code></li><li>调用组件实例下的<code>shouldComponentUpdate</code>根据返回的布尔值去判断是否需要更新组件</li><li>调用组件实例下的<code>componentWillUpdate</code></li><li>调用组件的<code>render</code>去拿到新的<code>Vnode</code>，和之前的做对比，如果之前的组件<code>Vnode</code>不存在，就直接调用<code>instantiateReactComponent</code>返回新的组件实例</li><li>调用组件生命周期下的<code>componentDidUpdate</code>方法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ReactCompositeComponent</span> </span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     *  接收到新组件, 更新实例下的state, 组件生命周期方法调用</span></div><div class="line"><span class="comment">     *  @param   &#123;ReactElement&#125;  nextElement  [新的Vnode]</span></div><div class="line"><span class="comment">     *  @param   &#123;Object&#125;        newState     [this.setState(state)中的state]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    receiveComponent(nextElement, newState) &#123;</div><div class="line">        <span class="comment">//  如果接受了新的, 就使用最新的element</span></div><div class="line">        <span class="keyword">this</span>._currentElement = nextElement || <span class="keyword">this</span>._currentElement;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> &#123; _rootNodeID &#125; = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">        <span class="keyword">let</span> inst = <span class="keyword">this</span>._instance,</div><div class="line"></div><div class="line">            <span class="comment">//  nextState和nextProps的处理</span></div><div class="line">            nextState = <span class="built_in">Object</span>.assign(inst.state || &#123;&#125;, newState),</div><div class="line">            nextProps = lodash.clone(<span class="keyword">this</span>._currentElement.props),</div><div class="line">            finalProps,</div><div class="line">            prevComponentInstance,</div><div class="line">            prevRenderedElement,</div><div class="line">            nextRenderedElement,</div><div class="line">            nextMarkup,</div><div class="line">            child;</div><div class="line"></div><div class="line">        <span class="comment">//  修改组件的state和props</span></div><div class="line">        <span class="keyword">this</span>._instance.state = nextState;</div><div class="line">        <span class="keyword">this</span>._instance.props = nextProps;</div><div class="line">        inst.state = nextState;</div><div class="line">        inst.props = nextProps;</div><div class="line"></div><div class="line">        <span class="comment">//  声明周期shouldComponentUpdate</span></div><div class="line">        <span class="keyword">if</span> (!inst.shouldComponentUpdate(nextProps, nextState)) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//  声明周期componentWillUpdate</span></div><div class="line">        inst.componentWillUpdate(nextProps, nextState);</div><div class="line"></div><div class="line">        <span class="comment">//  之前的组件组件实例</span></div><div class="line">        prevComponentInstance = <span class="keyword">this</span>._renderedComponent;</div><div class="line"></div><div class="line">        <span class="comment">//  之前的组件元素</span></div><div class="line">        prevRenderedElement = prevComponentInstance._currentElement;</div><div class="line"></div><div class="line">        <span class="comment">//  即将被渲染的新组件元素</span></div><div class="line">        nextRenderedElement = inst.render();</div><div class="line"></div><div class="line">        <span class="comment">//  判断是需要更新还是直接就重新渲染</span></div><div class="line">        <span class="keyword">if</span> (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) &#123;</div><div class="line">            prevComponentInstance.receiveComponent(nextRenderedElement);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//  重新new一个对应的component</span></div><div class="line">            <span class="keyword">this</span>._renderedComponent = instantiateReactComponent(nextRenderedElement);</div><div class="line"></div><div class="line">            <span class="comment">//  重新生成对应的元素内容</span></div><div class="line">            nextMarkup = <span class="keyword">this</span>._renderedComponent.mountComponent(_rootNodeID);</div><div class="line"></div><div class="line">            <span class="comment">//  替换整个节点</span></div><div class="line">            $(<span class="string">`[data-reactid="<span class="subst">$&#123;_rootNodeID&#125;</span>"]`</span>).innerHTML = nextMarkup;</div><div class="line">        &#125;</div><div class="line">        inst.componentDidUpdate();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在组件的<code>render</code>被重新调用之后，最后还是需要要更新<code>DOM</code>的，所以在<code>ReactDOMComponent</code>下的<code>receiveComponent</code>里我们需要对组件里的<code>DOM</code>下的属性和结构进行更新。</p><p>在<code>React</code>中，有一套<code>diff</code>算法来比较新老组件间的差异，返回需要更新的队列，然后统一对<code>DOM</code>结构进行更新，在<code>ReactDOMComponent</code>下的<code>receiveComponent</code>中，我们需要完成下面的几件事情</p><ul><li>拿到老的<code>props</code>和新的<code>props</code>做，在<code>_updateDOMProperties</code>中对<code>DOM</code>下的属性进行更新</li><li>调用<code>_updateDOMChildren</code>，传入新的组件子节点，去拼凑差异队列，然后更新<code>DOM</code></li><li>修改<code>currentElement</code>变成本次渲染的，供下次使用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ReactDOMComponent</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     *  接收到新组件</span></div><div class="line"><span class="comment">     *  @param   &#123;Object&#125;  nextElement  [新组件]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    receiveComponent(nextElement) &#123;</div><div class="line">        <span class="keyword">const</span> lastProps = lodash.clone(<span class="keyword">this</span>._currentElement.props),</div><div class="line">            nextProps = nextElement.props;</div><div class="line"></div><div class="line">        <span class="comment">//  需要单独的更新属性</span></div><div class="line">        <span class="keyword">this</span>._updateDOMProperties(lastProps, nextProps);</div><div class="line"></div><div class="line">        <span class="comment">//  再更新子节点</span></div><div class="line">        <span class="keyword">this</span>._updateDOMChildren(nextElement.props.children);</div><div class="line"></div><div class="line">        <span class="comment">//  修改currentElement变成本次渲染的</span></div><div class="line">        <span class="keyword">this</span>._currentElement = nextElement;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     *  更新组件中相关DOM的属性</span></div><div class="line"><span class="comment">     *  @param    &#123;Object&#125;  lastProps  [旧属性]</span></div><div class="line"><span class="comment">     *  @param    &#123;Object&#125;  nextProps  [新属性]</span></div><div class="line"><span class="comment">     *  @private</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    _updateDOMProperties(lastProps, nextProps) &#123;</div><div class="line">        <span class="keyword">const</span> &#123; _rootNodeID &#125; = <span class="keyword">this</span>,</div><div class="line">        element = $(<span class="string">`[data-reactid="<span class="subst">$&#123;_rootNodeID&#125;</span>"]`</span>);</div><div class="line">        <span class="keyword">let</span> propKey, propValue, eventType, removed;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (propKey <span class="keyword">in</span> lastProps) &#123;</div><div class="line">            <span class="comment">//  只删除老属性中有但是新属性中没有的</span></div><div class="line">            <span class="keyword">if</span> (hasOwnProperty(lastProps, propKey) &amp;&amp; !hasOwnProperty(nextProps, propKey)) &#123;</div><div class="line">                propValue = lastProps[propKey];</div><div class="line"></div><div class="line">                <span class="comment">//  之前的事件代理需要解除</span></div><div class="line">                <span class="keyword">if</span> (EVENT_REG.test(propKey)) &#123;</div><div class="line">                    eventType = propKey.replace(<span class="string">"on"</span>, <span class="string">""</span>);</div><div class="line">                    Event.undelegate(&#123;</div><div class="line">                        element: doc,</div><div class="line">                        type: eventType,</div><div class="line">                        selector: <span class="string">`[data-reactid="<span class="subst">$&#123;_rootNodeID&#125;</span>"]`</span></div><div class="line">                    &#125;);</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === <span class="string">"className"</span>) &#123;</div><div class="line">                    removed = <span class="string">"class"</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    removed = propKey;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">//  删除DOM上的相关属性</span></div><div class="line">                element.removeAttribute(removed);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//  开始遍历新属性集合</span></div><div class="line">        <span class="keyword">for</span> (propKey <span class="keyword">in</span> nextProps) &#123;</div><div class="line">            <span class="keyword">if</span> (hasOwnProperty(nextProps, propKey) &amp;&amp; propKey !== <span class="string">"children"</span>) &#123;</div><div class="line">                propValue = lastProps[propKey];</div><div class="line">              <span class="comment">//重新代理事件</span></div><div class="line">                <span class="keyword">if</span> (EVENT_REG.test(propKey)) &#123;</div><div class="line">                    eventType = propKey.replace(<span class="string">"on"</span>, <span class="string">""</span>);</div><div class="line">                    Event.undelegate(&#123;</div><div class="line">                        element: doc,</div><div class="line">                        type: eventType,</div><div class="line">                        selector: <span class="string">`[data-reactid="<span class="subst">$&#123;_rootNodeID&#125;</span>"]`</span></div><div class="line">                    &#125;);</div><div class="line">                    Event.delegate(&#123;</div><div class="line">                        element: doc,</div><div class="line">                        type: eventType,</div><div class="line">                        selector: <span class="string">`[data-reactid="<span class="subst">$&#123;_rootNodeID&#125;</span>"]`</span>,</div><div class="line">                        handler: propValue,</div><div class="line">                        context: <span class="literal">null</span></div><div class="line">                    &#125;);</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === <span class="string">"className"</span>) &#123;</div><div class="line">                    element.setAttribute(<span class="string">"class"</span>, propValue);</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === <span class="string">"style"</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (lodash.isObject(propValue)) &#123;</div><div class="line">                        propValue = toStyle.string(propValue);</div><div class="line">                    &#125;</div><div class="line">                    element.setAttribute(propKey, propValue);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    element.setAttribute(propKey, propValue);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     *  更新子元素</span></div><div class="line"><span class="comment">     *  @param    &#123;Array&#125;  nextChildrenElements  [被更新的组件队列]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    _updateDOMChildren(nextChildrenElements) &#123;</div><div class="line">        <span class="keyword">if</span> (nextChildrenElements &amp;&amp; nextChildrenElements.length) &#123;</div><div class="line"></div><div class="line">            update.updateDepth++;</div><div class="line">            <span class="comment">//  递归找出差别, 组装差异对象</span></div><div class="line">            update.diff(update.diffQueue, nextChildrenElements, <span class="keyword">this</span>);</div><div class="line">            update.updateDepth--;</div><div class="line"></div><div class="line">            <span class="comment">//  应用更新</span></div><div class="line">            <span class="keyword">if</span> (update.updateDepth === <span class="number">0</span>) &#123;</div><div class="line">                update.patch(update.diffQueue);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在<code>_updateDOMChildren</code>中我们调用了<code>update.diff</code>和<code>update.patch</code>方法，一个对比一个应用，这里我是把<code>diff</code>和<code>patch</code>放到一个对象下作为一个模块暴露出去的，下面就是具体的实现代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义更新类型(移动已经存在的，删除节点，插入的新标签)</span></div><div class="line"><span class="keyword">const</span> UPDATE_TYPES = &#123;</div><div class="line">    MOVE_EXISTING: <span class="number">1</span>,</div><div class="line">    REMOVE_NODE: <span class="number">2</span>,</div><div class="line">    INSERT_MARKUP: <span class="number">3</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> update = &#123;</div><div class="line">    <span class="comment">//  更新深度标识</span></div><div class="line">    updateDepth: <span class="number">0</span>,</div><div class="line"></div><div class="line">    <span class="comment">//  更新队列</span></div><div class="line">    diffQueue: [],</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     *  递归找出差别, 组装差异对象, 添加到更新队列diffQueue</span></div><div class="line"><span class="comment">     *  @param   &#123;Array&#125;  diffQueue             [更新队列]</span></div><div class="line"><span class="comment">     *  @param   &#123;Array&#125;  nextChildrenElements  [新的子组件集合]</span></div><div class="line"><span class="comment">     *  @param   &#123;Object&#125; component             [被diff的组件]</span></div><div class="line"><span class="comment">     *  @return  &#123;Array&#125;                        [需要更新的内容]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    diff(diffQueue, nextChildrenElements, component) &#123;</div><div class="line">        <span class="comment">//  获取到当前组件下已经渲染的组件集合，把component._renderedChildren扁平成一个对象，如果child有key，就拿key作为对应的属性名，否则用下标做属性名，具体实现可以看下面</span></div><div class="line">        <span class="keyword">const</span> prevChildren = flattenChildren(component._renderedChildren),</div><div class="line"></div><div class="line">            <span class="comment">//  生成新的子节点的component对象集合(如果是组件有更新, 就复用原来的, 如果是新增就是新的组件实例)</span></div><div class="line">            nextChildren = generateComponentChildren(prevChildren, nextChildrenElements);</div><div class="line"></div><div class="line">        <span class="keyword">let</span> lastIndex = <span class="number">0</span>,</div><div class="line">            nextIndex = <span class="number">0</span>,</div><div class="line">            prevChild = <span class="literal">null</span>,</div><div class="line">            nextChild = <span class="literal">null</span>,</div><div class="line">            name, props, propKey, eventType;</div><div class="line"></div><div class="line">        <span class="comment">//  枚举nextChildren</span></div><div class="line">        <span class="keyword">for</span> (name <span class="keyword">in</span> nextChildren) &#123;</div><div class="line">            <span class="keyword">if</span> (!hasOwnProperty(nextChildren, name)) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            prevChild = prevChildren &amp;&amp; prevChildren[name];</div><div class="line">            nextChild = nextChildren[name];</div><div class="line"></div><div class="line">            <span class="comment">//  两个相同说明是使用的同一个component,所以我们需要做移动的操作</span></div><div class="line">            <span class="keyword">if</span> (lodash.isEqual(prevChild, nextChild)) &#123;</div><div class="line">                <span class="keyword">if</span> (prevChild._mountIndex &lt; lastIndex) &#123;</div><div class="line">                    <span class="keyword">this</span>.diffQueue.push(&#123;</div><div class="line">                        parentId: component._rootNodeID,</div><div class="line">                        parentNode: $(<span class="string">`[data-reactid="<span class="subst">$&#123;component._rootNodeID&#125;</span>"]`</span>),</div><div class="line">                        type: UPDATE_TYPES.MOVE_EXISTING,</div><div class="line">                      <span class="comment">//从组件原来的mountIndex</span></div><div class="line">                        fromIndex: prevChild._mountIndex,</div><div class="line">                      <span class="comment">//到nextIndex</span></div><div class="line">                        toIndex: nextIndex</div><div class="line">                    &#125;);</div><div class="line">                &#125;</div><div class="line">              </div><div class="line">              <span class="comment">//缓存上次遍历时最大的index</span></div><div class="line">                lastIndex = <span class="built_in">Math</span>.max(prevChild._mountIndex, lastIndex);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//  之前存在子节点, 需要先将子节点移除</span></div><div class="line">                <span class="keyword">if</span> (prevChild) &#123;</div><div class="line">                    <span class="keyword">this</span>.diffQueue.push(&#123;</div><div class="line">                        parentId: component._rootNodeID,</div><div class="line">                        parentNode: $(<span class="string">`[data-reactid="<span class="subst">$&#123;component._rootNodeID&#125;</span>"]`</span>),</div><div class="line">                        type: UPDATE_TYPES.REMOVE_NODE,</div><div class="line">                        fromIndex: prevChild._mountIndex,</div><div class="line">                        toIndex: <span class="literal">null</span></div><div class="line">                    &#125;);</div><div class="line">                    lastIndex = <span class="built_in">Math</span>.max(prevChild._mountIndex, lastIndex);</div><div class="line"></div><div class="line">                    props = (prevChild._currentElement &amp;&amp; prevChild._currentElement.props) ? prevChild._currentElement.props : &#123;&#125;;</div><div class="line"></div><div class="line">                  <span class="comment">//对移除的子节点需要进行事件代理的接触，防止重复</span></div><div class="line">                    <span class="keyword">for</span> (propKey <span class="keyword">in</span> props) &#123;</div><div class="line">                        <span class="keyword">if</span> (hasOwnProperty(props, propKey) &amp;&amp; EVENT_REG.test(propKey)) &#123;</div><div class="line">                            eventType = propKey.replace(<span class="string">"on"</span>, <span class="string">""</span>);</div><div class="line">                            Event.undelegate(&#123;</div><div class="line">                                element: doc,</div><div class="line">                                type: eventType,</div><div class="line">                                selector: <span class="string">`[data-reactid="<span class="subst">$&#123;prevChild._rootNodeID&#125;</span>"]`</span></div><div class="line">                            &#125;);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">//  新增的节点, 需要push到diffQueue</span></div><div class="line">                <span class="keyword">if</span> (nextChild) &#123;</div><div class="line">                    <span class="keyword">this</span>.diffQueue.push(&#123;</div><div class="line">                        parentId: component._rootNodeID,</div><div class="line">                        parentNode: $(<span class="string">`[data-reactid="<span class="subst">$&#123;component._rootNodeID&#125;</span>"]`</span>),</div><div class="line">                        type: UPDATE_TYPES.INSERT_MARKUP,</div><div class="line">                        fromIndex: <span class="literal">null</span>,</div><div class="line">                        toIndex: nextIndex,</div><div class="line">                        markup: nextChild.mountComponent(<span class="string">`<span class="subst">$&#123;component._rootNodeID&#125;</span>.<span class="subst">$&#123;name&#125;</span>`</span>)</div><div class="line">                    &#125;);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//  更新_mountIndex和nextIndex</span></div><div class="line">            nextChild._mountIndex = nextIndex;</div><div class="line">            nextIndex++;</div><div class="line"></div><div class="line">            <span class="comment">//  把nextChildren克隆一份给_renderedChildren</span></div><div class="line">            component._renderedChildren = makeArray(nextChildren);</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     *  应用更新, 执行DOM操作</span></div><div class="line"><span class="comment">     *  @param   &#123;Array&#125;  updates  [差异对象集合]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    patch(updates) &#123;</div><div class="line">        <span class="keyword">let</span> initialChildren = &#123;&#125;,</div><div class="line">            deleteChildren = [],</div><div class="line">            updatedIndex, updatedChild, parentID;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> update <span class="keyword">of</span> updates) &#123;</div><div class="line">            updatedIndex = update.fromIndex;</div><div class="line">            updatedChild = update.parentNode.children[updatedIndex];</div><div class="line">            parentID = update.parentID;</div><div class="line"></div><div class="line">            <span class="comment">//  把所有需要更新的节点都保存下来</span></div><div class="line">            initialChildren[parentID] = initialChildren[parentID] || [];</div><div class="line"></div><div class="line">            <span class="comment">//  使用parentID作为简易命名空间</span></div><div class="line">            initialChildren[parentID][updatedIndex] = updatedChild;</div><div class="line"></div><div class="line">            <span class="comment">//  所有需要修改的节点先删除,对于move的,后面再重新插入到正确的位置即可</span></div><div class="line">            <span class="keyword">if</span> (!lodash.isNull(updatedChild) &amp;&amp; !lodash.isUndefined(updatedChild)) &#123;</div><div class="line">                deleteChildren.push(updatedChild);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//  删除需要删除的节点</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> child <span class="keyword">of</span> deleteChildren) &#123;</div><div class="line">            child.parentNode.removeChild(child);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> updateItem <span class="keyword">of</span> updates) &#123;</div><div class="line">            <span class="keyword">switch</span> (updateItem.type) &#123;</div><div class="line">                <span class="comment">//  插入新元素</span></div><div class="line">                <span class="keyword">case</span> UPDATE_TYPES.INSERT_MARKUP:</div><div class="line">                    insertChildAt(updateItem.parentNode, updateItem.markup, updateItem.toIndex);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line"></div><div class="line">                    <span class="comment">//  元素位置发生改变    </span></div><div class="line">                <span class="keyword">case</span> UPDATE_TYPES.MOVE_EXISTING:</div><div class="line">                    insertChildAt(updateItem.parentNode, initialChildren[updateItem.parentID][updateItem.fromIndex], updateItem.toIndex);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line"></div><div class="line">                    <span class="comment">//  上面已经删除, 所以不需要处理</span></div><div class="line">                <span class="keyword">case</span> UPDATE_TYPES.REMOVE_NODE:</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line"></div><div class="line">                <span class="keyword">default</span>:</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//  重置相关变量</span></div><div class="line">        <span class="keyword">this</span>.reset();</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     *  重置相关变量</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    reset() &#123;</div><div class="line">        <span class="keyword">this</span>.updateDepth = <span class="number">0</span>;</div><div class="line">        <span class="keyword">this</span>.diffQueue = [];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>在<code>diff</code>中，我们看到了两个新方法，分别是<code>flattenChildren</code>和<code>generateComponentChildren</code>，我们先看下<code>flattenChildren</code>的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> *  把原来是数组的子组件集合转换成Map返回</span></div><div class="line"><span class="comment"> *  @param   &#123;Array&#125;  componentChildren     [子组件集合]</span></div><div class="line"><span class="comment"> *  @return  &#123;Object&#125;                       [输出的Map, 每个子组件的key或者一个随机数做key]</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">flattenChildren</span>(<span class="params">componentChildren</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> childrenMap = &#123;&#125;,</div><div class="line">        child, name, i, len;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, len = componentChildren.length; i &lt; len; i++) &#123;</div><div class="line">        child = componentChildren[i];</div><div class="line">        name = child &amp;&amp; child._currentelement &amp;&amp; child._currentelement.key ? child._currentelement.key : i.toString(<span class="number">36</span>);</div><div class="line">        childrenMap[name] = child;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> childrenMap;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在<code>generateComponentChildren</code>我们大概需要完成下面几件事情：</p><ul><li>遍历拿到即将渲染的新组件<code>children</code>（做参数 <code>nextChildrenElements</code>传入）和老节点进行对比</li><li>如果老节点存在且和新节点有差异，即调用老节点下的<code>receiveComponent</code>去更新</li><li>否则如果老节点不存在，则重新调用<code>instantiateReactComponent</code>返回一个组件实例</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> *  生成子节点elements的component集合</span></div><div class="line"><span class="comment"> *  @param   &#123;Object&#125;  prevChildren          [flattenChildren返回的Map]</span></div><div class="line"><span class="comment"> *  @param   &#123;Array&#125;   nextChildrenElements  [即将要渲染的节点]</span></div><div class="line"><span class="comment"> *  @return  &#123;Object&#125;                        [子节点elements的component集合]</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateComponentChildren</span>(<span class="params">prevChildren, nextChildrenElements</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> nextChildren = &#123;&#125;,</div><div class="line">        index, len, name, prevChild, prevElement, nextElement, nextChildInstance, element;</div><div class="line">    nextChildrenElements = nextChildrenElements || [];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>, len = nextChildrenElements.length; index &lt; len; index++) &#123;</div><div class="line">        element = nextChildrenElements[index];</div><div class="line">        name = (element &amp;&amp; element.key) ? element.key : index;</div><div class="line">        prevChild = prevChildren &amp;&amp; prevChildren[name];</div><div class="line">        prevElement = prevChild &amp;&amp; prevChild._currentElement;</div><div class="line">        nextElement = element;</div><div class="line"></div><div class="line">        <span class="comment">//  组件有更新, 调用当前组件下的reciveComponent去更新组件</span></div><div class="line">        <span class="keyword">if</span> (shouldUpdateReactComponent(prevElement, nextElement)) &#123;</div><div class="line">            prevChild.receiveComponent(nextElement);</div><div class="line">            nextChildren[name] = prevChild;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//  新节点, 实例化新组件</span></div><div class="line">            nextChildInstance = instantiateReactComponent(nextElement);</div><div class="line">            nextChildren[name] = nextChildInstance;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> nextChildren;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在之前好几个地方我们都看到了<code>shouldUpdateReactComponent</code>这个方法，它完成的功能主要是判断两个<code>Vnode</code>之前是否有差异，返回布尔值，主要完成下面几件事情：</p><ul><li>如果新老<code>Vnode</code>有一个或者都为空，直接返回<code>false</code></li><li>文本节点之间的对比</li><li>当新的<code>Vnode</code>的<code>type</code>是<code>object</code>，比较老节点的<code>type</code>和<code>key</code>，并且拿到两者的<code>children</code>数组，做一个简单的长度对比</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> *  判断组件是否需要更新</span></div><div class="line"><span class="comment"> *  @param   &#123;Object&#125;  prevElement  [老的vnode]</span></div><div class="line"><span class="comment"> *  @param   &#123;Object&#125;  nextElement  [新的vnode]</span></div><div class="line"><span class="comment"> *  @return  &#123;Boolean&#125;              [标识组件是否需要更新]</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">shouldUpdateReactComponent</span>(<span class="params">prevElement, nextElement</span>) </span>&#123;</div><div class="line">    <span class="comment">//  排除为空的情况</span></div><div class="line">    <span class="keyword">if</span> (!lodash.isNull(prevElement) &amp;&amp; !lodash.isNull(nextElement) &amp;&amp; !lodash.isUndefined(prevElement) &amp;&amp; !lodash.isUndefined(nextElement)) &#123;</div><div class="line">        <span class="keyword">const</span> prevType = <span class="keyword">typeof</span> prevElement,</div><div class="line">            nextType = <span class="keyword">typeof</span> nextElement;</div><div class="line"></div><div class="line">        <span class="comment">//  纯文本组件</span></div><div class="line">        <span class="keyword">if</span> (prevType === <span class="string">"number"</span> || prevType === <span class="string">"string"</span>) &#123;</div><div class="line">            <span class="keyword">return</span> (nextType === <span class="string">"number"</span> || nextType === <span class="string">"number"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">let</span> prevChildren = [],</div><div class="line">                nextChildren = [],</div><div class="line">                childEqual = <span class="literal">true</span>;</div><div class="line"></div><div class="line">            <span class="keyword">if</span>(prevElement &amp;&amp; prevElement.props) &#123;</div><div class="line">                prevChildren = prevElement.props.children || [];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (nextElement &amp;&amp; nextElement.props) &#123;</div><div class="line">                nextChildren = nextElement.props.children || [];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            childEqual = prevChildren.length === nextChildren.length;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> (nextType === <span class="string">"object"</span> &amp;&amp;</div><div class="line">                (prevElement.type === nextElement.type) &amp;&amp;</div><div class="line">                (prevElement.key === nextElement.key) &amp;&amp;</div><div class="line">                childEqual);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>到这里我们就实现一个<code>setState</code>和生命周期，在例子中实现了一个<code>Todo</code>，一起看下效果</p><p><img src="/imgs/todo.gif" alt="todo"></p><p>至此我们就实现了一个简单的<code>React</code>，但是仅仅实现了<code>虚拟节点</code>，<code>差异算法</code>，<code>props单向数据流</code>，还有很多更优秀的没实现，比如批量更新，事件优化，组件中的<code>refs</code>，服务端渲染等等，只是一个玩具，对于想深入了解<code>React</code>原理的可能会有些帮助。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在前面一篇中我们用&lt;code&gt;instantiateReactComponent&lt;/code&gt;方法来根据&lt;code&gt;node&lt;/code&gt;的不同来返回不同的组件实例，之前的分类可能有些问题，就是当该组件中&lt;code&gt;JSX&lt;/code&gt;部分有返回&lt;code&gt;null&lt;/co
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
      <category term="React" scheme="http://yoursite.com/categories/javascript/React/"/>
    
    
  </entry>
  
  <entry>
    <title>从零开始写一个React - 初始化渲染</title>
    <link href="http://yoursite.com/2017/09/04/2017-09-04-write-your-own-react-1/"/>
    <id>http://yoursite.com/2017/09/04/2017-09-04-write-your-own-react-1/</id>
    <published>2017-09-03T16:00:00.000Z</published>
    <updated>2017-09-07T04:26:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道<code>React</code>组件返回的是<code>JSX</code>，而<code>JSX</code>将被<code>babel</code>转换，在<code>React</code>中是将<code>JSX</code>中转换成<code>React.createElement(type, config, children)</code>的形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"app-container"</span>&gt;</span>App Component<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//babel转换后输出的代码</span></div><div class="line"><span class="keyword">var</span> App = React.createClass(&#123;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span> React.createElement(<span class="string">"div"</span>, &#123;</div><div class="line">          className: <span class="string">"app-container"</span></div><div class="line">        &#125;, <span class="string">"App Component"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>我们可以在<code>babel</code>中把<code>JSX</code>的<code>pragma</code>转换改成自己的函数名:</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"presets"</span>: [</div><div class="line">    <span class="string">"es2015"</span></div><div class="line">  ],</div><div class="line">  <span class="attr">"plugins"</span>: [</div><div class="line">    [<span class="string">"transform-react-jsx"</span>, &#123;</div><div class="line">      "pragma":  "createElement"//默认的是React.createElement, 这里我们还是用默认的</div><div class="line">    &#125;]</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下面一起看看<code>createElement</code>的实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> uselessProp = [<span class="string">"key"</span>, <span class="string">"ref"</span>, <span class="string">"__self"</span>, <span class="string">"__source"</span>]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, config, ...children</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> props = &#123;&#125;,</div><div class="line">        key = <span class="literal">null</span>,</div><div class="line">        ref = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">if</span> (config != <span class="literal">null</span>) &#123;</div><div class="line">        ref = lodash.isUndefined(config.ref) ? <span class="literal">null</span> : config.ref;</div><div class="line">        key = lodash.isUndefined(config.key) ? <span class="literal">null</span> : <span class="string">""</span> + config.key;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> propsName <span class="keyword">in</span> config) &#123;</div><div class="line">            <span class="keyword">if</span> (uselessProp.indexOf(propsName) === <span class="number">-1</span> &amp;&amp; hasOwnProperty(config, propsName)) &#123;</div><div class="line">                props[propsName] = config[propsName];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//  子组件</span></div><div class="line">        props.children = children;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReactElement(type, key, props, ref);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里<code>createElement</code>就是对参数进行处理，返回一个ReactElement(<code>virtual-dom</code>)，<code>ReactElement</code>返回一个<code>vnode</code>来表示一个节点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReactElement</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(type, key, props, ref) &#123;</div><div class="line">        <span class="keyword">this</span>.type = type;</div><div class="line">        <span class="keyword">this</span>.key = key;</div><div class="line">        <span class="keyword">this</span>.props = props || &#123;&#125;;</div><div class="line">        <span class="keyword">this</span>.ref = ref || &#123;&#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在返回的<code>vnode</code>中，<code>type</code>用来标识组件类型，<code>props</code>就是组件中标签上的<code>attributes</code>，<code>key</code>用作这个<code>vnode</code>的唯一标识，可用于后面的更新，现在有了<code>vnode</code>，就需要将<code>vnode</code>转换成真实的<code>DOM</code>挂载到页面上，在<code>React</code>启动的时候，是通过<code>ReactDOM.render</code>来进行渲染组件到页面，渲染就是一个递归调用<code>render</code>的过程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">componnet, container, callback = noop</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> componentInstance = instantiateReactComponent(componnet),</div><div class="line">        markup = componentInstance.mountComponent(React.nextReactRootIndex ++);</div><div class="line">    container.innerHTML = markup;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (lodash.isFunction(callback)) &#123;</div><div class="line">        callback.call(componentInstance);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在<code>render</code>中我们调用了一个<code>instantiateReactComponent</code>，这个函数的作用是根据<code>vnode</code>里面<code>type</code>的不同来返回不同的组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">instantiateReactComponent</span>(<span class="params">node</span>) </span>&#123;</div><div class="line">    <span class="comment">//  文本节点的情况</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> node === <span class="string">"string"</span> || <span class="keyword">typeof</span> node === <span class="string">"number"</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReactDOMTextComponent(node);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//  浏览器默认节点的情况</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> node === <span class="string">"object"</span> &amp;&amp; <span class="keyword">typeof</span> node.type === <span class="string">"string"</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReactDOMComponent(node);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//  自定义的元素节点</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> node === <span class="string">"object"</span> &amp;&amp; <span class="keyword">typeof</span> node.type === <span class="string">"function"</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReactCompositeComponent(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其中，<code>ReactDOMTextComponent</code>是纯文本组件，<code>ReactDOMComponent</code>是浏览器标签组件，<code>ReactCompositeComponent</code>是自定义的组件，后面的两种组件类型都属于<code>virtual-dom</code>。</p><p>我们接下来看看上面三个组件的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  文本组件</span></div><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ReactDOMTextComponent</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(text) &#123;</div><div class="line">        <span class="comment">//  存下当前的字符串</span></div><div class="line">        <span class="keyword">this</span>._currentElement =  (<span class="string">""</span> + text);</div><div class="line">        <span class="comment">//  组件唯一id</span></div><div class="line">        <span class="keyword">this</span>._rootNodeID = <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     *  component渲染时生成的dom结构</span></div><div class="line"><span class="comment">     *  @param   &#123;String&#125;  rootID  [组件唯一id]</span></div><div class="line"><span class="comment">     *  @return  &#123;String&#125;          [HTML字符串]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    mountComponent(rootID) &#123;</div><div class="line">        <span class="keyword">this</span>._rootNodeID = rootID;</div><div class="line"><span class="keyword">return</span> <span class="string">`&lt;!-- react-text: <span class="subst">$&#123;<span class="keyword">this</span>._rootNodeID&#125;</span> --&gt;<span class="subst">$&#123;<span class="keyword">this</span>._currentElement&#125;</span>&lt;!-- /react-text --&gt;`</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//浏览器标签组件</span></div><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ReactDOMComponent</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(element) &#123;</div><div class="line">        <span class="comment">//  存下当前元素引用</span></div><div class="line">        <span class="keyword">this</span>._currentElement = element;</div><div class="line">        <span class="comment">//  组件唯一id</span></div><div class="line">        <span class="keyword">this</span>._rootNodeID = <span class="literal">null</span>;</div><div class="line">        <span class="comment">//  子组件集合</span></div><div class="line">        <span class="keyword">this</span>._renderedChildren = <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     *  component渲染时生成的dom结构</span></div><div class="line"><span class="comment">     *  @param   &#123;String&#125;  rootID  [组件唯一id]</span></div><div class="line"><span class="comment">     *  @return  &#123;String&#125;          [HTML字符串]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    mountComponent(rootID) &#123;</div><div class="line">        <span class="keyword">this</span>._rootNodeID = rootID;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> &#123; props, type &#125; = <span class="keyword">this</span>._currentElement,</div><div class="line">            &#123; children &#125; = props,</div><div class="line">            </div><div class="line"><span class="comment">//判断是否为单标签</span></div><div class="line">            isSingleTag = SINGLE_TAG_REG.test(type);</div><div class="line">        <span class="keyword">let</span> tagOpen,</div><div class="line">            tagClose,</div><div class="line">            propKey, </div><div class="line">            propValue, </div><div class="line">            eventType,</div><div class="line">            childrenInstances, </div><div class="line">            childComponentInstance, </div><div class="line">            childrenMarkups, </div><div class="line">            curRootId;</div><div class="line"></div><div class="line">        tagOpen = [];</div><div class="line">        tagOpen.push(<span class="string">`&lt;<span class="subst">$&#123;type&#125;</span>`</span>, <span class="string">`data-reactid="<span class="subst">$&#123;<span class="keyword">this</span>._rootNodeID&#125;</span>"`</span>);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (propKey <span class="keyword">in</span> props) &#123;</div><div class="line">          </div><div class="line">          <span class="comment">//过滤掉propKey为"children"的情况</span></div><div class="line">            <span class="keyword">if</span> (hasOwnProperty(props, propKey) &amp;&amp; propKey !== <span class="string">"children"</span>) &#123;</div><div class="line"></div><div class="line">                propValue = props[propKey];</div><div class="line">                <span class="keyword">if</span> (<span class="regexp">/^on[a-z]+/i</span>.test(propKey)) &#123;</div><div class="line">                    <span class="comment">/**</span></div><div class="line"><span class="comment">                     *  handleClick() &#123;</span></div><div class="line"><span class="comment">                     *      alert("clicked");</span></div><div class="line"><span class="comment">                     *  &#125;</span></div><div class="line"><span class="comment">                     *  </span></div><div class="line"><span class="comment">                     *  render() &#123;</span></div><div class="line"><span class="comment">                     *      return (</span></div><div class="line"><span class="comment">                     *          &lt;div onClick=&#123;this.handleClick&#125;&gt;click me&lt;/div&gt;</span></div><div class="line"><span class="comment">                     *      );</span></div><div class="line"><span class="comment">                     *  &#125;</span></div><div class="line"><span class="comment">                     */</span></div><div class="line">                  </div><div class="line">                  <span class="comment">//取得事件名称并进行事件代理</span></div><div class="line">                    eventType = propKey.replace(<span class="string">"on"</span>, <span class="string">""</span>).toLowerCase();</div><div class="line">                    Event.delegate(&#123;</div><div class="line">                        element: doc,</div><div class="line">                        type: eventType,</div><div class="line">                        selector: <span class="string">`[data-reactid="<span class="subst">$&#123;<span class="keyword">this</span>._rootNodeID&#125;</span>"]`</span>,</div><div class="line">                        handler: propValue,</div><div class="line">                        context: <span class="literal">null</span></div><div class="line">                    &#125;);</div><div class="line"></div><div class="line">                    <span class="comment">//  <span class="doctag">TODO:</span> 实现对当前元素进行事件代理</span></div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === <span class="string">"style"</span>) &#123;</div><div class="line"></div><div class="line">                    <span class="comment">/**</span></div><div class="line"><span class="comment">                     *  render() &#123;</span></div><div class="line"><span class="comment">                     *      return (</span></div><div class="line"><span class="comment">                     *          &lt;div style=&#123;"background: red;"&#125;&gt;&lt;/div&gt;</span></div><div class="line"><span class="comment">                     *      );</span></div><div class="line"><span class="comment">                     *  &#125;</span></div><div class="line"><span class="comment">                     *</span></div><div class="line"><span class="comment">                     *  -----------------------</span></div><div class="line"><span class="comment">                     *</span></div><div class="line"><span class="comment">                     *  render() &#123;</span></div><div class="line"><span class="comment">                     *      return (</span></div><div class="line"><span class="comment">                     *          &lt;div style=&#123;&#123;background: 'red'&#125;&#125;&gt;</span></div><div class="line"><span class="comment">                     *          &lt;/div&gt;</span></div><div class="line"><span class="comment">                     *      );</span></div><div class="line"><span class="comment">                     *  &#125;</span></div><div class="line"><span class="comment">                     */</span></div><div class="line">                    <span class="keyword">if</span> (lodash.isObject(propValue)) &#123;</div><div class="line">                      </div><div class="line"><span class="comment">//这里的toStyle用了一个npm包(https://www.npmjs.com/package/to-style)</span></div><div class="line">                        propValue = toStyle.string(propValue);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    tagOpen.push(<span class="string">`style="<span class="subst">$&#123;propValue&#125;</span>"`</span>);</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propValue === <span class="string">"className"</span>) &#123;</div><div class="line">                    tagOpen.push(<span class="string">`class="<span class="subst">$&#123;propValue&#125;</span>"`</span>);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    tagOpen.push(<span class="string">`<span class="subst">$&#123;propKey&#125;</span>="<span class="subst">$&#123;propValue&#125;</span>"`</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (isSingleTag) &#123;</div><div class="line">            tagOpen.push(<span class="string">"/&gt;"</span>);</div><div class="line">            tagClose = <span class="string">""</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            tagOpen.push(<span class="string">"&gt;"</span>);</div><div class="line">            tagClose = <span class="string">`&lt;/<span class="subst">$&#123;type&#125;</span>&gt;`</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        childrenMarkups = [];</div><div class="line">        childrenInstances = [];</div><div class="line">      </div><div class="line">      <span class="comment">//遍历子节点，实例化-&gt;渲染子节点</span></div><div class="line">        <span class="keyword">if</span> (children &amp;&amp; children.length) &#123;</div><div class="line">            children.forEach(<span class="function">(<span class="params">child, key</span>) =&gt;</span> &#123;</div><div class="line">                childComponentInstance = instantiateReactComponent(child);</div><div class="line">                childrenInstances.push(childComponentInstance);</div><div class="line">                childComponentInstance._mountIndex = key;</div><div class="line">              </div><div class="line">              <span class="comment">//拼一个类似于"x.y"的子节点的nodeId</span></div><div class="line">                curRootId = <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>._rootNodeID&#125;</span>.<span class="subst">$&#123;key&#125;</span>`</span>;</div><div class="line">                childrenMarkups.push(childComponentInstance.mountComponent.call(childComponentInstance, curRootId));</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">      <span class="comment">//将子组件的集合保留起来，留作后面更新使用</span></div><div class="line">        <span class="keyword">this</span>._renderedChildren = childrenInstances;</div><div class="line">      </div><div class="line">      <span class="comment">//返回组件的真实HTML结构</span></div><div class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;tagOpen.join(<span class="string">" "</span>)&#125;</span> <span class="subst">$&#123;childrenMarkups.join(<span class="string">" "</span>)&#125;</span> <span class="subst">$&#123;tagClose&#125;</span>`</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//React自定义组件</span></div><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ReactCompositeComponent</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(element) &#123;</div><div class="line">        <span class="comment">//  存放元素element对象</span></div><div class="line">        <span class="keyword">this</span>._currentElement = element;</div><div class="line">        <span class="comment">//  存放唯一标识</span></div><div class="line">        <span class="keyword">this</span>._rootNodeID = <span class="literal">null</span>;</div><div class="line">        <span class="comment">//  存放对应的ReactClass的实例</span></div><div class="line">        <span class="keyword">this</span>._instance = <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mountComponent(rootID, hostContainerInfo, context) &#123;</div><div class="line">        <span class="keyword">this</span>._rootNodeID = rootID;</div><div class="line">        <span class="keyword">const</span> &#123; props, type &#125; = <span class="keyword">this</span>._currentElement,</div><div class="line">            ReactClass = type,</div><div class="line">            <span class="comment">//根据vnode中的type来实例化</span></div><div class="line">            <span class="comment">//在instantiateReactComponent中可以看到,只有当vnode的type是一个方法类型(组件的constructor)时才会返回ReactCompositeComponent</span></div><div class="line">            inst = <span class="keyword">new</span> ReactClass(props);</div><div class="line">        <span class="keyword">let</span> renderedElement, renderedComponentInstance, renderedMarkup;</div><div class="line"></div><div class="line">      <span class="comment">//保持对当前组件实例的引用</span></div><div class="line">        <span class="keyword">this</span>._instance = inst;</div><div class="line">        inst._reactInternalInstance = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">      <span class="comment">//执行生命周期中的componentWillMount</span></div><div class="line">        <span class="keyword">if</span> (lodash.isFunction(inst.componentWillMount)) &#123;</div><div class="line">            inst.componentWillMount();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">      <span class="comment">//调用当前组件的render</span></div><div class="line">        renderedElement = <span class="keyword">this</span>._instance.render();</div><div class="line">      </div><div class="line">      <span class="comment">//根据render中返回的再去执行instantiateReactComponent</span></div><div class="line">        renderedComponentInstance = instantiateReactComponent(renderedElement);</div><div class="line">        <span class="keyword">this</span>._renderedComponent = renderedComponentInstance;</div><div class="line">      </div><div class="line">      <span class="comment">//挂载组件</span></div><div class="line">        renderedMarkup = renderedComponentInstance.mountComponent(<span class="keyword">this</span>._rootNodeID);</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (lodash.isFunction(inst.componentDidMount)) &#123;</div><div class="line">            inst.componentDidMount();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> renderedMarkup;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    receiveComponent(nextElement, newState) &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面就是我们对三种组件的一个实现，下面我们用一个图简单表示下具体的渲染过程，第一次画图，不足之处多多包涵。</p><p><img src="/imgs/react-render.png" alt="渲染逻辑"></p><p>接下来我们需要写一个<code>Component</code>基类，去给所有的子类继承：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>() &#123;&#125;</div><div class="line"></div><div class="line">    setState(newState) &#123;</div><div class="line">        <span class="keyword">this</span>._reactInternalInstance.receiveComponent(<span class="literal">null</span>, newState);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     *  组件即将被挂载到DOM上</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    componentWillMount() &#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     *  组件已经被挂载到DOM上</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    componentDidMount() &#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     *  组件即将收到新的props</span></div><div class="line"><span class="comment">     *  @param   &#123;Object&#125;  nextProps  [新的props]</span></div><div class="line"><span class="comment">     *  @param   &#123;Object&#125;  nextState  [新的state]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    componentWillReceiveProps(nextProps, nextState) &#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     *  组件是否应该更新</span></div><div class="line"><span class="comment">     *  @param   &#123;Object&#125;  nextProps  [新的props]</span></div><div class="line"><span class="comment">     *  @param   &#123;Object&#125;  nextState  [新的state]</span></div><div class="line"><span class="comment">     *  @return  &#123;Boolean&#125;            [标记组件是否应该更新]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    shouldComponentUpdate(nextProps, nextState) &#123;</div><div class="line">        <span class="keyword">return</span> lodash.isEqual(<span class="keyword">this</span>.state, nextState) || lodash.isEqual(<span class="keyword">this</span>.props, nextProps);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     *  组件即将更新</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    componentWillUpdate() &#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     *  组件已经更新</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    componentDidUpdate() &#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     *  组件即将被卸载</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    componentWillUnmount() &#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     *  返回组件内部的jsx</span></div><div class="line"><span class="comment">     *  @return  &#123;JSX&#125;  [组件布局]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    render() &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下面我们一起根据上面的代码来完成一个初始化渲染的demo：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">"./src/react"</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputComponnet</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    keyUpHandler(ev) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">&lt;input</div><div class="line">        type = <span class="string">"text"</span></div><div class="line">                ref=<span class="string">"textInput"</span></div><div class="line">        placeholder = &#123; <span class="string">"请输入..."</span> &#125;</div><div class="line">        onKeyUp = &#123; <span class="keyword">this</span>.keyUpHandler.bind(<span class="keyword">this</span>) &#125;</div><div class="line">        style = &#123;&#123;</div><div class="line">                display: <span class="string">"block"</span>,</div><div class="line">                width: <span class="string">"200px"</span>,</div><div class="line">                height: <span class="string">"30px"</span>,</div><div class="line">                fontSize: <span class="string">"14px"</span>,</div><div class="line">                lineHeight: <span class="string">"30px"</span></div><div class="line">        &#125;&#125; /&gt;</div><div class="line">       );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span> ( </div><div class="line">            &lt;div style = &#123; <span class="string">"background: red;"</span> &#125; &gt;</div><div class="line">        App Component &lt;InputComponnet placeholder = &#123; <span class="string">"请输入..."</span> &#125;/&gt; </div><div class="line">         &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">        );</span></div><div class="line"><span class="regexp">    &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">React.render( &lt; App /</span> &gt; , <span class="built_in">document</span>.querySelector(<span class="string">"#root"</span>));</div></pre></td></tr></table></figure><p>到这里我们的初始化渲染已经完成了，我们实现了组件中的事件绑定（事件代理），简单的生命周期（<code>componentWillMout</code>， <code>componentDidMount</code>），将<code>virtual-dom</code>转换成真实的<code>DOM</code>并且挂载到页面的过程。</p><p><a href="https://github.com/rwson/little-react" target="_blank" rel="external">这里</a>可以查看相对完整的代码。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="http://www.ahonn.me/2017/06/08/write-a-react-from-scratch-init-render/" target="_blank" rel="external">从零开始写一个 React：初始化渲染</a></li><li><a href="https://segmentfault.com/a/1190000010822571" target="_blank" rel="external">从0实现一个tiny react</a></li><li><a href="http://purplebamboo.github.io/2015/09/15/reactjs_source_analyze_part_one/" target="_blank" rel="external">reactjs源码分析-上篇</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们知道&lt;code&gt;React&lt;/code&gt;组件返回的是&lt;code&gt;JSX&lt;/code&gt;，而&lt;code&gt;JSX&lt;/code&gt;将被&lt;code&gt;babel&lt;/code&gt;转换，在&lt;code&gt;React&lt;/code&gt;中是将&lt;code&gt;JSX&lt;/code&gt;中转换成&lt;code&gt;Reac
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
      <category term="React" scheme="http://yoursite.com/categories/javascript/React/"/>
    
    
  </entry>
  
  <entry>
    <title>实现你自己的Promise</title>
    <link href="http://yoursite.com/2017/08/04/2017-08-04-write-your-promise/"/>
    <id>http://yoursite.com/2017/08/04/2017-08-04-write-your-promise/</id>
    <published>2017-08-03T16:00:00.000Z</published>
    <updated>2017-09-04T08:08:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>在现代化前端开发中，经常会用到<code>Promise</code>模式，<code>Promise</code>最大的好处就是可以使异步代码看起来如同步般清新易读，从而从回调地狱中解脱出来，<code>ES6</code>已经原生支持<code>Promise</code>对象，但在未支持的浏览器中还需要通过 polyfill 模拟实现。下面一起实现一个<code>Promise</code>。</p><p>一般我们用<code>Promise</code>会写成类似下面的样子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> ins = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">  <span class="comment">//...</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">ins.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</div><div class="line">  <span class="comment">//   ...</span></div><div class="line">&#125;, (ex) =&gt; &#123;&#125;);</div></pre></td></tr></table></figure><p>在<code>Promise</code>中一共存在三种状态，<code>PENDING</code>, <code>FULFILLED</code>,<code>REJECTED</code>，在实例化一个<code>Promise</code>后，它的状态会变成<code>PENDING</code>，执行<code>resolve</code>或者<code>reject</code>方法会把状态改成<code>FULFILLED</code>或者<code>REJECTED</code>，此过程不可逆，也就是说每个<code>Promise</code>只能调用一次<code>resolve</code>或者<code>reject</code>。</p><p>先来搭个骨架:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> PENDING = <span class="string">"PENDING"</span>,</div><div class="line">    FULFILLED = <span class="string">"FULFILLED"</span>,</div><div class="line">    REJECTED = <span class="string">"REJECTED"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">resolver</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!isFunction(resolver)) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"TypeError: resolver must be a function"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//实例的值</span></div><div class="line">    <span class="keyword">this</span>.value = <span class="literal">null</span>;</div><div class="line"></div><div class="line">    <span class="comment">//实例的状态</span></div><div class="line">    <span class="keyword">this</span>.status = PENDING;</div><div class="line"></div><div class="line">    <span class="comment">//缓存then和catch中传入的方法</span></div><div class="line">    <span class="keyword">this</span>._doneCallbacks = [];</div><div class="line">    <span class="keyword">this</span>._failCallbacks = [];</div><div class="line"></div><div class="line">    <span class="comment">//在执行resolver内部抛出异常, try ... catch 包裹</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        resolver(resolve.bind(<span class="keyword">this</span>), reject.bind(<span class="keyword">this</span>));</div><div class="line">    &#125; <span class="keyword">catch</span> (ex) &#123;</div><div class="line">        reject.bind(<span class="keyword">this</span>)(ex);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">Promise</span>.prototype = &#123;</div><div class="line">  <span class="keyword">constructor</span>: Promise,</div><div class="line">  </div><div class="line">  then: function(onFulfilled, onRejected) &#123;&#125;,</div><div class="line">  </div><div class="line">  <span class="keyword">catch</span>: <span class="function"><span class="keyword">function</span>(<span class="params">onRejected</span>) </span>&#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFunction</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">"function"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面实现了一个<code>Promise</code>构造器并且在它原型上声明了<code>then</code>和<code>catch</code>两个空方法，下面我们一起来实现一下<code>then</code>和<code>catch</code>两个方法, <code>Promise</code>中的<code>then</code>支持调用，所以<code>then</code>方法需要返回一个<code>Promise</code>实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.prototype = &#123;</div><div class="line">  <span class="keyword">constructor</span>: Promise,</div><div class="line">  </div><div class="line">  //then方法接受onFulfilled, onRejected两个回调, 并且返回一个新的Promise实例</div><div class="line">  then: function(onFulfilled, onRejected) &#123;</div><div class="line">    <span class="comment">//要返回的新Promise</span></div><div class="line">    <span class="keyword">let</span> ins = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;);</div><div class="line"><span class="keyword">if</span> (isFunction(onFulfilled)) &#123;</div><div class="line">      <span class="comment">//将onFulfilled缓存到_doneCallbacks中</span></div><div class="line">      <span class="keyword">this</span>._doneCallbacks.push(makeCallback(ins, onFulfilled, <span class="string">"resolve"</span>));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (isFunction(onRejected)) &#123;</div><div class="line">      <span class="keyword">this</span>._failCallbacks.push(makeCallback(ins, onFulfilled, <span class="string">"reject"</span>));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ins;</div><div class="line">  &#125;,</div><div class="line">  </div><div class="line">  <span class="keyword">catch</span>: <span class="function"><span class="keyword">function</span>(<span class="params">onRejected</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>在实例化一个<code>Promise</code>时，我们的<code>resolver</code>有<code>resolve</code>和<code>reject</code>两个参数(也就是上面构造器中的最后)，在实例化完成后其中有一个将被立即调用，用于结束当前<code>Promise</code>。下面一起实现下<code>resolve</code>和<code>reject</code>，这两个函数完成的功能就是接受<code>resolver</code>中异步处理返回的值并且传递给<code>then</code>或者<code>catch</code>，并且将当前<code>PENDING</code>的状态改掉，刚才上面说到<code>Promise</code>的状态从<code>PENDING</code>到<code>FULFILLED</code>或者<code>REJECTED</code>是一个不可逆的过程，所以为了确保<code>resolve</code>或者<code>reject</code>不被多次调用，需要在方法开头提前判断下<code>status</code>是不是<code>PENDING</code>状态。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status !== PENDING) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">this</span>.value = data;</div><div class="line">  <span class="keyword">this</span>.status = FULFILLED;</div><div class="line">  run.call(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">ex</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status !== PENDING) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">this</span>.value = ex;</div><div class="line">  <span class="keyword">this</span>.status = REJECTED;</div><div class="line">  run.call(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在<code>resolve</code>和<code>reject</code>中，我们都调用了<code>run</code>方法，该方法的作用是用于触发接下来的<code>Promise</code>的执行。<code>run</code>函数中需要注意的一点是，需要异步执行相关的回调函数，下面一起来实现一个<code>run</code>方法，需要注意的是每个<code>Promise</code>只能被执行一次，所以在<code>run</code>方法最后，把<code>_doneCallbacks</code>和<code>_failCallbacks</code>置空。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">//获取到异步处理后的值, 根据当前状态获取要执行的回调</span></div><div class="line">  <span class="keyword">const</span> &#123; value &#125; = <span class="keyword">this</span>,</div><div class="line">callbacks = <span class="keyword">this</span>.status === FULFILLED ? <span class="keyword">this</span>._doneCallbacks : <span class="keyword">this</span>._failCallbacks；</div><div class="line">  </div><div class="line">  <span class="comment">//Promise异步执行</span></div><div class="line">  <span class="keyword">let</span> timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> fn <span class="keyword">of</span> callbacks) &#123;</div><div class="line">  <span class="comment">//值穿透到每个then或者catch</span></div><div class="line">      fn(value);</div><div class="line">    &#125;</div><div class="line">    clearTimeout(timeout);</div><div class="line">  &#125;);</div><div class="line">  </div><div class="line">  <span class="keyword">this</span>._doneCallbacks = [];</div><div class="line">  <span class="keyword">this</span>._failCallbacks = [];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面<code>run</code>里执行的每个<code>fn</code>都是<code>then</code>方法中<code>push</code>进<code>_doneCallbacks</code>或<code>_failCallbacks的</code>makeCallback<code>返回值，</code>makeCallback`是整个代码中比较复杂的一部分，下面一起看下具体实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeCallback</span>(<span class="params">promise, callback, action</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">promiseCallback</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="comment">//callback是个函数</span></div><div class="line">        <span class="keyword">if</span> (isFunction(callback)) &#123;</div><div class="line">        <span class="comment">//定义个变量去接受返回值</span></div><div class="line">        <span class="comment">//防止抛出异常, try ... catch 包裹, catch 时直接调用reject</span></div><div class="line">            <span class="keyword">let</span> x;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                x = callback(value);</div><div class="line">            &#125; <span class="keyword">catch</span> (ex) &#123;</div><div class="line">                reject.bind(promise)(ex);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//callback中返回的是this, 会引发死循环</span></div><div class="line">            <span class="comment">//抛出类型异常到reject</span></div><div class="line">            <span class="comment">/**</span></div><div class="line"><span class="comment">             * const ins = new Promise((resolve, reject) =&gt; &#123;&#125;);</span></div><div class="line"><span class="comment">             * ins.then(() =&gt; &#123;</span></div><div class="line"><span class="comment">             * return ins;</span></div><div class="line"><span class="comment">             * &#125;);</span></div><div class="line"><span class="comment">             */</span></div><div class="line">            <span class="keyword">if</span> (x === promise) &#123;</div><div class="line">                <span class="keyword">let</span> reason = <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"TypeError: The return value could not be same with the promise"</span>);</div><div class="line">                reject.bind(promise)(reason);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</div><div class="line"></div><div class="line">            <span class="comment">//callback中返回一个新的Promise</span></div><div class="line">            <span class="comment">//执行该Promise的then和catch</span></div><div class="line">            <span class="comment">/**</span></div><div class="line"><span class="comment">             * const ins = new Promise((resolve, reject) =&gt; &#123;&#125;);</span></div><div class="line"><span class="comment">             * ins.then(() =&gt; &#123;</span></div><div class="line"><span class="comment">             * return new Promise((resolve, reject) =&gt; &#123;&#125;);</span></div><div class="line"><span class="comment">             * &#125;);</span></div><div class="line"><span class="comment">             */</span></div><div class="line">                x.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</div><div class="line">                    resolve.bind(promise)(data);</div><div class="line">                &#125;, (ex) =&gt; &#123;</div><div class="line">                    reject.bind(promise)(ex);</div><div class="line">                &#125;);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">let</span> then;</div><div class="line">                (<span class="function"><span class="keyword">function</span> <span class="title">resolveThenable</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">                    <span class="comment">// 如果返回的是一个Thenable对象(Promise)</span></div><div class="line">                    <span class="keyword">if</span> (x &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">"object"</span> || isFunction(x))) &#123;</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            then = x.then;</div><div class="line">                        &#125; <span class="keyword">catch</span> (ex) &#123;</div><div class="line">                            reject.bind(promise)(ex);</div><div class="line">                            <span class="keyword">return</span>;</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        <span class="keyword">if</span> (isFunction(then)) &#123;</div><div class="line">                            <span class="comment">// 调用Thenable对象的then方法时,传递进去的resolvePromise和rejectPromise方法（及下面的两个匿名方法）</span></div><div class="line">                            <span class="comment">// 可能会被重复调用。 但Promise+规范规定这两个方法有且只能有其中的一个被调用一次,多次调用将被忽略</span></div><div class="line">                            <span class="comment">// 此处通过invoked来处理重复调用</span></div><div class="line">                            <span class="keyword">let</span> invoked = <span class="literal">false</span>;</div><div class="line">                            <span class="keyword">try</span> &#123;</div><div class="line">                                then.call( x, (y) =&gt; &#123;</div><div class="line">                                <span class="comment">//如果已经被调用了，直接return掉</span></div><div class="line">                                        <span class="keyword">if</span> (invoked) &#123;</div><div class="line">                                            <span class="keyword">return</span>;</div><div class="line">                                        &#125;</div><div class="line">                                        invoked = <span class="literal">true</span>;</div><div class="line"></div><div class="line">                                        <span class="comment">// 避免死循环</span></div><div class="line">                                        <span class="keyword">if</span> (y === x) &#123;</div><div class="line">                                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"TypeError: The return value could not be same with the previous thenable object"</span>);</div><div class="line">                                        &#125;</div><div class="line"></div><div class="line">                                        <span class="comment">// y仍有可能是thenable对象，递归调用</span></div><div class="line">                                        resolveThenable(y);</div><div class="line">                                    &#125;, (e) =&gt; &#123;</div><div class="line">                                        <span class="keyword">if</span> (invoked) &#123;</div><div class="line">                                            <span class="keyword">return</span>;</div><div class="line">                                        &#125;</div><div class="line">                                        invoked = <span class="literal">true</span>;</div><div class="line">                                        reject.bind(promise)(e);</div><div class="line">                                    &#125;</div><div class="line">                                );</div><div class="line">                            &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">                                <span class="comment">// 如果resolvePromise和rejectPromise方法被调用后,再抛出异常,则忽略异常</span></div><div class="line">                                <span class="comment">// 否则用异常对象reject此Promise对象</span></div><div class="line">                                <span class="keyword">if</span> (!invoked) &#123;</div><div class="line">                                    reject.bind(promise)(e);</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            resolve.bind(promise)(x);</div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        resolve.bind(promise)(x);</div><div class="line">                    &#125;</div><div class="line">                &#125;(x));</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//根据action判断执行resolve或者reject</span></div><div class="line">        action === <span class="string">"resolve"</span> ? resolve.bind(promise)(value) : reject.bind(promise)(value);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面就是我对于一个<code>Promise</code>的实现，完整代码请移步我的<a href="https://github.com/rwson/My-Promise" target="_blank" rel="external">GitHub</a></p><p>参考：</p><ul><li><a href="http://www.ituring.com.cn/article/66566" target="_blank" rel="external">Promises/A+规范</a></li><li><a href="http://bruce-xu.github.io/blogs/js/promise" target="_blank" rel="external">JS Promise的实现原理</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在现代化前端开发中，经常会用到&lt;code&gt;Promise&lt;/code&gt;模式，&lt;code&gt;Promise&lt;/code&gt;最大的好处就是可以使异步代码看起来如同步般清新易读，从而从回调地狱中解脱出来，&lt;code&gt;ES6&lt;/code&gt;已经原生支持&lt;code&gt;Promise&lt;/cod
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
      <category term="Promise" scheme="http://yoursite.com/categories/javascript/Promise/"/>
    
    
  </entry>
  
  <entry>
    <title>编写你自己的async.waterfall</title>
    <link href="http://yoursite.com/2017/05/14/2017-05-14-write-your-async.waterfall/"/>
    <id>http://yoursite.com/2017/05/14/2017-05-14-write-your-async.waterfall/</id>
    <published>2017-05-13T16:00:00.000Z</published>
    <updated>2017-06-14T08:43:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>在早期的异步开发中，如果有一些异步任务需要处理，难免会遇到回调地狱，为了解决这种问题，也出现过很多第三方库来避免，其中<a href="[https://caolan.github.io/async/]">async.js</a>就是比较有名的一个，里面有个<code>waterfall</code>方法，本文我们一起来模拟实现一个类似的</p><p>先来看下调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">waterfall([</div><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>);</div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">cb(<span class="literal">null</span>, <span class="number">123</span>);</div><div class="line">&#125;, <span class="number">2000</span>);</div><div class="line">&#125;,</div><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params">arg, cb</span>) </span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>);</div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="built_in">console</span>.log(arg);</div><div class="line">cb(<span class="literal">null</span>, <span class="number">123</span>, <span class="number">456</span>);</div><div class="line">&#125;, <span class="number">2000</span>);</div><div class="line">&#125;,</div><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2, cb</span>) </span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>);</div><div class="line"><span class="built_in">console</span>.log(arg1, arg2);</div><div class="line">&#125;</div><div class="line">], <span class="function"><span class="keyword">function</span>(<span class="params">ex</span>) </span>&#123;</div><div class="line"><span class="keyword">if</span> (ex) &#123;</div><div class="line"><span class="keyword">throw</span> ex;</div><div class="line">&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>下面我们一起来看下实现下<code>waterfall</code>这个方法 : </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * @param task 任务队列</span></div><div class="line"><span class="comment"> * @param callback 最后的回调</span></div><div class="line"><span class="comment"> **/</span></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">task = [], callback = noop</span>) </span>&#123;</div><div class="line">  <span class="comment">//类型判断</span></div><div class="line">    <span class="keyword">if</span> (!(task <span class="keyword">instanceof</span> <span class="built_in">Array</span>)) &#123;</div><div class="line">        <span class="keyword">return</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"task should be an array!"</span>));</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">  </div><div class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">...args</span>) </span>&#123;</div><div class="line">        <span class="comment">//  第一个参数如果不为空就直接执行callback</span></div><div class="line">        <span class="keyword">if</span> (args[<span class="number">0</span>]) &#123;</div><div class="line">            <span class="keyword">return</span> callback(args[<span class="number">0</span>]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (task.length) &#123;</div><div class="line">            <span class="comment">//  取得当前要执行的函数</span></div><div class="line">            <span class="keyword">let</span> fn = task.shift();</div><div class="line">          <span class="comment">//第一个参数是error相关的,所以从第二个开始截取</span></div><div class="line">            fn.apply(<span class="literal">null</span>, [...args.slice(<span class="number">1</span>), onlyOnce(next)]);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            callback.apply(<span class="literal">null</span>, args);</div><div class="line">        &#125;</div><div class="line">    &#125;)();</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 包装一个函数确保它只被执行一次</span></div><div class="line"><span class="comment"> **/</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onlyOnce</span>(<span class="params">cb</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> flag = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (flag) &#123;</div><div class="line">            <span class="keyword">return</span> cb(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'cb already called'</span>));</div><div class="line">        &#125;</div><div class="line">        cb.apply(<span class="literal">null</span>, args);</div><div class="line">        flag = <span class="literal">true</span>;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">noop</span>(<span class="params"></span>) </span>&#123;&#125;</div></pre></td></tr></table></figure><p>上面就是对<code>waterfall</code>方法的实现，在<a href="[https://caolan.github.io/async/]">async.js</a>还有很多其他很有用的方法，后面有机会继续模拟实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在早期的异步开发中，如果有一些异步任务需要处理，难免会遇到回调地狱，为了解决这种问题，也出现过很多第三方库来避免，其中&lt;a href=&quot;[https://caolan.github.io/async/]&quot;&gt;async.js&lt;/a&gt;就是比较有名的一个，里面有个&lt;code&gt;wa
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
      <category term="异步流控制" scheme="http://yoursite.com/categories/javascript/%E5%BC%82%E6%AD%A5%E6%B5%81%E6%8E%A7%E5%88%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>实现一个new函数</title>
    <link href="http://yoursite.com/2017/04/20/2017-04-20-write-a-new-operator/"/>
    <id>http://yoursite.com/2017/04/20/2017-04-20-write-a-new-operator/</id>
    <published>2017-04-19T16:00:00.000Z</published>
    <updated>2017-11-09T08:59:44.162Z</updated>
    
    <content type="html"><![CDATA[<p>在日常javaScript开发中，我们多多少少都会用到<code>new</code>，最常见的比如<code>new Date</code>等等，在一些<code>js</code>面向对象中，用到<code>new</code>的地方更多了，比如我们通过<code>function</code>来模拟声明一个类，需要实例化的时候就需要用<code>new xxx()</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Class</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> inst = <span class="keyword">new</span> Class();</div></pre></td></tr></table></figure><p>在<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="external">MDN</a>上对在执行了<code>new</code>之后的介绍如下:</p><ul><li>一个新对象被创建。它继承自<code>*foo*.prototype</code></li><li>构造函数 <code>*foo*</code> 被执行。执行的时候，相应的传参会被传入，同时上下文会被指定为这个新实例。<code>new *foo*</code> 等同于 <code>new *foo*()</code>, 只能用在不传递任何参数的情况。</li><li>如果构造函数返回了一个“对象”，那么这个对象会取代整个<code>new</code>出来的结果。如果构造函数没有返回对象，那么<code>new</code>出来的结果为步骤1创建的对象。(一般情况下构造函数不返回任何值，不过用户如果想覆盖这个返回值，可以自己选择返回一个普通对象来覆盖。当然，返回数组也会覆盖，因为数组也是对象。)</li></ul><p>在知道了<code>new</code>之后发生的事情，我们的<code>_new</code>函数就可以按照上面的几个步骤来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">//获取到所有参数</span></div><div class="line"><span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>),</div><div class="line">        <span class="comment">//创建一个空对象</span></div><div class="line">obj = <span class="built_in">Object</span>.create(&#123;&#125;),</div><div class="line">        <span class="comment">//把第一个参数作为构造器</span></div><div class="line">Constructor = args[<span class="number">0</span>],</div><div class="line">res;</div><div class="line">  <span class="comment">//继承构造器下的原型</span></div><div class="line">obj.__proto__ = args[<span class="number">0</span>].prototype;</div><div class="line">  <span class="comment">//执行构造器，并传入相关参数</span></div><div class="line">res = Constructor.apply(obj, args.slice(<span class="number">1</span>));</div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面是第一版，我们把构造器的执行结果作为返回值返回出去，下面我们一起写个模拟类测试下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Class</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line"><span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Class.prototype = &#123;</div><div class="line"><span class="keyword">constructor</span>: Class,</div><div class="line">method: function () &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"I'm method under Class.prototype"</span>);</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> inst = _new(Class, <span class="string">"rwson"</span>, <span class="number">24</span>);</div><div class="line">inst.method();</div><div class="line"><span class="built_in">console</span>.log(inst);</div></pre></td></tr></table></figure><p>可以看到在控制台打出的类似下图的东西</p><p><img src="/imgs/new-1.png" alt="new-1"></p><p>我们现在实现了一个版本，只是把在<code>_new</code>方法中的<code>obj</code>对象返回出来了，刚才上面第三步骤说到，<code>如果构造函数返回了一个“对象”，那么这个对象会取代整个</code>new<code>出来的结果。如果构造函数没有返回对象，那么</code>new<code>出来的结果为步骤1创建的对象。(一般情况下构造函数不返回任何值，不过用户如果想覆盖这个返回值，可以自己选择返回一个普通对象来覆盖。当然，返回数组也会覆盖，因为数组也是对象。)</code>，针对构造函数有返回值的情况，我们需要把该返回值返回，下面我们把之前的代码改改，以适配有返回值的情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>),</div><div class="line">obj = <span class="built_in">Object</span>.create(&#123;&#125;),</div><div class="line">Constructor = args[<span class="number">0</span>],</div><div class="line">res;</div><div class="line">obj.__proto__ = args[<span class="number">0</span>].prototype;</div><div class="line">res = Constructor.apply(obj, args.slice(<span class="number">1</span>));</div><div class="line">  </div><div class="line">  <span class="comment">//判断Constructor的返回值类型</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> res === <span class="string">"object"</span> ? res : obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>同样我们写个类做测试</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Class</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line"><span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">       name: name,</div><div class="line">       age: age</div><div class="line">&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> inst = _new(Class, <span class="string">"rwson"</span>, <span class="number">24</span>);</div><div class="line"><span class="built_in">console</span>.log(inst);</div></pre></td></tr></table></figure><p>观察在控制台的输出应该和下面的类似：</p><p><img src="/imgs/new-2.png" alt="new-2"></p><p>到这里我们的<code>_new</code>方法就实现了，但是由于<code>Object.create</code>的原因，在<code>IE9-</code>的版本中可能不太支持，所以我们需要把<code>Object.create</code>改成<code>new Object</code>或者对象字面量的形式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>),</div><div class="line">obj = &#123;&#125;,</div><div class="line">Constructor = args[<span class="number">0</span>],</div><div class="line">res;</div><div class="line">obj.__proto__ = args[<span class="number">0</span>].prototype;</div><div class="line">res = Constructor.apply(obj, args.slice(<span class="number">1</span>));</div><div class="line">  </div><div class="line">  <span class="comment">//判断Constructor的返回值类型</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> res === <span class="string">"object"</span> ? res : obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在日常javaScript开发中，我们多多少少都会用到&lt;code&gt;new&lt;/code&gt;，最常见的比如&lt;code&gt;new Date&lt;/code&gt;等等，在一些&lt;code&gt;js&lt;/code&gt;面向对象中，用到&lt;code&gt;new&lt;/code&gt;的地方更多了，比如我们通过&lt;code&gt;fu
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
      <category term="new操作符" scheme="http://yoursite.com/categories/javascript/new%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>NodeJs读取windows注册表来对软件进行卸载</title>
    <link href="http://yoursite.com/2017/03/29/2017-03-29-node-read-regedit-uninstall-software/"/>
    <id>http://yoursite.com/2017/03/29/2017-03-29-node-read-regedit-uninstall-software/</id>
    <published>2017-03-28T16:00:00.000Z</published>
    <updated>2017-03-30T13:28:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在基于node-webkit(以下简称NW)开发windows桌面app,里面有个类似于软件市场的功能,后台管理员提供一些软件,可以从该app上进行下载、安装、卸载、升级等等。</p><p>安装或升级可以直接通过把下载好的zip包解压出来然后执行里面的exe程序安装就好,但是卸载相对来说比较麻烦,几乎每个第三方exe在安装后的目录里面都有一个uninstall.exe,但是我们不知道这个软件具体安装在哪,所以要卸载也无从下手,这时候就想到了注册表,通过注册表可以获取到某个软件的安装目录,所以可以先把当前注册表的目录取得,再去相应目录下找卸载该软件的那个exe并执行。</p><p>由于NW是基于nodejs的,所以可以通过一些第三方的npm包来操作,在这里主要主要用到的包是<a href="https://github.com/fresc81/node-winreg" target="_blank" rel="external">winreg</a>,首先我们先分析下注册表:</p><p><img src="/imgs/regedit-nalysis.png" alt="注册表分析"></p><p>可以看到根下面有5个大项(HKEY_CLASSES_ROOT、HKEY_CURRENT_USER、HKEY_LOCAL_MACHINE、HKEY_USERS、HKEY_CURRENT_CONFIG),第三方软件基本上都是在HKEY_LOCAL_MACHINE下面的,所以读取的时候就从HKEY_LOCAL_MACHINE下面开始找,这里以搜狗输入法为例:</p><p><img src="/imgs/sogouinput.png" alt="搜狗输入法分析"></p><p>从上图中看到该项的全路径为”HKEY_LOCAL_MACHINE\SOFTWARE\SogouInput”,注册项里的第一项就是安装路径,对应的名称是默认,所以我们读取的时候从就可以读取刚才的那个路径,下面是主要的实现:</p><pre><code>const Registry = require(&quot;winreg&quot;),    child_process = require(&quot;child_process&quot;),    path = require(&quot;path&quot;),    key = new Registry({        //  打开HKEY_LOCAL_MACHINE这个大类        //  一共有5个属性,分别是&apos;HKLM&apos;, &apos;HKCU&apos;, &apos;HKCR&apos;, &apos;HKU&apos;, &apos;HKCC&apos;        //  就是上面那5大项的简称        hive: Registry.HKLM,        //  反斜杠前面需要加&quot;\&quot;进行转义        key: &quot;\\SOFTWARE\\SogouInput&quot;    });let pre, end, cur, target;//  获取到注册项中中所有配置项,以键值对的形式返回//  每一小项分别包含(host、hive、key、name、type、value、arch)这几个属性key.values((err, res) =&gt; {    if (err) {        console.log(err);    } else {        for(var i in res) {            cur = res[i];            //  判断当前项的名称是否包含default或者version            if (/default/gi.test(cur.name)) {                pre = cur.value;            } else if (/^version$/gi.test(cur.name)) {                end = cur.value;            }        }        //  拼接软件的安装全路径        target = `${pre}\\${end}`;        //  结合nodejs中子进程模块中的execFile方法执行卸载的exe        child_process.execFile(path.join(target, &quot;Uninstall.exe&quot;), (err, res) =&gt; {            if (err) {                console.log(&quot;卸载失败,请重试!&quot;);            }        });    }});</code></pre><p>最后执行写好的js文件,就会顺利打开相关卸载窗口:</p><p><img src="/imgs/uninstall-screenshoot.png" alt="卸载窗口"></p><p>当然这只是一个简单的实现,是分析好了软件安装目录下的卸载文件在什么地方去调用它的,肯定不能应用于所有场景,应该遍历该软件安装的根目录和子目录搜索卸载程序所在的最终目录来执行并进行卸载。</p><h5 id="记在2017-03-30"><a href="#记在2017-03-30" class="headerlink" title="记在2017-03-30"></a>记在2017-03-30</h5><p>今天尝试用昨天的写法来实现软件卸载,发现实现起来并不是那么简单,而且遍历文件的话面临一个性能问题,层级一多,递归循环就可能导致需要等好久才能开始卸载,所以又深入研究了下注册表,真是得来全不费工夫,注册表里面就给我们提供了某个软件的卸载路径,具体位置在</p><pre><code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\</code></pre><p>这边都是我们安装的所有软件,需要注意的是在64位系统中该路径有所不同,大问题解决了,我们又面临一个其他问题,就是有些软件在安装后,卸载那一级的最后一层并不是它自己的名字,而是一串花括号开始花括号结尾的字符串,类似于下图所示:</p><p><img src="/imgs/uninstall-id.png" alt="卸载id"></p><p>于是又在好几种不同版本的windows电脑上进行尝试,发现这个id始终是唯一的,最后和需求商量决定后台管理员在提供软件的时候把这个id也带上,这样就解决了问题,这样唯一的不好就是后台管理员的工作可能会稍微繁琐点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在基于node-webkit(以下简称NW)开发windows桌面app,里面有个类似于软件市场的功能,后台管理员提供一些软件,可以从该app上进行下载、安装、卸载、升级等等。&lt;/p&gt;
&lt;p&gt;安装或升级可以直接通过把下载好的zip包解压出来然后执行里面的exe程序安装就
      
    
    </summary>
    
      <category term="nodejs" scheme="http://yoursite.com/categories/nodejs/"/>
    
      <category term="桌面exe" scheme="http://yoursite.com/categories/nodejs/%E6%A1%8C%E9%9D%A2exe/"/>
    
    
  </entry>
  
  <entry>
    <title>decorator的学习</title>
    <link href="http://yoursite.com/2017/02/17/2017-02-17-es7-decorator-tourial/"/>
    <id>http://yoursite.com/2017/02/17/2017-02-17-es7-decorator-tourial/</id>
    <published>2017-02-16T16:00:00.000Z</published>
    <updated>2017-02-17T12:44:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>随着前端技术的发展,越来越多人把ES6、7用在日常开发中,在ES7中除了广为人知的async/await之外,还有一大特性 — decorator(装饰器)。</p><p>在之前原生javascript设计模式中的一篇文章(<a href="http://rwson.github.io/2015/07/15/2015-07-15-js-design-mode-decorator/" target="_blank" rel="external">javascript装饰者模式</a>)中说道: js装饰者模式可以把一个对象(类/函数)透明地包装在另外一个对象上,完成对被装饰者添加一些新功能的作用。简单的说我们可以在不修改类/函数内部代码的情况下,来达到给类/函数加入一些新功能。</p><p>装饰器可以作用于类或者类的成员属性/方法上,下面我们通过两段代码来分别解释:</p><pre><code>//  作用于类/** * 需求: * 封装4个方法,分别实现加减乘除四个功能 * 通过装饰器给类添加这四个方法,并且可指定是否作为类的静态方法添加 **///  加减乘除的实现function add() {    return [].slice.call(arguments).reduce((a, b) =&gt; a + b);}function reduce() {    return [].slice.call(arguments).reduce((a, b) =&gt; a - b);}function mul() {    return [].slice.call(arguments).reduce((a, b) =&gt; a * b);}function div() {    return [].slice.call(arguments).reduce((a, b) =&gt; a / b);}@bindCal(add, true)@bindCal(reduce, true)@bindCal(mul, false)@bindCal(div, false)class MyMath {}</code></pre><p>上面我们完成了需求中的四个函数的封装以及对MyMath类应用了装饰器,下面我们就来实现这个装饰器:</p><pre><code>/** * @param    {Function}   method    指向需要被添加方法的指针 * @param    {String}     isStatic  是否添加为静态属性,默认为true * @return   {Function} */function bindCal(method, isStatic = true) {    //  获取到方法名    const {name} = method;    //  当作用于类上时,会返回一个匿名函数,将类的构造函数作为第一个参数    return function(target) {        //  获取类的原型        const {prototype} = target;        //  添加为原型属性(非静态属性)        if (!isStatic) {            //  检测要添加的属性是否存在            if (prototype[name]) {                throw `${prototype.name}.${name} already exits!`;            } else {                //  利用ES5中的Object.defineProperty来添加相关属性                Object.defineProperty(target.prototype, name, {                    value: method                });            }        } else {            //  添加为静态属性            //  检测要添加的属性是否存在            if (target[name]) {                throw `${target}.${name} already exits!`;            }            //  利用ES5中的Object.defineProperty来添加相关属性            Object.defineProperty(target, name, {                value: method            });        }        //  返回类的构造器        return target;    }}</code></pre><p>我们把add和reduce作为静态方法添加给MyMath类,把mul和div作为原型方法给了MyMath类,所以调用应该看起来像下面的样子:</p><pre><code>const math = new MyMath();console.log(MyMath.add(1, 2, 3, 4));        //  10console.log(MyMath.reduce(1, 2, 3, 4));     //  -8console.log(math.mul(1, 2, 3, 4));          //  24console.log(math.div(10000, 1000, 10, 5));  //  0.2</code></pre><p>上面就是我们在类上应用装饰器的一个例子,下面再一起看下如果在成员属性/方法上应用构造器的例子:</p><pre><code>/** * 需求: * 实现在类中可以冻结成员属性(外部无法修改,只读) * 实现修改类中成员方法中的this指向 **///  实现一个类,并且对其成员属性/方法应用装饰器、定义一个对象,作为成员方法中的this指向const obj = {    name: &quot;rwson&quot;,    age: 24,    sex: &quot;male&quot;,    job: &quot;web developer&quot;};class Context {    constructor() {    }    @readonly    version = &quot;1.0.0&quot;;    @bindContext(obj)    showContext() {        console.log(this);    }} </code></pre><p>上面我们完成了对装饰器应用过程,下面一起看下readonly和bindContext两个装饰器的实现:</p><pre><code>/** * @param    {Object}   target    当前类的prototype * @param    {String}   key       将要被装饰的属性名 * @param    {Object}   decorator ES5中Object.defineProperty的最后一个参数 * @return   {Object}   decorator */function readonly(target, key, decorator) {    decorator.configurable = false;    decorator.enumerable = false;    decorator.writable = false;    decorator.value = decorator.value;    return decorator;}/** * @param    {Object}   context    需要绑定成this的对象 * @return   {Function} */function bindContext(context) {    /**     * @param    {Object}   target    当前类的prototype     * @param    {String}   key       将要被装饰的属性名     * @param    {Object}   decorator ES5中Object.defineProperty的最后一个参数     * @return   {Object}   decorator     */    return function(target, key, decorator) {        if (typeof context === &quot;undefined&quot;) {            context = target;        }        decorator.value = decorator.value.bind(context);        return decorator;    }}</code></pre><p>好了上面就是我们的两个作用于成员属性/方法上的装饰器,下面一起来看下简单的调用吧:</p><pre><code>const context = new Context();context.showContext();          //  打印出刚才定义的obj对象context.version = &quot;1.1.0&quot;;      //  抛出异常 Uncaught TypeError: Cannot assign to read only property &apos;version&apos; of object &apos;#&lt;Context&gt;&apos;</code></pre><p>好了,上面就装饰器的几种用法和实现,我们可能会发现刚才在定义装饰器函数的时候,当该装饰器作用于类上的时候返回出的匿名函数都是一个参数;而作用于成员属性或者成员方法上的,都是三个参数,这又是为啥呢?</p><p>一起来分析下编译后的代码:</p><pre><code>/** * @param    {Object}               target     当前类的prototype * @param    {String}               property   将要被装饰的属性名 * @param    {Array.&lt;Function&gt;}       decorators 装饰器函数列表 * @param    {Object}               descriptor ES5中Object.defineProperty的最后一个参数 * @param    {[type]}   context    [description] * @return   {[type]}              [description] * @private */function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {    //    属性对象    var desc = {};    //    Object[&quot;keys&quot;]    -&gt; [&quot;value&quot;, &quot;writable&quot;, &quot;enumerable&quot;, &quot;configurable&quot;]    //    把ES5中Object.defineProperty的最后一个参数的属性变成外部指定的    Object[&apos;ke&apos; + &apos;ys&apos;](descriptor).forEach(function (key) {        desc[key] = descriptor[key];    });    desc.enumerable = !!desc.enumerable;    desc.configurable = !!desc.configurable;    if (&apos;value&apos; in desc || desc.initializer) {        desc.writable = true;    }    desc = decorators.slice().reverse().reduce(function (desc, decorator) {        return decorator(target, property, desc) || desc;    }, desc);    if (context &amp;&amp; desc.initializer !== void 0) {        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;        desc.initializer = undefined;    }    //    利用Object.defineProperty定义属性    if (desc.initializer === void 0) {        Object[&apos;define&apos; + &apos;Property&apos;](target, property, desc);        desc = null;    }    //    返回当前属性对象    return desc;}</code></pre><p>可以看出其实decorator最后也是通过Object.defineProperty实现的,所以参数和Object.defineProperty是一致的。</p><p>那日常开发中,我们可能需要借助babel来对带有decorator的代码进行编译,首先我们需要安装babel:</p><pre><code>npm install babel -g</code></pre><p>然后切换到项目目录运行:</p><pre><code>npm install babel-plugin-transform-decorators-legacy --save-dev</code></pre><p>然后创建.babelrc配置文件,在plugins选项中添加以下配置:</p><pre><code>//  ...&quot;plugins&quot;: [    &quot;transform-decorators-legacy&quot;]//  ...</code></pre><p>最后我们就可以编译之前写的代码了:</p><pre><code>babel decorator.js &gt; decorator.es5.js</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着前端技术的发展,越来越多人把ES6、7用在日常开发中,在ES7中除了广为人知的async/await之外,还有一大特性 — decorator(装饰器)。&lt;/p&gt;
&lt;p&gt;在之前原生javascript设计模式中的一篇文章(&lt;a href=&quot;http://rwson.gi
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
      <category term="ES7" scheme="http://yoursite.com/categories/javascript/ES7/"/>
    
      <category term="decorator" scheme="http://yoursite.com/categories/javascript/ES7/decorator/"/>
    
    
  </entry>
  
  <entry>
    <title>实现一个拷贝文件夹以及文件夹下所有文件的方法</title>
    <link href="http://yoursite.com/2017/01/20/2017-01-20-copy-a-directory-and-files-under-it/"/>
    <id>http://yoursite.com/2017/01/20/2017-01-20-copy-a-directory-and-files-under-it/</id>
    <published>2017-01-19T16:00:00.000Z</published>
    <updated>2017-03-30T12:19:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>实现这个方法依赖了<a href="https://www.npmjs.com/package/fs-extra" target="_blank" rel="external">fs-extra</a>模块,实现目的是为了一个方法拷贝所有当前目录下所有文件,具体实现如下:</p><pre><code>let fs = require(&quot;fs-extra&quot;);/** * 批量拷贝文件 * @param src           源目录          String * @param target        目标目录        String * @param filetypes     文件类型        RegExp * @param ignorefiles   忽略文件列表    Array **/fs.copyAllFiles = (src, target, filetypes, ignorefiles) =&gt; {    let argus = arguments,        readSrc = src,        targetSrc = target,        fileSrc, targeFileSrc;    fs.readdir(readSrc, (ex, files) =&gt; {        if (files.length) {            files.forEach((file) =&gt; {                //  当前文件不在忽略列表中                if (!(~ignoreFiles.indexOf(file))) {                    fileSrc = path.resolve(readSrc, file);                    if (filetypes.test(file)) {                        targeFileSrc = path.resolve(targetSrc, file);                        fs.copySync(fileSrc, targeFileSrc);                    } else {                        targeFileSrc = path.resolve(targetSrc, file);                        fs.copySync(fileSrc, targeFileSrc);                        //  递归拷贝下一级目录                        fs.copyAllFiles.call(fileSrc, targeFileSrc, filetypes, ignorefiles);                    }                }            });        }    });};</code></pre><p>上面的就是要实现的方法,调用的方法就看起来像下面的样子:</p><pre><code>const ignoreFiles = [&quot;.DS_Store&quot;, &quot;.idea&quot;, &quot;.git&quot;, &quot;.svn&quot;];fs.copyAllFiles(&quot;a&quot;, &quot;b&quot;, /\.jpe?g|\.png/, ignoreFiles);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实现这个方法依赖了&lt;a href=&quot;https://www.npmjs.com/package/fs-extra&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;fs-extra&lt;/a&gt;模块,实现目的是为了一个方法拷贝所有当前目录下所有文件,具体实现如下:&lt;
      
    
    </summary>
    
      <category term="nodejs" scheme="http://yoursite.com/categories/nodejs/"/>
    
      <category term="文件操作" scheme="http://yoursite.com/categories/nodejs/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>实现一个webpack loader</title>
    <link href="http://yoursite.com/2017/01/18/2017-01-18-wrire-a-webpack-loader/"/>
    <id>http://yoursite.com/2017/01/18/2017-01-18-wrire-a-webpack-loader/</id>
    <published>2017-01-17T16:00:00.000Z</published>
    <updated>2017-03-30T12:19:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>在React,ES6开发模式越来越普及的今天,webpack就成了前端构建的一个标配。webpack有两大重要部分组成: loader和plugin。loader是用在应用源码上的转换原件,比如最常用到的babel-loader/jsx-loader/file-loader/css-loader/url-loader等等。</p><p>loader可链式执行,一种文件类型可以用多个loader(比如css文件,可能就需要用到css-loader和style-loader),loader之间用”!”分隔,当前loader处理完,把处理结果带到下一个loader,最后一个loader返回一个String或者String Buffer返回给compiler。</p><p>loader调用方式大体有3种形式:</p><ol><li><p>引用时调用</p><pre><code>//  a.jsrequire(&quot;style-loader/url!css-loader!./xxx.css&quot;);</code></pre></li><li><p>webpack直接调用</p><pre><code>//  webpack.config.js//  ...module: {    loaders: [        //  ...        {            test: /\.css$/,            loader: &quot;style-loader!css-loader&quot;        }    ]}</code></pre></li><li><p>指定loaders数组</p><pre><code>//  webpack.config.js//  ...module: {    loaders: [        //  ...        {            test: /\.css$/,            loaders: [                &quot;style-loader&quot;,                &quot;css-loader&quot;            ]        }    ]}</code></pre></li></ol><p>webpack官网上说”A loader is a node module exporting a function”,也就是说一个loader就是一个暴露出去的node模块,既然是一个node module,也就基本可以写成下面的样子:</p><pre><code>module.exports = function() {    //  ...};</code></pre><p>需要注意的是,在该模块被调用时,传入的第一个参数是文件的内容,所以我们可以再改改:</p><pre><code>/** * @param content  将被处理的内容 * **/module.exports = function(content) {    //  ...    //  运行下一个loader    this.callback(content);};</code></pre><p>知道了大体写法,现在我们就来实现一个简单的loader,主要功能就是把css中的px单位转换成rem单位</p><pre><code>//  px2rem-loader/index.js&quot;use strict&quot;;//  用来获取调用loader时传入的参数等等var loaderUtils = require(&quot;loader-utils&quot;);//  css解析模块var css = require(&quot;css&quot;);//  乘除模块,防止在计算中出现精度丢失的问题var privateMath = {    mul: function(num1, num2) {        var m = 0,            s1 = num1.toString(),            s2 = num2.toString();        try {            m += s1.split(&quot;.&quot;)[1].length        } catch (e) {}        try {            m += s2.split(&quot;.&quot;)[1].length        } catch (e) {}        return Number(s1.replace(&quot;.&quot;, &quot;&quot;)) * Number(s2.replace(&quot;.&quot;, &quot;&quot;)) / Math.pow(10, m);    },    div: function(num1, num2) {        var t1, t2, r1, r2;        try {            t1 = num1.toString().split(&apos;.&apos;)[1].length;        } catch (e) {            t1 = 0;        }        try {            t2 = num2.toString().split(&quot;.&quot;)[1].length;        } catch (e) {            t2 = 0;        }        r1 = Number(num1.toString().replace(&quot;.&quot;, &quot;&quot;));        r2 = Number(num2.toString().replace(&quot;.&quot;, &quot;&quot;));        return (r1 / r2) * Math.pow(10, t2 - t1);    }};module.exports = function(content) {    //  把当成css内容解析成AST对象    var contentAST = css.parse(content);    //  使用loader时的queryString(相关参数)    var query = loaderUtils.parseQuery(this.query);    //  最小px值,当数组小于它是忽略计算    var minSize = query.minSize || 1;    //  基数(最后计算出的结果 = (原先的大小 / base / scale) + &quot;rem&quot;)    var base = query.base || 37.5;    //  忽略的样式规则名称    var ignore = query.ignore.length ? query.ignore.split(&quot;|&quot;) : [];    //  缩放比    var scale = query.scale || 1;    //  匹配10px或者10.5px这种单位    var pxUnitReg = /\d+[\.{1}\d+]?px/gi;    var tmp;    //  遍历样式树    contentAST.stylesheet.rules.forEach(function(rule) {        //  遍历样式表        rule.declarations.forEach(function(style) {            if (ignore.indexOf(style.property) &lt; 0) {                style.value = style.value.replace(pxUnitReg, function(match) {                    tmp = parseFloat(match);                    if(tmp &gt; minSize) {                        return privateMath.div(tmp, privateMath.mul(base, scale)) + &quot;rem&quot;;                    }                });            }        });    });    //  再把处理好的AST对象转成css String    content = css.stringify(contentAST);    //  调用下一个loader    this.callback(null, content);};</code></pre><p>到这里,一个简单的load就算实现了,一起来看下调用把:</p><pre><code>//  webpack.config.jsconst webpack = require(&quot;webpack&quot;);module.exports = {    entry: &quot;./src/js/entry.js&quot;,    output: {        path: __dirname,        filename: &quot;build/bundle.js&quot;    },    module: {        loaders: [{            test: /\.js$/,            loader: &apos;babel-loader?presets[]=es2015&apos;        }, {            test: /\.css$/,            loader: &apos;style-loader!css-loader!px2rem-loader?base=37.5&amp;scale=2&amp;minSize=1&amp;ignore=border|margin|padding&apos;        }]    },    plugins: [    ]};</code></pre><p>之前的css:</p><p><img src="/imgs/webpack-loader-1.png" alt=""></p><p>打包之后:</p><p><img src="/imgs/webpack-px-2rem-compiled.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在React,ES6开发模式越来越普及的今天,webpack就成了前端构建的一个标配。webpack有两大重要部分组成: loader和plugin。loader是用在应用源码上的转换原件,比如最常用到的babel-loader/jsx-loader/file-loader
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
      <category term="构建工具" scheme="http://yoursite.com/categories/javascript/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    
      <category term="webpack" scheme="http://yoursite.com/categories/javascript/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/webpack/"/>
    
    
  </entry>
  
  <entry>
    <title>Shadow DOM研究</title>
    <link href="http://yoursite.com/2016/12/12/2016-12-12-chrome-shadow-dom-tourial/"/>
    <id>http://yoursite.com/2016/12/12/2016-12-12-chrome-shadow-dom-tourial/</id>
    <published>2016-12-11T16:00:00.000Z</published>
    <updated>2017-02-11T03:55:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://github.com/Polymer/polymer" target="_blank" rel="external">Polymer</a>中,提出了<a href="https://developer.mozilla.org/zh-CN/docs/Web/Web_Components" target="_blank" rel="external">Web Component</a>的概念,旨在让开发者可以封装出很多可复用的组件。现在,webkit添加了对该API支持,也就意味着我们不用借助框架,也可以自己封装出可复用的组件(通过自定义元素的形式),而不需要依赖其他框架来实现。</p><p>假设我们这边需要封装一个进度条组件,实现代码大概是这样的:</p><pre><code>//  javascriptclass CustomProgressBar extends HTMLElement {    constructor(args) {        super(args);        //  createShadowRoot用来创建一个shadowDOM实例        const shadowRoot = this.createShadowRoot();        //  设置组件内的布局结构和样式        shadowRoot.innerHTML = `            &lt;style type=&quot;text/css&quot;&gt;                :host {                    display: inline-block;                    width: 200px;                    height: 30px;                    box-sizing: border-box;                    padding: 1px;                }                :host * {                    -webkit-touch-callout: none;                    -webkit-user-select: none;                    -khtml-user-select: none;                    -moz-user-select: none;                    -ms-user-select: none;                    user-select: none;                }                .progress {                    display: inline-block;                    width: 200px;                    height: 30px;                    position: relative;                    border: 1px solid #000;                }                .progress &gt; .bar {                    background: red;                    height: 100%;                    width: 0;                    transition: all 0.2s;                }                .progress .label {                    position: absolute;                    top: 0;                    left: 0;                    width: 100%;                    text-align: center;                    font-size: 14px;                    line-height: 30px;                    color: #000;                }            &lt;/style&gt;            &lt;div class=&quot;progress&quot; aria-valuenow=&quot;0&quot; aria-valuemin=&quot;0&quot; aria-valuemax=&quot;100&quot;&gt;                &lt;div class=&quot;bar&quot;&gt;&lt;/div&gt;                &lt;div class=&quot;label&quot;&gt;0%&lt;/div&gt;            &lt;/div&gt;        `;        //  将相关元素存储到成员变量中        this._progressElement = shadowRoot.querySelector(&quot;.progress&quot;);        this._bar = shadowRoot.querySelector(&quot;.bar&quot;);        this._label = shadowRoot.querySelector(&quot;.label&quot;);    }    /**     * 取得当前进度     * @return {string}     */    get progress() {        return Number(this._progressElement.getAttribute(&quot;aria-valuenow&quot;));    }    /**     * 设置进度     * @param value     */    set progress(value) {        //  最大值值最小值        const max = this._progressElement.getAttribute(&quot;aria-valuemax&quot;),              min = this._progressElement.getAttribute(&quot;aria-valuemin&quot;);        //  类型判断        if(Number.isNaN(Number(value))) {            throw new Error(`value must be an number type, you specified ${value} which is ${{}.toString.call(value).slice(8, -1).toLowerCase()}!`);        }        //  范围检测        if(value &gt; max || value &lt; min) {            throw new Error(`value must between ${min} to ${max} , you specified ${value}!`);        }        //  设置相关属性        this._progressElement.setAttribute(&quot;aria-valuenow&quot;, value);        this._bar.style.width = `${value}%`;        this._label.textContent = `${value}%`;    }    /**     * 提供可以绑定onclick的接口     * @param callback     */    set onclick(callback) {        if(typeof callback === &quot;function&quot;) {            this._progressElement.addEventListener(&quot;click&quot;, e =&gt; {                callback.call(this, e);            }, false);        }    }}//  调用 customElements.define定义自定义元素,第一个参数自定义元素名,第二个参数是HTMLElement的一个子类customElements.define(&quot;custom-progress-bar&quot;, CustomProgressBar);window.onload = () =&gt; {    let customProgressBar = document.querySelector(&quot;custom-progress-bar&quot;),        progress;    /**     * 给进度条组件绑定onclick事件,每次点击进度加10     * @param e     */    customProgressBar.onclick = (e) =&gt; {        progress = Number(this.progress);        if(progress &gt;= 100) {            progress = 0;        } else {            progress += 10;        }        this.progress = progress;    };};//  HTML//  现在我们可以通过new CustomProgressBar()或者custom-progress-bar来使用自定义元素了&lt;custom-progress-bar&gt;&lt;/custom-progress-bar&gt;</code></pre><p>至此我们的一个进度条组件就算封装完成了,需要注意的是,customElements.define方法对第一个参数有一些要求:</p><ul><li>必须以小写字母 a-z 开头</li><li>不能包含大写字母 A-Z</li><li>必须包含”-“</li></ul><p>最后渲染出来是如下的布局结构:</p><p><img src="/imgs/shadow-dom-rendered.png" alt=""></p><p>一起看看实际的效果:</p><p><img src="/imgs/shadow-dom-gif.gif" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在&lt;a href=&quot;https://github.com/Polymer/polymer&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Polymer&lt;/a&gt;中,提出了&lt;a href=&quot;https://developer.mozilla.org/zh-CN
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
      <category term="Shadow DOM" scheme="http://yoursite.com/categories/javascript/Shadow-DOM/"/>
    
      <category term="Web Component" scheme="http://yoursite.com/categories/javascript/Shadow-DOM/Web-Component/"/>
    
    
  </entry>
  
  <entry>
    <title>Gulp插件的研究</title>
    <link href="http://yoursite.com/2016/11/29/2016-11-29-gulp-plugin-tourial/"/>
    <id>http://yoursite.com/2016/11/29/2016-11-29-gulp-plugin-tourial/</id>
    <published>2016-11-28T16:00:00.000Z</published>
    <updated>2017-03-30T12:19:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>在网页端功能越来越繁杂的今天,随着功能的增多,代码量也必不可少的多个,代码量一多,web性能就显得尤为重要,尤其是加载方面,时间太长,可能用户就没心情等下去,所以现在的web项目一般都在发布的时候进行一版自动构建,从原来的grunt到gulp,再到现在的webpack。</p><p>今天研究了下gulp插件,写点心得体会吧。看了两个gulp插件源码,发现里面都引入了<a href="https://github.com/rvagg/through2" target="_blank" rel="external">through2</a>这个包,官方的说法就是”Node Stream的简单封装，目的是让链式流操作更加简单;”,就也照葫芦画瓢,引用了这个包,简单实现一个gulp插件,功能就是压缩css,并且把css中的”background: url(xxxx.png)”中的”xxxx.png”转换成base64编码的形式,减少http请求数。</p><pre><code>&quot;use strict&quot;;const through = require(&quot;through2&quot;),    path = require(&quot;path&quot;),    fs = require(&quot;fs&quot;),    //  引用async/await,方便处理文件读写的异步操作    async = require(&quot;asyncawait&quot;).async,    await = require(&quot;asyncawait&quot;).await,    //  匹配url(../xxx.yyy)这种表达式    imgReg = /url\s*\((\s*[A-Za-z0-9\-\_\.\/\:]+\s*)\);?/gi,    //  将fs.readFile封装成Promise    readFile = (path) =&gt; {        return new Promise((resolve, reject) =&gt; {            fs.readFile(path, (ex, file) =&gt; {                if (ex) {                    reject(ex);                }                resolve(file);            });        });    };let base, contents, match, tmp, url;//  暴露出去的函数module.exports = (opt) =&gt; {    return through.obj(function(file, enc, cb) {        //  文件为空直接执行回调函数        if (file.isNull()) {            cb(null, file);        }        //  取得当前css的绝对路径        base = file.base;        //  匹配css中的无效字符,并且转换成buffer        file.contents = new Buffer(file._contents.toString()            //  去换行符            .replace(/\n/gm, &quot;&quot;)            //  去&quot;{&quot;之后到第一条样式间的空白字符            .replace(/\{\s+/g, &quot;{&quot;)            //  去&quot;;&quot;之后的空白字符            .replace(/\;\s+/g, &quot;;&quot;));        //  将文件内容转换成普通字符串并缓存        contents = file.contents.toString();        //  取得url(../../xxx.yyy),并且缓存        match = contents.match(imgReg);        //  async-await读取图片文件成base64编码        async(() =&gt; {            //  遍历之前的缓存项            match.forEach((item) =&gt; {                //  拼凑文件绝对路径                url = item.replace(&quot;url(&quot;, &quot;&quot;).replace(&quot;)&quot;, &quot;&quot;).trim();                //  用await读取文件,避免嵌套                tmp = await (readFile(path.resolve(base, url)));                //  替换之前匹配的字符串                contents = contents.replace(item, `url(data:image/png;base64,${tmp.toString(&quot;base64&quot;)})`);            });            //  把文件内容转成buffer            file.contents = new Buffer(contents);            //  回调函数            cb(null, file);        })();    });};</code></pre><p>至此,一个简单的插件就实现了,当然,还有很多不足,比如对图片进行压缩,减少base64字符串的长度,用request模块处理对网络图片的引用等等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在网页端功能越来越繁杂的今天,随着功能的增多,代码量也必不可少的多个,代码量一多,web性能就显得尤为重要,尤其是加载方面,时间太长,可能用户就没心情等下去,所以现在的web项目一般都在发布的时候进行一版自动构建,从原来的grunt到gulp,再到现在的webpack。&lt;/
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
      <category term="Gulp" scheme="http://yoursite.com/categories/javascript/Gulp/"/>
    
      <category term="构建工具" scheme="http://yoursite.com/categories/javascript/Gulp/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>javascript模块化编程-同步模式</title>
    <link href="http://yoursite.com/2016/11/29/2016-11-23-js-sync-module-mode/"/>
    <id>http://yoursite.com/2016/11/29/2016-11-23-js-sync-module-mode/</id>
    <published>2016-11-28T16:00:00.000Z</published>
    <updated>2017-03-30T12:19:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>在日常开发中,为了便于多人协作开发,我们通常都会采用模块化开发的模式,今天看张荣铭的《javascript设计模式》的时候,看到同步模式这一章,结合自己之前的立即,也来实现一个简单的同步模块化模式。</p><pre><code>const module = (() =&gt; {    //  缓存之前声明的模块    let modules = {};    /**     * [description]     * @param  deps     依赖列表     * @return Array     */    let _loadDeps = (deps) =&gt; {        return deps.map((dep) =&gt; {            return modules[dep];        });    };    return {        /**         * 声明一个模块         * @param   id      模块id         * @param   deps    依赖数组(模块id)         * @param   factory 构造函数         */        define: (id, deps, factory) =&gt; {            //  获取依赖,并且取得模块返回的对象            deps = _loadDeps(deps);            deps.map(function(dep) {                return dep.factory.apply(window, dep.deps);            });            //  判断模块名是否重复            if (modules[id]) {                 throw new Error(&quot;module &quot; + id + &quot; has been declared!&quot;);            }            //  缓存模块            modules[id] = {                id: id,                factory: factory,                deps: deps            };        },        /**         * 使用定义好的模块         * @param   depArr  依赖数组(模块id)         * @param   factory 构造函数         */        use: (depArr, factory) =&gt; {            //  获取依赖,并且取得模块返回的对象            depArr = depArr.map((dep) =&gt; {                return modules[dep].factory.apply(window, modules[dep].deps);            });            //  运行构造函数            factory.apply(window, depArr);        }    };})();</code></pre><p>下面我们声明几个模块做测试:</p><pre><code>//  A模块module.define(&quot;A&quot;, [], () =&gt; {    return {        method: () =&gt; {            console.log(&quot;method under module A&quot;);        }    };});//  B模块module.define(&quot;B&quot;, [], () =&gt; {    return {        method: () =&gt; {            console.log(&quot;method under module B&quot;);        }    };});//  Person类module.define(&quot;PersonClass&quot;, [], () =&gt; {    class Person {        constructor(name, age, sex, job) {            this.name = name;            this.age = age;            this.sex = sex;            this.job = job;        }        hello() {            console.log(&quot;hello &quot; + this.name);        }        eat() {            console.log(this.name + &quot; will eat&quot;);        }        getProfile() {            return {                name: this.name,                age: this.age,                sex: this.sex,                job: this.job            };        }    }    return Person;});</code></pre><p>最后我们调用module.use来使用这些模块:</p><pre><code>module.use([&quot;A&quot;, &quot;B&quot;, &quot;PersonClass&quot;], (A, B, PersonClass) =&gt; {    A.method();    B.method();    let person = new PersonClass(&quot;rwson&quot;, 24, &quot;male&quot;, &quot;web developer&quot;);    person.hello();    setTimeout(function() {        person.eat();    }, 5000);    console.log(person.getProfile());});</code></pre><p>最后浏览器控制台输出如下图的结果:</p><p><img src="/imgs/sync-module-mode.png" alt="javascript模块化-同步模式"></p><p>至此一个简单的模块化工具就开发完成了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在日常开发中,为了便于多人协作开发,我们通常都会采用模块化开发的模式,今天看张荣铭的《javascript设计模式》的时候,看到同步模式这一章,结合自己之前的立即,也来实现一个简单的同步模块化模式。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const module = (() =&amp;g
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
      <category term="模块化" scheme="http://yoursite.com/categories/javascript/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>一起写一个npm命令行工具</title>
    <link href="http://yoursite.com/2016/11/20/2016-11-20-write-a-client/"/>
    <id>http://yoursite.com/2016/11/20/2016-11-20-write-a-client/</id>
    <published>2016-11-19T16:00:00.000Z</published>
    <updated>2017-09-22T03:17:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>自从nodejs问世之后，随着前端不断的发展，出现过很多的命令行工具，就比如前端构建工具，从最开始的<code>grunt</code>，再到<code>gulp</code>，然后到现在的<code>webpack</code>等等，它们都有自己的命令行，接下来我们一起分析并实现一个简单的命令行工具</p><p>首先需要建一个目录，在这里我们暂且叫<code>cli-starter</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkdir cli-starter</div></pre></td></tr></table></figure><p>然后我们需要去用<code>npm</code>初始化这个目录，这里我们用默认的就好</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm init -y</div></pre></td></tr></table></figure><p>普通的 node.js 脚本需要使用<code>node 文件名</code>的形式执行，在脚本首行加上<code>#!/usr/bin/env node</code>可以在<code>linux</code>环境中指定脚本的解释程序</p><p>一切从<code>hello world</code>开始，我们现在新建一个<code>bin</code>目录，在下面用建一个<code>hello.js</code>，写入下面内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/usr/bin/env node</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"hello world"</span>);</div></pre></td></tr></table></figure><p>然后去<code>node ./bin/hello</code>，可以看到控制台会输出<code>hello world</code></p><p>当然这个只是在特定目录下去执行这个文件，如果想和其他命令行工具做到无处不在，可以在<code>package.json</code>中做如下指定</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"name"</span>: <span class="string">"hello"</span>,</div><div class="line">  <span class="attr">"bin"</span>: &#123;</div><div class="line">    <span class="attr">"hello"</span>: <span class="string">"./bin/hello"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后再通过<code>npm link</code>去添加到系统<code>PATH</code>，不要担心会污染系统，既然有<code>npm link</code>，肯定就有<code>npm unlink</code>，就是把我们添加的删除，这样，我们就可以在任何一个目录下使用这个<code>hello</code>命令了</p><p>上面就是一个最简单的命令行了，接下来我们需要对它进行完善，最常见的就是参数，有很多<code>npm</code>模块可以解析我们传入的参数，常用的有<a href="https://www.npmjs.com/package/commander" target="_blank" rel="external">commander</a>、<a href="https://www.npmjs.com/package/minimist" target="_blank" rel="external">minimist</a>等</p><p>在这里我用的<code>minimist</code>这个模块，用法<code>npm</code>上已经有了这里不再赘述，下面我们一起完成一个翻译小工具，调用谷歌的翻译接口，这里我直接用的<code>translate-api</code>这个<code>npm</code>包,一起看下实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/usr/bin/env node</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> minimist = <span class="built_in">require</span>(<span class="string">"minimist"</span>),</div><div class="line">    translate = <span class="built_in">require</span>(<span class="string">"translate-api"</span>);</div><div class="line"></div><div class="line"><span class="comment">//获取参数</span></div><div class="line"><span class="keyword">var</span> args = minimist((process.argv.slice(<span class="number">2</span>)), &#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     *  参数别名</span></div><div class="line"><span class="comment">     * hello --target=abc &lt;=&gt; hello -t=abc</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    alias: &#123;</div><div class="line">        t: <span class="string">"target"</span>,</div><div class="line">        i: <span class="string">"input"</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//存储输入的参数</span></div><div class="line"><span class="keyword">var</span> target = args.target,</div><div class="line">    input = args.input;</div><div class="line"></div><div class="line"><span class="comment">//调用封装好的Google Translate API</span></div><div class="line">translate.getText(input, &#123; <span class="attr">to</span>: target &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</div><div class="line"><span class="built_in">console</span>.log(res.text);</div><div class="line"><span class="comment">//退出进程</span></div><div class="line">    process.exit(<span class="number">1</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>到这里我们一个简单的命令行工具就写好了，只是一个小玩具，还有很多没实现，比如子命令等。</p><p>那么如果感觉这个工具写的还行，想分享到<code>npm</code>仓库里面给更多人使用，这时候我们就要用到<code>npm</code>的一些子命令了，首先我们需要用<code>npm adduser</code>去登录<code>npm</code>，让它知道这个包是谁发布的，然后用<code>npm publish</code>去推送到仓库，这里需要注意的是，在发布<code>npm</code>包时我们需要把镜像源切换成官方的，推荐使用<a href="https://www.npmjs.com/package/nrm" target="_blank" rel="external">nrm</a>去管理镜像，在用<code>publish</code>之前，先<code>nrm use npm</code>切下镜像，等发布成功之后别人就可以用<code>npm install &lt;package-name&gt; -g</code>去把我们的命令行工具安装到全局使用啦😜</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;自从nodejs问世之后，随着前端不断的发展，出现过很多的命令行工具，就比如前端构建工具，从最开始的&lt;code&gt;grunt&lt;/code&gt;，再到&lt;code&gt;gulp&lt;/code&gt;，然后到现在的&lt;code&gt;webpack&lt;/code&gt;等等，它们都有自己的命令行，接下来我们一起分
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
      <category term="命令行工具" scheme="http://yoursite.com/categories/javascript/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>async/await学习</title>
    <link href="http://yoursite.com/2016/11/09/2016-11-09-async:await-tourial/"/>
    <id>http://yoursite.com/2016/11/09/2016-11-09-async:await-tourial/</id>
    <published>2016-11-08T16:00:00.000Z</published>
    <updated>2017-03-30T12:19:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>在处理javascript中异步的时候,回调往往是最让人恶心的,之前介绍过用<a href="http://123.207.98.169:81/2016/05/04/2016-05-04-es6-promise/" target="_blank" rel="external">Promise</a>来处理异步的问题,但是即使用上了Promise,在处理回调上还是会有各种嵌套,今天来介绍下ES7中的async/await,由于在Nodejs中还未得到支持,所以需要借助一些npm包来实践,在这里用的是<a href="https://github.com/yortus/asyncawait" target="_blank" rel="external">asyncawait</a>。</p><p>先来个原生文件读取的例子:</p><pre><code>const fs = require(&quot;fs&quot;);fs.readFile(&quot;test.txt&quot;, (ex, res) =&gt; {   console.log(res.toString());    //   do something...   fs.readFile(&quot;test2.txt&quot;, (ex, res) =&gt; {        console.log(res.toString());        //  do something   });});//  控制台输出xxxxxyyyyy</code></pre><p>下面我们再用async/await实现一遍:</p><pre><code>const async = require(&quot;asyncawait&quot;).async;const await = require(&quot;asyncawait&quot;).await;let readFile = function(path) {    return new Promise((resolve, reject) =&gt; {        fs.readFile(path, (ex, res) =&gt; {            if (ex) {                reject(ex);            }            resolve(res);        });    });}let asyncReadFile = async(() =&gt; {    let fs = await (readFile(&quot;test.txt&quot;));    let fs2 = await (readFile(&quot;test2.txt&quot;));    console.log(fs.toString());    console.log(fs2.toString());});asyncReadFile();</code></pre><p>虽然代码可能比上面的多了一点,但是已经完全看不到回调嵌套的影子了,也能完成同样的功能,何乐而不为。😉</p><p>下面我们再来模拟一个异步请求的例子:</p><pre><code>const async = require(&quot;asyncawait&quot;).async;const await = require(&quot;asyncawait&quot;).await;const http = require(&quot;http&quot;);http.createServer((req, res) =&gt; {    switch (req.url) {        case &quot;/async-await&quot;:            setTimeout(() =&gt; {                res.writeHead(200, { &quot;Content-Type&quot;: &quot;text/plain&quot; });                res.end(&quot;request end&quot;);            }, 5000);            break;        case &quot;/async-await2&quot;:            setTimeout(() =&gt; {                res.writeHead(200, { &quot;Content-Type&quot;: &quot;text/plain&quot; });                res.end(&quot;request end2&quot;);            }, 8000);            break;        default:            break;    }}).listen(3000, &quot;127.0.0.1&quot;);let requestUrl = function(path) {    return new Promise((resolve, reject) =&gt; {        http.get({            hostname: &apos;localhost&apos;,            port: 3000,            path: path,            agent: false        }, (res) =&gt; {            res.on(&quot;data&quot;, (data) =&gt; {                resolve(data);            });            res.on(&quot;error&quot;, (ex) =&gt; {                reject(ex);            })        });    });}let asyncRequest = async(() =&gt; {    let resp, resp2;    await (requestUrl(&quot;/async-await&quot;).then((res) =&gt; {        console.log(res.toString());        resp = res.toString();    }).catch((ex) =&gt; {        resp = &quot;发生错误!&quot;;    }));    await (requestUrl(&quot;/async-await2&quot;).then((res) =&gt; {        resp2 = res.toString();    }).catch((ex) =&gt; {        resp = &quot;发生错误!&quot;;    }));    console.log(resp);    console.log(resp2);});asyncRequest();//  控制台输出request endrequest end2</code></pre><p>由此我们可以将async/await用在很多地方,比如例子中的文件读取、异步请求、nodejs中的查询数据库等等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在处理javascript中异步的时候,回调往往是最让人恶心的,之前介绍过用&lt;a href=&quot;http://123.207.98.169:81/2016/05/04/2016-05-04-es6-promise/&quot; target=&quot;_blank&quot; rel=&quot;external
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
      <category term="ES7" scheme="http://yoursite.com/categories/javascript/ES7/"/>
    
      <category term="async/await" scheme="http://yoursite.com/categories/javascript/ES7/async-await/"/>
    
    
  </entry>
  
  <entry>
    <title>IE下AngularJs中的ajax缓存</title>
    <link href="http://yoursite.com/2016/11/02/2016-11-02-ie-ajax-cache/"/>
    <id>http://yoursite.com/2016/11/02/2016-11-02-ie-ajax-cache/</id>
    <published>2016-11-01T16:00:00.000Z</published>
    <updated>2017-03-30T12:19:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>在单页应用越来越普及的今天,越来越多的项目都会采用这种方案,这几天用AngularJs做了一个PC端应用,有登录注册的功能,登录注册的功能是通过ajax实现的,在登录注册以后页面不刷新,只修改$rootScope下的某些属性值,然后在页面里面通过ng-if之类的指令来控制相关元素的显示隐藏。</p><p>之前的大概实现如下:</p><pre><code>//  jsvar app = angular.module(&quot;app&quot;, []);app.run([&quot;$rootScope&quot;, &quot;$http&quot;, function($rootScope, $http) {    $rootScope.isLogin = false;    $rootScope.$on(&quot;$routeChangeStart&quot;, function (event, next, current) {    $http.get(&quot;xxxx&quot;)        .success(function(res) {            $rootScope.isLogin = !!(res.isLogin);            //  ...        })        .error(function() {            //  ...        });    });}]);//  HTML&lt;div class=&quot;container&quot;&gt;    &lt;a href=&quot;/user/center&quot; ng-if=&quot;isLogin&quot;&gt;用户中心&lt;/a&gt;    &lt;a href=&quot;javascript:;&quot; ng-click=&quot;logout()&quot; ng-if=&quot;isLogin&quot;&gt;登出&lt;/a&gt;    &lt;a href=&quot;/login&quot; ng-if=&quot;!isLogin&quot;&gt;登录&lt;/a&gt;&lt;/div&gt;</code></pre><p>后来发现在Chrome/Firefox下都是好的,到了IE下登录以后不刷新就显示不对。原来以为是ng-if在IE下重新渲染过慢的问题,改成ng-show以后还是不行,然后看http状态码,发现是304,想到可能和缓存有关系,后来改了配置中关键ajax请求那边的东西,发现可以了,核心代码如下:</p><pre><code>app.config([&quot;$routeProvider&quot;, &quot;$httpProvider&quot;, function($routeProvider, $httpProvider){    //  ...    if (!$httpProvider.defaults.headers.get) {        $httpProvider.defaults.headers.get = {};    }    $httpProvider.defaults.headers.common[&quot;X-Requested-With&quot;] = &quot;XMLHttpRequest&quot;;    $httpProvider.defaults.headers.get[&quot;Cache-Control&quot;] = &quot;no-cache&quot;;    $httpProvider.defaults.headers.get[&quot;Pragma&quot;] = &quot;no-cache&quot;;}]);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在单页应用越来越普及的今天,越来越多的项目都会采用这种方案,这几天用AngularJs做了一个PC端应用,有登录注册的功能,登录注册的功能是通过ajax实现的,在登录注册以后页面不刷新,只修改$rootScope下的某些属性值,然后在页面里面通过ng-if之类的指令来控制相
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
      <category term="AngularJs" scheme="http://yoursite.com/categories/javascript/AngularJs/"/>
    
      <category term="ajax" scheme="http://yoursite.com/categories/javascript/AngularJs/ajax/"/>
    
    
  </entry>
  
  <entry>
    <title>javascript中的序列化</title>
    <link href="http://yoursite.com/2016/09/17/2016-09-17-javascript-serialize/"/>
    <id>http://yoursite.com/2016/09/17/2016-09-17-javascript-serialize/</id>
    <published>2016-09-16T16:00:00.000Z</published>
    <updated>2017-03-30T12:19:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>在用jQuery发送ajax(POST)请求的时候,最常见的提交方式就是”application/x-www-form-urlencoded”,通常都会传入一个data属性作为传输给后端的数据,在ajax发送之前,那么我们直接如果直接传入把这个对象传递给后端,后端就不能对该对象进行解析,因为对象会被转成字符串”[object Object]”,所以就需要我们对该对象进行url编码,并且转换成字符串,再传给后端。</p><p>假设我们先传递一个简单的对象(所有的key对应的value都不是引用类型[Array、Object]),就像下面这样:</p><pre><code>{    string: &quot;string&quot;,    number: 1}</code></pre><p>用jQuery中的$.ajax方法,POST提交,打开请求面板,在form data那边,点击view source,可以看到下面这一串字符串,就像下面的样子:</p><pre><code>string=string&amp;number=1</code></pre><p>在jQuery中,$.param这个方法可以实现进行url编码的作用。</p><p>现在可以自己实现一个:</p><pre><code>//  获取对象上的类名function _typeOf(obj) {    return {}.toString.call(obj).slice(8, -1);}//  encodeURIComponent简写function _encode(data) {    data = data || &quot;&quot;;    return encodeURIComponent(data);}//  序列化主函数function _serializenData(data) {    var res = data,        typeIn;    //  判断传入的是否是一个Object类型的数据    if (_typeOf(data) === &quot;Object&quot;) {        res = [];        for (var i in data) {            typeIn = _typeOf(data[i]);            switch (typeIn) {                //  遇到Object、Array时需要进行遍历或者枚举,对其内部元素、属性做处理后再放到结果集数组中                case &quot;Object&quot;:                    res.push(_loopObject(data[i], i));                    break;                case &quot;Array&quot;:                    res.push(_loopArray(data[i], i));                    break;                //  其他类型直接推到结果集数组                default:                    res.push(_encode(i) + &quot;=&quot; + _encode(data[i]));                    break;            }        }        //  把结果集数组转换成&quot;xxx=111&amp;yyy=333&amp;zzz=444&quot;的形式        res = res.join(&quot;&amp;&quot;).replace(&quot;%20&quot;, &quot;+&quot;)    }    return (&quot;&quot; + res);}/** * 深层遍历一个数组 * @param  {[type]} array [description] * @param  {[type]} key   [description] * @return {[type]}       [description] */function _loopArray(array, key) {    var res = [],        typeIn;    for (var i = 0, len = array.length; i &lt; len; i++) {        //  获取每一项的类名,如果是Object/则递归调用_loopArray/_loopObject,传入当前项和属性名,处理子项,再放到结果集中        typeIn = _typeOf(array[i]);        switch (typeIn) {            case &quot;Array&quot;:                res.push(_loopArray(array[i], (key + &quot;[&quot; + i + &quot;]&quot;)));                break;            case &quot;Object&quot;:                res.push(_loopObject(array[i], (key + &quot;[&quot; + i + &quot;]&quot;)));                break;            //    其他类型的直接推到结果集数组            default:                res.push(_encode(key + &quot;[]&quot;) + &quot;=&quot; + _encode((&quot;&quot; + array[i])));                break;        }    }    //  把结果集转换成&quot;xxx=111&amp;yyy=333&amp;zzz=444&quot;的形式    return res.join(&quot;&amp;&quot;);}/** * 深层遍历一个对象 * @param  {[type]} object [description] * @param  {[type]} key    [description] * @return {[type]}        [description] */function _loopObject(object, key) {    var res = [],        typeIn;    for (var i in object) {        //  取得一个当前key对应value的类名,如果是Object/Array,则进行递归调用        typeIn = _typeOf(object[i]);        switch (typeIn) {            case &quot;Array&quot;:                res.push(_loopArray(object[i], key + &quot;[&quot; + i + &quot;]&quot;));                break;            case &quot;Object&quot;:                res.push(_loopObject(object[i], key + &quot;[&quot; + i + &quot;]&quot;));                break;            //    其他类型的直接推到结果集数组中            default:                res.push(_encode(key + &quot;[&quot; + i + &quot;]&quot;) + &quot;=&quot; + _encode((&quot;&quot; + object[i])));                break;        }    }    //  把结果集转换成&quot;xxx=111&amp;yyy=333&amp;zzz=444&quot;的形式    return res.join(&quot;&amp;&quot;);}</code></pre><p>下面我们模拟几个复杂点的对象,调用封装的序列化方法,和$.param进行对比:</p><pre><code>var obj = {    string: &quot;string&quot;,    number: 1,    array: [1, 2, 3, 4, 5]};var obj2 = {    string: &quot;string&quot;,    number: 1,    array: [        1, 2, 3, 4, 5, {            key1: &quot;value1&quot;,            key2: &quot;value2&quot;,            key3: &quot;value3&quot;        }    ]};var obj3 = {    array: [1, 2, 3, 4, 5],    arrayobject: [{        key1: &quot;value1&quot;,        key2: &quot;value2&quot;,        key3: &quot;value3&quot;    }, {        key1: &quot;value1&quot;,        key2: &quot;value2&quot;,        key3: &quot;value3&quot;    }, {        key1: &quot;value1&quot;,        key2: &quot;value2&quot;,        key3: &quot;value3&quot;    }]};var deepObj1 = {    arr: [{        string: &quot;string&quot;,        number: 1,        arr: [1, 2, 3, 4],        mixArr: [{            key1: &quot;value1&quot;,            key2: &quot;value2&quot;        }, {            key1: &quot;value1&quot;,            key2: &quot;value2&quot;        }, {            key1: &quot;value1&quot;,            key2: &quot;value2&quot;        }]    }]};var deepObj2 = {    obj: {        key1: &quot;value1&quot;,        key2: &quot;value2&quot;,        key3: &quot;value3&quot;    },    array: [1, 2, 3, 4, 5],    objectArray: {        array: [1, 2, 3, 4, 5, {            key1: &quot;value1&quot;,            key2: &quot;value2&quot;,            key3: &quot;value3&quot;        }]    },    arrayObj: [{        key1: &quot;value1&quot;,        key2: &quot;value2&quot;,        key3: &quot;value3&quot;    }, {        key1: &quot;value1&quot;,        key2: &quot;value2&quot;,        key3: &quot;value3&quot;    }, {        key1: &quot;value1&quot;,        key2: &quot;value2&quot;,        key3: &quot;value3&quot;    }]};//  打开控制台的console面板,查看输出console.group(&quot;serialize obj&quot;);console.log(_serializenData(obj));  //  ...console.log($.param(obj));  //  ...console.log(_serializenData(obj) === $.param(obj)); //  trueconsole.groupEnd();console.group(&quot;serialize obj2&quot;);console.log(_serializenData(obj2)); //  ...console.log($.param(obj2)); //  ...console.log(_serializenData(obj2) === $.param(obj2));   //  trueconsole.groupEnd();    console.group(&quot;serialize obj3&quot;);console.log(_serializenData(obj3)); //  ...console.log($.param(obj3)); //  ...console.log(_serializenData(obj3) === $.param(obj3));   //  trueconsole.groupEnd();console.group(&quot;serialize deepObj1&quot;);console.log(_serializenData(deepObj1)); //  ...console.log($.param(deepObj1)); //  ...console.log(_serializenData(deepObj1) === $.param(deepObj1));   //  trueconsole.groupEnd();console.group(&quot;serialize deepObj2&quot;);console.log(_serializenData(deepObj2)); //  ...console.log($.param(deepObj2)); //  ...console.log(_serializenData(deepObj2) === $.param(deepObj2));   //  trueconsole.groupEnd();</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在用jQuery发送ajax(POST)请求的时候,最常见的提交方式就是”application/x-www-form-urlencoded”,通常都会传入一个data属性作为传输给后端的数据,在ajax发送之前,那么我们直接如果直接传入把这个对象传递给后端,后端就不能对该
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
      <category term="序列化" scheme="http://yoursite.com/categories/javascript/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>javascript中Date细节</title>
    <link href="http://yoursite.com/2016/08/30/2016-08-30-something-about-javascript-Date/"/>
    <id>http://yoursite.com/2016/08/30/2016-08-30-something-about-javascript-Date/</id>
    <published>2016-08-29T16:00:00.000Z</published>
    <updated>2017-03-30T12:19:21.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="Safri浏览器new-Date-“yyyy-mm-dd”-返回invalid-Date"><a href="#Safri浏览器new-Date-“yyyy-mm-dd”-返回invalid-Date" class="headerlink" title="Safri浏览器new Date(“yyyy-mm-dd”)返回invalid Date"></a>Safri浏览器new Date(“yyyy-mm-dd”)返回invalid Date</h5><p>许多时候我们需要初始化一个具体某天的日期对象的时候,会用到new Date(),这个方法,我们可以传入一个字符串作为参数来指定具体的日期,而一般我们会传入一个”yyyy-mm-dd hh:ii:ss”这种格式作为一个初始日期,但到了Safri浏览器下,就会返回一个invalid Date,调用该Date实例下的所有方法都会返回NaN值,原因是Safri不能正常解析中间的”-“分隔符,解决办法也很简单,有两种:</p><p>直接</p><pre><code>var myDate1 = Date.parseExact(&quot;29-11-2010&quot;, &quot;dd-MM-yyyy&quot;);var myDate2 = Date.parseExact(&quot;11-29-2010&quot;, &quot;MM-dd-yyyy&quot;);var myDate3 = Date.parseExact(&quot;2010-11-29&quot;, &quot;yyyy-MM-dd&quot;);var myDate4 = Date.parseExact(&quot;2010-29-11&quot;, &quot;yyyy-dd-MM&quot;);</code></pre><p>或者</p><pre><code>new Date(&quot;2011-04-12&quot;.replace(/-/g, &quot;/&quot;));</code></pre><h5 id="setMonth溢出问题"><a href="#setMonth溢出问题" class="headerlink" title="setMonth溢出问题"></a>setMonth溢出问题</h5><p>实例化一个Date对象,通过如下的方式,然后调用该实例的setMonth方法,把当前月份加1,就像下面这样</p><pre><code>var date = new Date(&quot;2016/01/30&quot;);date.setMonth(date.getMonth() + 1);console.log(date.getMonth());       //  Tue Mar 01 2016 00:00:00 GMT+0800 (CST)</code></pre><p>或者</p><pre><code>var date = new Date(&quot;2016/10/31&quot;);date.setMonth(date.getMonth() + 1);console.log(date);                 //  Thu Dec 01 2016 00:00:00 GMT+0800 (CST)</code></pre><p>上面两段我们都希望是返回的是2月和11月,但是真正返回了3月和12月</p><p>出现这种情况的原因是2月没有28/29号以后的日期,而当前日期对象的日期为30号,调用setMonth,就导致溢出,下面的例子同理。</p><p>解决办法也很简单,在调用setMonth之前,拿下个月的最后一天和当前的比较下,再做相应处理就好,或者更简单粗暴的方法,把当前Date对象的date改成1,哈哈。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;Safri浏览器new-Date-“yyyy-mm-dd”-返回invalid-Date&quot;&gt;&lt;a href=&quot;#Safri浏览器new-Date-“yyyy-mm-dd”-返回invalid-Date&quot; class=&quot;headerlink&quot; title=&quot;Safr
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
      <category term="Date" scheme="http://yoursite.com/categories/javascript/Date/"/>
    
    
  </entry>
  
</feed>
