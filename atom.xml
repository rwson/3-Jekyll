<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小宋</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-09-14T09:26:47.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>rwson</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从零开始写一个React - setState和生命周期</title>
    <link href="http://yoursite.com/2017/09/14/2017-09-14-write-your-own-react-2/"/>
    <id>http://yoursite.com/2017/09/14/2017-09-14-write-your-own-react-2/</id>
    <published>2017-09-13T16:00:00.000Z</published>
    <updated>2017-09-14T09:26:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>在前面一篇中我们用<code>instantiateReactComponent</code>方法来根据<code>node</code>的不同来返回不同的组件实例，之前的分类可能有些问题，就是当该组件中<code>JSX</code>部分有返回<code>null</code>的情况，<code>instantiateReactComponent</code>就不能返回正确的组件，所以在这里加了一种新的组件类型：<code>ReactEmptyComponent</code>，作用就是返回一段空的注释，标记这是一个空组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">instantiateReactComponent</span>(<span class="params">node</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (lodash.isNull(node) || lodash.isUndefined(node)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReactEmptyComponent(<span class="literal">null</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//  ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//  空组件</span></div><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ReactEmptyComponent</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(node) &#123;</div><div class="line">        <span class="keyword">this</span>.type = <span class="string">"ReactEmptyComponent"</span>;</div><div class="line">        <span class="keyword">this</span>._currentElement = <span class="literal">null</span>;</div><div class="line">        <span class="keyword">this</span>._rootNodeID = <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     *  空组件挂载直接返回一段空注释回去</div><div class="line">     */</div><div class="line">    mountComponent(rootID) &#123;</div><div class="line">        <span class="keyword">this</span>._rootNodeID = rootID;</div><div class="line">        <span class="keyword">return</span> <span class="string">`&lt;!-- empty component data-reactid="<span class="subst">$&#123;<span class="keyword">this</span>._rootNodeID&#125;</span>" --&gt;`</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们之前简单实现了一个初始化渲染的过程，现在我们一起实现一个<code>setState</code>方法以及组件后面的更新逻辑。<code>setState</code>是在组件中被调用的，所以我们需要在之前的<code>Component</code>类中加入一个<code>setState</code>方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">//	...</span></div><div class="line"></div><div class="line">    setState(newState, callback) &#123;</div><div class="line">        <span class="keyword">const</span> stacks = StackTrace.getSync();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> &#123;functionName, source&#125; <span class="keyword">of</span> stacks) &#123;</div><div class="line">            <span class="keyword">if</span>(RENDER_REG.test(functionName) &amp;&amp; RENDER_REG.test(source)) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"callStack Error: you can't call setState in render method!"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>._reactInternalInstance.receiveComponent(<span class="literal">null</span>, newState);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (lodash.isFunction(callback)) &#123;</div><div class="line">            callback();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="comment">//	...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之前一篇我们说到一共可分成文本组件，浏览器标签组件，自定义标签组件，所以我们需要在这三个组件中各实现一个<code>receiveComponent</code>来接收新组件并且实现相应更新：</p>
<p>对于普通的文本节点，要做的相对简单，就是在<code>receiveComponent</code>中去更新相关<code>DOM</code>的<code>textContent</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ReactDOMTextComponent</span> </span>&#123;</div><div class="line">  	<span class="comment">//	...</span></div><div class="line">  </div><div class="line">    <span class="comment">/**</span></div><div class="line">     *  接收到新组件</div><div class="line">     *  @param   &#123;String&#125;  text  [接收到的新组件]</div><div class="line">     */</div><div class="line">    receiveComponent(text) &#123;</div><div class="line">        <span class="keyword">const</span> nextStringText = (<span class="string">""</span> + text);</div><div class="line">        <span class="keyword">if</span> (nextStringText !== <span class="keyword">this</span>._currentElement) &#123;</div><div class="line">            <span class="keyword">this</span>._currentElement = nextStringText;</div><div class="line">          	<span class="comment">//	更新相关DOM的textContent</span></div><div class="line">            $(<span class="string">`[data-reactid='<span class="subst">$&#123;<span class="keyword">this</span>._rootNodeID&#125;</span>']`</span>).textContent = nextStringText;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在自定标签组件中，我们需要做的事情大概如下</p>
<ul>
<li>如果调用时传入了新的<code>Vnode</code>就把当前的<code>_currentElement</code>改成新传入的<code>Vnode</code></li>
<li>合并新老<code>state</code></li>
<li>调用组件实例下的<code>shouldComponentUpdate</code>根据返回的布尔值去判断是否需要更新组件</li>
<li>调用组件实例下的<code>componentWillUpdate</code></li>
<li>调用组件的<code>render</code>去拿到新的<code>Vnode</code>，和之前的做对比，如果之前的组件<code>Vnode</code>不存在，就直接调用<code>instantiateReactComponent</code>返回新的组件实例</li>
<li>调用组件生命周期下的<code>componentDidUpdate</code>方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ReactCompositeComponent</span> </span>&#123;</div><div class="line">    <span class="comment">//	...</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     *  接收到新组件, 更新实例下的state, 组件生命周期方法调用</div><div class="line">     *  @param   &#123;ReactElement&#125;  nextElement  [新的Vnode]</div><div class="line">     *  @param   &#123;Object&#125;        newState     [this.setState(state)中的state]</div><div class="line">     */</div><div class="line">    receiveComponent(nextElement, newState) &#123;</div><div class="line">        <span class="comment">//  如果接受了新的, 就使用最新的element</span></div><div class="line">        <span class="keyword">this</span>._currentElement = nextElement || <span class="keyword">this</span>._currentElement;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> &#123; _rootNodeID &#125; = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">        <span class="keyword">let</span> inst = <span class="keyword">this</span>._instance,</div><div class="line"></div><div class="line">            <span class="comment">//  nextState和nextProps的处理</span></div><div class="line">            nextState = <span class="built_in">Object</span>.assign(inst.state || &#123;&#125;, newState),</div><div class="line">            nextProps = lodash.clone(<span class="keyword">this</span>._currentElement.props),</div><div class="line">            finalProps,</div><div class="line">            prevComponentInstance,</div><div class="line">            prevRenderedElement,</div><div class="line">            nextRenderedElement,</div><div class="line">            nextMarkup,</div><div class="line">            child;</div><div class="line"></div><div class="line">        <span class="comment">//  修改组件的state和props</span></div><div class="line">        <span class="keyword">this</span>._instance.state = nextState;</div><div class="line">        <span class="keyword">this</span>._instance.props = nextProps;</div><div class="line">        inst.state = nextState;</div><div class="line">        inst.props = nextProps;</div><div class="line"></div><div class="line">        <span class="comment">//  声明周期shouldComponentUpdate</span></div><div class="line">        <span class="keyword">if</span> (!inst.shouldComponentUpdate(nextProps, nextState)) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//  声明周期componentWillUpdate</span></div><div class="line">        inst.componentWillUpdate(nextProps, nextState);</div><div class="line"></div><div class="line">        <span class="comment">//  之前的组件组件实例</span></div><div class="line">        prevComponentInstance = <span class="keyword">this</span>._renderedComponent;</div><div class="line"></div><div class="line">        <span class="comment">//  之前的组件元素</span></div><div class="line">        prevRenderedElement = prevComponentInstance._currentElement;</div><div class="line"></div><div class="line">        <span class="comment">//  即将被渲染的新组件元素</span></div><div class="line">        nextRenderedElement = inst.render();</div><div class="line"></div><div class="line">        <span class="comment">//  判断是需要更新还是直接就重新渲染</span></div><div class="line">        <span class="keyword">if</span> (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) &#123;</div><div class="line">            prevComponentInstance.receiveComponent(nextRenderedElement);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//  重新new一个对应的component</span></div><div class="line">            <span class="keyword">this</span>._renderedComponent = instantiateReactComponent(nextRenderedElement);</div><div class="line"></div><div class="line">            <span class="comment">//  重新生成对应的元素内容</span></div><div class="line">            nextMarkup = <span class="keyword">this</span>._renderedComponent.mountComponent(_rootNodeID);</div><div class="line"></div><div class="line">            <span class="comment">//  替换整个节点</span></div><div class="line">            $(<span class="string">`[data-reactid="<span class="subst">$&#123;_rootNodeID&#125;</span>"]`</span>).innerHTML = nextMarkup;</div><div class="line">        &#125;</div><div class="line">        inst.componentDidUpdate();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在组件的<code>render</code>被重新调用之后，最后还是需要要更新<code>DOM</code>的，所以在<code>ReactDOMComponent</code>下的<code>receiveComponent</code>里我们需要对组件里的<code>DOM</code>下的属性和结构进行更新。</p>
<p>在<code>React</code>中，有一套<code>diff</code>算法来比较新老组件间的差异，返回需要更新的队列，然后统一对<code>DOM</code>结构进行更新，在<code>ReactDOMComponent</code>下的<code>receiveComponent</code>中，我们需要完成下面的几件事情</p>
<ul>
<li>拿到老的<code>props</code>和新的<code>props</code>做，在<code>_updateDOMProperties</code>中对<code>DOM</code>下的属性进行更新</li>
<li>调用<code>_updateDOMChildren</code>，传入新的组件子节点，去拼凑差异队列，然后更新<code>DOM</code></li>
<li>修改<code>currentElement</code>变成本次渲染的，供下次使用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ReactDOMComponent</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     *  接收到新组件</div><div class="line">     *  @param   &#123;Object&#125;  nextElement  [新组件]</div><div class="line">     */</div><div class="line">    receiveComponent(nextElement) &#123;</div><div class="line">        <span class="keyword">const</span> lastProps = lodash.clone(<span class="keyword">this</span>._currentElement.props),</div><div class="line">            nextProps = nextElement.props;</div><div class="line"></div><div class="line">        <span class="comment">//  需要单独的更新属性</span></div><div class="line">        <span class="keyword">this</span>._updateDOMProperties(lastProps, nextProps);</div><div class="line"></div><div class="line">        <span class="comment">//  再更新子节点</span></div><div class="line">        <span class="keyword">this</span>._updateDOMChildren(nextElement.props.children);</div><div class="line"></div><div class="line">        <span class="comment">//  修改currentElement变成本次渲染的</span></div><div class="line">        <span class="keyword">this</span>._currentElement = nextElement;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     *  更新组件中相关DOM的属性</div><div class="line">     *  @param    &#123;Object&#125;  lastProps  [旧属性]</div><div class="line">     *  @param    &#123;Object&#125;  nextProps  [新属性]</div><div class="line">     *  @private</div><div class="line">     */</div><div class="line">    _updateDOMProperties(lastProps, nextProps) &#123;</div><div class="line">        <span class="keyword">const</span> &#123; _rootNodeID &#125; = <span class="keyword">this</span>,</div><div class="line">        element = $(<span class="string">`[data-reactid="<span class="subst">$&#123;_rootNodeID&#125;</span>"]`</span>);</div><div class="line">        <span class="keyword">let</span> propKey, propValue, eventType, removed;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (propKey <span class="keyword">in</span> lastProps) &#123;</div><div class="line">            <span class="comment">//  只删除老属性中有但是新属性中没有的</span></div><div class="line">            <span class="keyword">if</span> (hasOwnProperty(lastProps, propKey) &amp;&amp; !hasOwnProperty(nextProps, propKey)) &#123;</div><div class="line">                propValue = lastProps[propKey];</div><div class="line"></div><div class="line">                <span class="comment">//  之前的事件代理需要解除</span></div><div class="line">                <span class="keyword">if</span> (EVENT_REG.test(propKey)) &#123;</div><div class="line">                    eventType = propKey.replace(<span class="string">"on"</span>, <span class="string">""</span>);</div><div class="line">                    Event.undelegate(&#123;</div><div class="line">                        <span class="attr">element</span>: doc,</div><div class="line">                        <span class="attr">type</span>: eventType,</div><div class="line">                        <span class="attr">selector</span>: <span class="string">`[data-reactid="<span class="subst">$&#123;_rootNodeID&#125;</span>"]`</span></div><div class="line">                    &#125;);</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === <span class="string">"className"</span>) &#123;</div><div class="line">                    removed = <span class="string">"class"</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    removed = propKey;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">//  删除DOM上的相关属性</span></div><div class="line">                element.removeAttribute(removed);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//  开始遍历新属性集合</span></div><div class="line">        <span class="keyword">for</span> (propKey <span class="keyword">in</span> nextProps) &#123;</div><div class="line">            <span class="keyword">if</span> (hasOwnProperty(nextProps, propKey) &amp;&amp; propKey !== <span class="string">"children"</span>) &#123;</div><div class="line">                propValue = lastProps[propKey];</div><div class="line">              	<span class="comment">//	重新代理事件</span></div><div class="line">                <span class="keyword">if</span> (EVENT_REG.test(propKey)) &#123;</div><div class="line">                    eventType = propKey.replace(<span class="string">"on"</span>, <span class="string">""</span>);</div><div class="line">                    Event.undelegate(&#123;</div><div class="line">                        <span class="attr">element</span>: doc,</div><div class="line">                        <span class="attr">type</span>: eventType,</div><div class="line">                        <span class="attr">selector</span>: <span class="string">`[data-reactid="<span class="subst">$&#123;_rootNodeID&#125;</span>"]`</span></div><div class="line">                    &#125;);</div><div class="line">                    Event.delegate(&#123;</div><div class="line">                        <span class="attr">element</span>: doc,</div><div class="line">                        <span class="attr">type</span>: eventType,</div><div class="line">                        <span class="attr">selector</span>: <span class="string">`[data-reactid="<span class="subst">$&#123;_rootNodeID&#125;</span>"]`</span>,</div><div class="line">                        <span class="attr">handler</span>: propValue,</div><div class="line">                        <span class="attr">context</span>: <span class="literal">null</span></div><div class="line">                    &#125;);</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === <span class="string">"className"</span>) &#123;</div><div class="line">                    element.setAttribute(<span class="string">"class"</span>, propValue);</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === <span class="string">"style"</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (lodash.isObject(propValue)) &#123;</div><div class="line">                        propValue = toStyle.string(propValue);</div><div class="line">                    &#125;</div><div class="line">                    element.setAttribute(propKey, propValue);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    element.setAttribute(propKey, propValue);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     *  更新子元素</div><div class="line">     *  @param    &#123;Array&#125;  nextChildrenElements  [被更新的组件队列]</div><div class="line">     */</div><div class="line">    _updateDOMChildren(nextChildrenElements) &#123;</div><div class="line">        <span class="keyword">if</span> (nextChildrenElements &amp;&amp; nextChildrenElements.length) &#123;</div><div class="line"></div><div class="line">            update.updateDepth++;</div><div class="line">            <span class="comment">//  递归找出差别, 组装差异对象</span></div><div class="line">            update.diff(update.diffQueue, nextChildrenElements, <span class="keyword">this</span>);</div><div class="line">            update.updateDepth--;</div><div class="line"></div><div class="line">            <span class="comment">//  应用更新</span></div><div class="line">            <span class="keyword">if</span> (update.updateDepth === <span class="number">0</span>) &#123;</div><div class="line">                update.patch(update.diffQueue);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>_updateDOMChildren</code>中我们调用了<code>update.diff</code>和<code>update.patch</code>方法，一个对比一个应用，这里我是把<code>diff</code>和<code>patch</code>放到一个对象下作为一个模块暴露出去的，下面就是具体的实现代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//	定义更新类型(移动已经存在的，删除节点，插入的新标签)</span></div><div class="line"><span class="keyword">const</span> UPDATE_TYPES = &#123;</div><div class="line">    <span class="attr">MOVE_EXISTING</span>: <span class="number">1</span>,</div><div class="line">    <span class="attr">REMOVE_NODE</span>: <span class="number">2</span>,</div><div class="line">    <span class="attr">INSERT_MARKUP</span>: <span class="number">3</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> update = &#123;</div><div class="line">    <span class="comment">//  更新深度标识</span></div><div class="line">    updateDepth: <span class="number">0</span>,</div><div class="line"></div><div class="line">    <span class="comment">//  更新队列</span></div><div class="line">    diffQueue: [],</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     *  递归找出差别, 组装差异对象, 添加到更新队列diffQueue</div><div class="line">     *  @param   &#123;Array&#125;  diffQueue             [更新队列]</div><div class="line">     *  @param   &#123;Array&#125;  nextChildrenElements  [新的子组件集合]</div><div class="line">     *  @param   &#123;Object&#125; component             [被diff的组件]</div><div class="line">     *  @return  &#123;Array&#125;                        [需要更新的内容]</div><div class="line">     */</div><div class="line">    diff(diffQueue, nextChildrenElements, component) &#123;</div><div class="line">        <span class="comment">//  获取到当前组件下已经渲染的组件集合，把component._renderedChildren扁平成一个对象，如果child有key，就拿key作为对应的属性名，否则用下标做属性名，具体实现可以看下面</span></div><div class="line">        <span class="keyword">const</span> prevChildren = flattenChildren(component._renderedChildren),</div><div class="line"></div><div class="line">            <span class="comment">//  生成新的子节点的component对象集合(如果是组件有更新, 就复用原来的, 如果是新增就是新的组件实例)</span></div><div class="line">            nextChildren = generateComponentChildren(prevChildren, nextChildrenElements);</div><div class="line"></div><div class="line">        <span class="keyword">let</span> lastIndex = <span class="number">0</span>,</div><div class="line">            nextIndex = <span class="number">0</span>,</div><div class="line">            prevChild = <span class="literal">null</span>,</div><div class="line">            nextChild = <span class="literal">null</span>,</div><div class="line">            name, props, propKey, eventType;</div><div class="line"></div><div class="line">        <span class="comment">//  枚举nextChildren</span></div><div class="line">        <span class="keyword">for</span> (name <span class="keyword">in</span> nextChildren) &#123;</div><div class="line">            <span class="keyword">if</span> (!hasOwnProperty(nextChildren, name)) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            prevChild = prevChildren &amp;&amp; prevChildren[name];</div><div class="line">            nextChild = nextChildren[name];</div><div class="line"></div><div class="line">            <span class="comment">//  两个相同说明是使用的同一个component,所以我们需要做移动的操作</span></div><div class="line">            <span class="keyword">if</span> (lodash.isEqual(prevChild, nextChild)) &#123;</div><div class="line">                <span class="keyword">if</span> (prevChild._mountIndex &lt; lastIndex) &#123;</div><div class="line">                    <span class="keyword">this</span>.diffQueue.push(&#123;</div><div class="line">                        <span class="attr">parentId</span>: component._rootNodeID,</div><div class="line">                        <span class="attr">parentNode</span>: $(<span class="string">`[data-reactid="<span class="subst">$&#123;component._rootNodeID&#125;</span>"]`</span>),</div><div class="line">                        <span class="attr">type</span>: UPDATE_TYPES.MOVE_EXISTING,</div><div class="line">                      	<span class="comment">//	从组件原来的mountIndex</span></div><div class="line">                        fromIndex: prevChild._mountIndex,</div><div class="line">                      	<span class="comment">//	到nextIndex</span></div><div class="line">                        toIndex: nextIndex</div><div class="line">                    &#125;);</div><div class="line">                &#125;</div><div class="line">              </div><div class="line">              	<span class="comment">//	缓存上次遍历时最大的index</span></div><div class="line">                lastIndex = <span class="built_in">Math</span>.max(prevChild._mountIndex, lastIndex);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//  之前存在子节点, 需要先将子节点移除</span></div><div class="line">                <span class="keyword">if</span> (prevChild) &#123;</div><div class="line">                    <span class="keyword">this</span>.diffQueue.push(&#123;</div><div class="line">                        <span class="attr">parentId</span>: component._rootNodeID,</div><div class="line">                        <span class="attr">parentNode</span>: $(<span class="string">`[data-reactid="<span class="subst">$&#123;component._rootNodeID&#125;</span>"]`</span>),</div><div class="line">                        <span class="attr">type</span>: UPDATE_TYPES.REMOVE_NODE,</div><div class="line">                        <span class="attr">fromIndex</span>: prevChild._mountIndex,</div><div class="line">                        <span class="attr">toIndex</span>: <span class="literal">null</span></div><div class="line">                    &#125;);</div><div class="line">                    lastIndex = <span class="built_in">Math</span>.max(prevChild._mountIndex, lastIndex);</div><div class="line"></div><div class="line">                    props = (prevChild._currentElement &amp;&amp; prevChild._currentElement.props) ? prevChild._currentElement.props : &#123;&#125;;</div><div class="line"></div><div class="line">                  	<span class="comment">//	对移除的子节点需要进行事件代理的接触，防止重复</span></div><div class="line">                    <span class="keyword">for</span> (propKey <span class="keyword">in</span> props) &#123;</div><div class="line">                        <span class="keyword">if</span> (hasOwnProperty(props, propKey) &amp;&amp; EVENT_REG.test(propKey)) &#123;</div><div class="line">                            eventType = propKey.replace(<span class="string">"on"</span>, <span class="string">""</span>);</div><div class="line">                            Event.undelegate(&#123;</div><div class="line">                                <span class="attr">element</span>: doc,</div><div class="line">                                <span class="attr">type</span>: eventType,</div><div class="line">                                <span class="attr">selector</span>: <span class="string">`[data-reactid="<span class="subst">$&#123;prevChild._rootNodeID&#125;</span>"]`</span></div><div class="line">                            &#125;);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">//  新增的节点, 需要push到diffQueue</span></div><div class="line">                <span class="keyword">if</span> (nextChild) &#123;</div><div class="line">                    <span class="keyword">this</span>.diffQueue.push(&#123;</div><div class="line">                        <span class="attr">parentId</span>: component._rootNodeID,</div><div class="line">                        <span class="attr">parentNode</span>: $(<span class="string">`[data-reactid="<span class="subst">$&#123;component._rootNodeID&#125;</span>"]`</span>),</div><div class="line">                        <span class="attr">type</span>: UPDATE_TYPES.INSERT_MARKUP,</div><div class="line">                        <span class="attr">fromIndex</span>: <span class="literal">null</span>,</div><div class="line">                        <span class="attr">toIndex</span>: nextIndex,</div><div class="line">                        <span class="attr">markup</span>: nextChild.mountComponent(<span class="string">`<span class="subst">$&#123;component._rootNodeID&#125;</span>.<span class="subst">$&#123;name&#125;</span>`</span>)</div><div class="line">                    &#125;);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//  更新_mountIndex和nextIndex</span></div><div class="line">            nextChild._mountIndex = nextIndex;</div><div class="line">            nextIndex++;</div><div class="line"></div><div class="line">            <span class="comment">//  把nextChildren克隆一份给_renderedChildren</span></div><div class="line">            component._renderedChildren = makeArray(nextChildren);</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     *  应用更新, 执行DOM操作</div><div class="line">     *  @param   &#123;Array&#125;  updates  [差异对象集合]</div><div class="line">     */</div><div class="line">    patch(updates) &#123;</div><div class="line">        <span class="keyword">let</span> initialChildren = &#123;&#125;,</div><div class="line">            deleteChildren = [],</div><div class="line">            updatedIndex, updatedChild, parentID;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> update <span class="keyword">of</span> updates) &#123;</div><div class="line">            updatedIndex = update.fromIndex;</div><div class="line">            updatedChild = update.parentNode.children[updatedIndex];</div><div class="line">            parentID = update.parentID;</div><div class="line"></div><div class="line">            <span class="comment">//  把所有需要更新的节点都保存下来</span></div><div class="line">            initialChildren[parentID] = initialChildren[parentID] || [];</div><div class="line"></div><div class="line">            <span class="comment">//  使用parentID作为简易命名空间</span></div><div class="line">            initialChildren[parentID][updatedIndex] = updatedChild;</div><div class="line"></div><div class="line">            <span class="comment">//  所有需要修改的节点先删除,对于move的,后面再重新插入到正确的位置即可</span></div><div class="line">            <span class="keyword">if</span> (!lodash.isNull(updatedChild) &amp;&amp; !lodash.isUndefined(updatedChild)) &#123;</div><div class="line">                deleteChildren.push(updatedChild);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//  删除需要删除的节点</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> child <span class="keyword">of</span> deleteChildren) &#123;</div><div class="line">            child.parentNode.removeChild(child);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> updateItem <span class="keyword">of</span> updates) &#123;</div><div class="line">            <span class="keyword">switch</span> (updateItem.type) &#123;</div><div class="line">                <span class="comment">//  插入新元素</span></div><div class="line">                <span class="keyword">case</span> UPDATE_TYPES.INSERT_MARKUP:</div><div class="line">                    insertChildAt(updateItem.parentNode, updateItem.markup, updateItem.toIndex);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line"></div><div class="line">                    <span class="comment">//  元素位置发生改变    </span></div><div class="line">                <span class="keyword">case</span> UPDATE_TYPES.MOVE_EXISTING:</div><div class="line">                    insertChildAt(updateItem.parentNode, initialChildren[updateItem.parentID][updateItem.fromIndex], updateItem.toIndex);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line"></div><div class="line">                    <span class="comment">//  上面已经删除, 所以不需要处理</span></div><div class="line">                <span class="keyword">case</span> UPDATE_TYPES.REMOVE_NODE:</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line"></div><div class="line">                <span class="keyword">default</span>:</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//  重置相关变量</span></div><div class="line">        <span class="keyword">this</span>.reset();</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     *  重置相关变量</div><div class="line">     */</div><div class="line">    reset() &#123;</div><div class="line">        <span class="keyword">this</span>.updateDepth = <span class="number">0</span>;</div><div class="line">        <span class="keyword">this</span>.diffQueue = [];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在<code>diff</code>中，我们看到了两个新方法，分别是<code>flattenChildren</code>和<code>generateComponentChildren</code>，我们先看下<code>flattenChildren</code>的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *  把原来是数组的子组件集合转换成Map返回</div><div class="line"> *  @param   &#123;Array&#125;  componentChildren     [子组件集合]</div><div class="line"> *  @return  &#123;Object&#125;                       [输出的Map, 每个子组件的key或者一个随机数做key]</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">flattenChildren</span>(<span class="params">componentChildren</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> childrenMap = &#123;&#125;,</div><div class="line">        child, name, i, len;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, len = componentChildren.length; i &lt; len; i++) &#123;</div><div class="line">        child = componentChildren[i];</div><div class="line">        name = child &amp;&amp; child._currentelement &amp;&amp; child._currentelement.key ? child._currentelement.key : i.toString(<span class="number">36</span>);</div><div class="line">        childrenMap[name] = child;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> childrenMap;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>generateComponentChildren</code>我们大概需要完成下面几件事情：</p>
<ul>
<li>遍历拿到即将渲染的新组件<code>children</code>（做参数 <code>nextChildrenElements</code>传入）和老节点进行对比</li>
<li>如果老节点存在且和新节点有差异，即调用老节点下的<code>receiveComponent</code>去更新</li>
<li>否则如果老节点不存在，则重新调用<code>instantiateReactComponent</code>返回一个组件实例</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *  生成子节点elements的component集合</div><div class="line"> *  @param   &#123;Object&#125;  prevChildren          [flattenChildren返回的Map]</div><div class="line"> *  @param   &#123;Array&#125;   nextChildrenElements  [即将要渲染的节点]</div><div class="line"> *  @return  &#123;Object&#125;                        [子节点elements的component集合]</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateComponentChildren</span>(<span class="params">prevChildren, nextChildrenElements</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> nextChildren = &#123;&#125;,</div><div class="line">        index, len, name, prevChild, prevElement, nextElement, nextChildInstance, element;</div><div class="line">    nextChildrenElements = nextChildrenElements || [];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>, len = nextChildrenElements.length; index &lt; len; index++) &#123;</div><div class="line">        element = nextChildrenElements[index];</div><div class="line">        name = (element &amp;&amp; element.key) ? element.key : index;</div><div class="line">        prevChild = prevChildren &amp;&amp; prevChildren[name];</div><div class="line">        prevElement = prevChild &amp;&amp; prevChild._currentElement;</div><div class="line">        nextElement = element;</div><div class="line"></div><div class="line">        <span class="comment">//  组件有更新, 调用当前组件下的reciveComponent去更新组件</span></div><div class="line">        <span class="keyword">if</span> (shouldUpdateReactComponent(prevElement, nextElement)) &#123;</div><div class="line">            prevChild.receiveComponent(nextElement);</div><div class="line">            nextChildren[name] = prevChild;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//  新节点, 实例化新组件</span></div><div class="line">            nextChildInstance = instantiateReactComponent(nextElement);</div><div class="line">            nextChildren[name] = nextChildInstance;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> nextChildren;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在之前好几个地方我们都看到了<code>shouldUpdateReactComponent</code>这个方法，它完成的功能主要是判断两个<code>Vnode</code>之前是否有差异，返回布尔值，主要完成下面几件事情：</p>
<ul>
<li>如果新老<code>Vnode</code>有一个或者都为空，直接返回<code>false</code></li>
<li>文本节点之间的对比</li>
<li>当新的<code>Vnode</code>的<code>type</code>是<code>object</code>，比较老节点的<code>type</code>和<code>key</code>，并且拿到两者的<code>children</code>数组，做一个简单的长度对比</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *  判断组件是否需要更新</div><div class="line"> *  @param   &#123;Object&#125;  prevElement  [老的vnode]</div><div class="line"> *  @param   &#123;Object&#125;  nextElement  [新的vnode]</div><div class="line"> *  @return  &#123;Boolean&#125;              [标识组件是否需要更新]</div><div class="line"> */</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">shouldUpdateReactComponent</span>(<span class="params">prevElement, nextElement</span>) </span>&#123;</div><div class="line">    <span class="comment">//  排除为空的情况</span></div><div class="line">    <span class="keyword">if</span> (!lodash.isNull(prevElement) &amp;&amp; !lodash.isNull(nextElement) &amp;&amp; !lodash.isUndefined(prevElement) &amp;&amp; !lodash.isUndefined(nextElement)) &#123;</div><div class="line">        <span class="keyword">const</span> prevType = <span class="keyword">typeof</span> prevElement,</div><div class="line">            nextType = <span class="keyword">typeof</span> nextElement;</div><div class="line"></div><div class="line">        <span class="comment">//  纯文本组件</span></div><div class="line">        <span class="keyword">if</span> (prevType === <span class="string">"number"</span> || prevType === <span class="string">"string"</span>) &#123;</div><div class="line">            <span class="keyword">return</span> (nextType === <span class="string">"number"</span> || nextType === <span class="string">"number"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">let</span> prevChildren = [],</div><div class="line">                nextChildren = [],</div><div class="line">                childEqual = <span class="literal">true</span>;</div><div class="line"></div><div class="line">            <span class="keyword">if</span>(prevElement &amp;&amp; prevElement.props) &#123;</div><div class="line">                prevChildren = prevElement.props.children || [];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (nextElement &amp;&amp; nextElement.props) &#123;</div><div class="line">                nextChildren = nextElement.props.children || [];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            childEqual = prevChildren.length === nextChildren.length;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> (nextType === <span class="string">"object"</span> &amp;&amp;</div><div class="line">                (prevElement.type === nextElement.type) &amp;&amp;</div><div class="line">                (prevElement.key === nextElement.key) &amp;&amp;</div><div class="line">                childEqual);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里我们就实现一个<code>setState</code>和生命周期，在例子中实现了一个<code>Todo</code>，一起看下效果</p>
<p><img src="/imgs/todo.gif" alt="todo"></p>
<p>至此我们就实现了一个简单的<code>React</code>，但是仅仅实现了<code>虚拟节点</code>，<code>差异算法</code>，<code>props单向数据流</code>，还有很多更优秀的没实现，比如批量更新，事件优化，组件中的<code>refs</code>，服务端渲染等等，只是一个玩具，对于想深入了解<code>React</code>原理的可能会有些帮助。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前面一篇中我们用&lt;code&gt;instantiateReactComponent&lt;/code&gt;方法来根据&lt;code&gt;node&lt;/code&gt;的不同来返回不同的组件实例，之前的分类可能有些问题，就是当该组件中&lt;code&gt;JSX&lt;/code&gt;部分有返回&lt;code&gt;null&lt;/co
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
      <category term="React" scheme="http://yoursite.com/categories/javascript/React/"/>
    
    
  </entry>
  
  <entry>
    <title>从零开始写一个React - 初始化渲染</title>
    <link href="http://yoursite.com/2017/09/04/2017-09-04-write-your-own-react-1/"/>
    <id>http://yoursite.com/2017/09/04/2017-09-04-write-your-own-react-1/</id>
    <published>2017-09-03T16:00:00.000Z</published>
    <updated>2017-09-07T04:26:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道<code>React</code>组件返回的是<code>JSX</code>，而<code>JSX</code>将被<code>babel</code>转换，在<code>React</code>中是将<code>JSX</code>中转换成<code>React.createElement(type, config, children)</code>的形式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"app-container"</span>&gt;</span>App Component<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//	babel转换后输出的代码</span></div><div class="line"><span class="keyword">var</span> App = React.createClass(&#123;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span> React.createElement(<span class="string">"div"</span>, &#123;</div><div class="line">          	<span class="attr">className</span>: <span class="string">"app-container"</span></div><div class="line">        &#125;, <span class="string">"App Component"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>我们可以在<code>babel</code>中把<code>JSX</code>的<code>pragma</code>转换改成自己的函数名:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  "presets": [</div><div class="line">    "es2015"</div><div class="line">  ],</div><div class="line">  "plugins": [</div><div class="line">    ["transform-react-jsx", &#123;</div><div class="line">      "pragma":  "createElement"	//	默认的是React.createElement, 这里我们还是用默认的</div><div class="line">    &#125;]</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面一起看看<code>createElement</code>的实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> uselessProp = [<span class="string">"key"</span>, <span class="string">"ref"</span>, <span class="string">"__self"</span>, <span class="string">"__source"</span>]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, config, ...children</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> props = &#123;&#125;,</div><div class="line">        key = <span class="literal">null</span>,</div><div class="line">        ref = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">if</span> (config != <span class="literal">null</span>) &#123;</div><div class="line">        ref = lodash.isUndefined(config.ref) ? <span class="literal">null</span> : config.ref;</div><div class="line">        key = lodash.isUndefined(config.key) ? <span class="literal">null</span> : <span class="string">""</span> + config.key;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> propsName <span class="keyword">in</span> config) &#123;</div><div class="line">            <span class="keyword">if</span> (uselessProp.indexOf(propsName) === <span class="number">-1</span> &amp;&amp; hasOwnProperty(config, propsName)) &#123;</div><div class="line">                props[propsName] = config[propsName];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//  子组件</span></div><div class="line">        props.children = children;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReactElement(type, key, props, ref);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里<code>createElement</code>就是对参数进行处理，返回一个ReactElement(<code>virtual-dom</code>)，<code>ReactElement</code>返回一个<code>vnode</code>来表示一个节点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReactElement</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(type, key, props, ref) &#123;</div><div class="line">        <span class="keyword">this</span>.type = type;</div><div class="line">        <span class="keyword">this</span>.key = key;</div><div class="line">        <span class="keyword">this</span>.props = props || &#123;&#125;;</div><div class="line">        <span class="keyword">this</span>.ref = ref || &#123;&#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在返回的<code>vnode</code>中，<code>type</code>用来标识组件类型，<code>props</code>就是组件中标签上的<code>attributes</code>，<code>key</code>用作这个<code>vnode</code>的唯一标识，可用于后面的更新，现在有了<code>vnode</code>，就需要将<code>vnode</code>转换成真实的<code>DOM</code>挂载到页面上，在<code>React</code>启动的时候，是通过<code>ReactDOM.render</code>来进行渲染组件到页面，渲染就是一个递归调用<code>render</code>的过程：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">componnet, container, callback = noop</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> componentInstance = instantiateReactComponent(componnet),</div><div class="line">        markup = componentInstance.mountComponent(React.nextReactRootIndex ++);</div><div class="line">    container.innerHTML = markup;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (lodash.isFunction(callback)) &#123;</div><div class="line">        callback.call(componentInstance);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>render</code>中我们调用了一个<code>instantiateReactComponent</code>，这个函数的作用是根据<code>vnode</code>里面<code>type</code>的不同来返回不同的组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">instantiateReactComponent</span>(<span class="params">node</span>) </span>&#123;</div><div class="line">    <span class="comment">//  文本节点的情况</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> node === <span class="string">"string"</span> || <span class="keyword">typeof</span> node === <span class="string">"number"</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReactDOMTextComponent(node);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//  浏览器默认节点的情况</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> node === <span class="string">"object"</span> &amp;&amp; <span class="keyword">typeof</span> node.type === <span class="string">"string"</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReactDOMComponent(node);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//  自定义的元素节点</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> node === <span class="string">"object"</span> &amp;&amp; <span class="keyword">typeof</span> node.type === <span class="string">"function"</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReactCompositeComponent(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，<code>ReactDOMTextComponent</code>是纯文本组件，<code>ReactDOMComponent</code>是浏览器标签组件，<code>ReactCompositeComponent</code>是自定义的组件，后面的两种组件类型都属于<code>virtual-dom</code>。</p>
<p>我们接下来看看上面三个组件的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  文本组件</span></div><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ReactDOMTextComponent</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(text) &#123;</div><div class="line">        <span class="comment">//  存下当前的字符串</span></div><div class="line">        <span class="keyword">this</span>._currentElement =  (<span class="string">""</span> + text);</div><div class="line">        <span class="comment">//  组件唯一id</span></div><div class="line">        <span class="keyword">this</span>._rootNodeID = <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     *  component渲染时生成的dom结构</div><div class="line">     *  @param   &#123;String&#125;  rootID  [组件唯一id]</div><div class="line">     *  @return  &#123;String&#125;          [HTML字符串]</div><div class="line">     */</div><div class="line">    mountComponent(rootID) &#123;</div><div class="line">        <span class="keyword">this</span>._rootNodeID = rootID;</div><div class="line">		<span class="keyword">return</span> <span class="string">`&lt;!-- react-text: <span class="subst">$&#123;<span class="keyword">this</span>._rootNodeID&#125;</span> --&gt;<span class="subst">$&#123;<span class="keyword">this</span>._currentElement&#125;</span>&lt;!-- /react-text --&gt;`</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//	浏览器标签组件</span></div><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ReactDOMComponent</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(element) &#123;</div><div class="line">        <span class="comment">//  存下当前元素引用</span></div><div class="line">        <span class="keyword">this</span>._currentElement = element;</div><div class="line">        <span class="comment">//  组件唯一id</span></div><div class="line">        <span class="keyword">this</span>._rootNodeID = <span class="literal">null</span>;</div><div class="line">        <span class="comment">//  子组件集合</span></div><div class="line">        <span class="keyword">this</span>._renderedChildren = <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     *  component渲染时生成的dom结构</div><div class="line">     *  @param   &#123;String&#125;  rootID  [组件唯一id]</div><div class="line">     *  @return  &#123;String&#125;          [HTML字符串]</div><div class="line">     */</div><div class="line">    mountComponent(rootID) &#123;</div><div class="line">        <span class="keyword">this</span>._rootNodeID = rootID;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> &#123; props, type &#125; = <span class="keyword">this</span>._currentElement,</div><div class="line">            &#123; children &#125; = props,</div><div class="line">            </div><div class="line">			<span class="comment">//	判断是否为单标签</span></div><div class="line">            isSingleTag = SINGLE_TAG_REG.test(type);</div><div class="line">        <span class="keyword">let</span> tagOpen,</div><div class="line">            tagClose,</div><div class="line">            propKey, </div><div class="line">            propValue, </div><div class="line">            eventType,</div><div class="line">            childrenInstances, </div><div class="line">            childComponentInstance, </div><div class="line">            childrenMarkups, </div><div class="line">            curRootId;</div><div class="line"></div><div class="line">        tagOpen = [];</div><div class="line">        tagOpen.push(<span class="string">`&lt;<span class="subst">$&#123;type&#125;</span>`</span>, <span class="string">`data-reactid="<span class="subst">$&#123;<span class="keyword">this</span>._rootNodeID&#125;</span>"`</span>);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (propKey <span class="keyword">in</span> props) &#123;</div><div class="line">          </div><div class="line">          	<span class="comment">//	过滤掉propKey为"children"的情况</span></div><div class="line">            <span class="keyword">if</span> (hasOwnProperty(props, propKey) &amp;&amp; propKey !== <span class="string">"children"</span>) &#123;</div><div class="line"></div><div class="line">                propValue = props[propKey];</div><div class="line">                <span class="keyword">if</span> (<span class="regexp">/^on[a-z]+/i</span>.test(propKey)) &#123;</div><div class="line">                    <span class="comment">/**</span></div><div class="line">                     *  handleClick() &#123;</div><div class="line">                     *      alert("clicked");</div><div class="line">                     *  &#125;</div><div class="line">                     *  </div><div class="line">                     *  render() &#123;</div><div class="line">                     *      return (</div><div class="line">                     *          &lt;div onClick=&#123;this.handleClick&#125;&gt;click me&lt;/div&gt;</div><div class="line">                     *      );</div><div class="line">                     *  &#125;</div><div class="line">                     */</div><div class="line">                  </div><div class="line">                  	<span class="comment">//	取得事件名称并进行事件代理</span></div><div class="line">                    eventType = propKey.replace(<span class="string">"on"</span>, <span class="string">""</span>).toLowerCase();</div><div class="line">                    Event.delegate(&#123;</div><div class="line">                        <span class="attr">element</span>: doc,</div><div class="line">                        <span class="attr">type</span>: eventType,</div><div class="line">                        <span class="attr">selector</span>: <span class="string">`[data-reactid="<span class="subst">$&#123;<span class="keyword">this</span>._rootNodeID&#125;</span>"]`</span>,</div><div class="line">                        <span class="attr">handler</span>: propValue,</div><div class="line">                        <span class="attr">context</span>: <span class="literal">null</span></div><div class="line">                    &#125;);</div><div class="line"></div><div class="line">                    <span class="comment">//  <span class="doctag">TODO:</span> 实现对当前元素进行事件代理</span></div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === <span class="string">"style"</span>) &#123;</div><div class="line"></div><div class="line">                    <span class="comment">/**</span></div><div class="line">                     *  render() &#123;</div><div class="line">                     *      return (</div><div class="line">                     *          &lt;div style=&#123;"background: red;"&#125;&gt;&lt;/div&gt;</div><div class="line">                     *      );</div><div class="line">                     *  &#125;</div><div class="line">                     *</div><div class="line">                     *  -----------------------</div><div class="line">                     *</div><div class="line">                     *  render() &#123;</div><div class="line">                     *      return (</div><div class="line">                     *          &lt;div style=&#123;&#123;background: 'red'&#125;&#125;&gt;</div><div class="line">                     *          &lt;/div&gt;</div><div class="line">                     *      );</div><div class="line">                     *  &#125;</div><div class="line">                     */</div><div class="line">                    <span class="keyword">if</span> (lodash.isObject(propValue)) &#123;</div><div class="line">                      </div><div class="line">						<span class="comment">//	这里的toStyle用了一个npm包(https://www.npmjs.com/package/to-style)</span></div><div class="line">                        propValue = toStyle.string(propValue);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    tagOpen.push(<span class="string">`style="<span class="subst">$&#123;propValue&#125;</span>"`</span>);</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propValue === <span class="string">"className"</span>) &#123;</div><div class="line">                    tagOpen.push(<span class="string">`class="<span class="subst">$&#123;propValue&#125;</span>"`</span>);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    tagOpen.push(<span class="string">`<span class="subst">$&#123;propKey&#125;</span>="<span class="subst">$&#123;propValue&#125;</span>"`</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (isSingleTag) &#123;</div><div class="line">            tagOpen.push(<span class="string">"/&gt;"</span>);</div><div class="line">            tagClose = <span class="string">""</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            tagOpen.push(<span class="string">"&gt;"</span>);</div><div class="line">            tagClose = <span class="string">`&lt;/<span class="subst">$&#123;type&#125;</span>&gt;`</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        childrenMarkups = [];</div><div class="line">        childrenInstances = [];</div><div class="line">      </div><div class="line">      	<span class="comment">//	遍历子节点，实例化-&gt;渲染子节点</span></div><div class="line">        <span class="keyword">if</span> (children &amp;&amp; children.length) &#123;</div><div class="line">            children.forEach(<span class="function">(<span class="params">child, key</span>) =&gt;</span> &#123;</div><div class="line">                childComponentInstance = instantiateReactComponent(child);</div><div class="line">                childrenInstances.push(childComponentInstance);</div><div class="line">                childComponentInstance._mountIndex = key;</div><div class="line">              </div><div class="line">              	<span class="comment">//	拼一个类似于"x.y"的子节点的nodeId</span></div><div class="line">                curRootId = <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>._rootNodeID&#125;</span>.<span class="subst">$&#123;key&#125;</span>`</span>;</div><div class="line">                childrenMarkups.push(childComponentInstance.mountComponent.call(childComponentInstance, curRootId));</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">      	<span class="comment">//	将子组件的集合保留起来，留作后面更新使用</span></div><div class="line">        <span class="keyword">this</span>._renderedChildren = childrenInstances;</div><div class="line">      </div><div class="line">      	<span class="comment">//	返回组件的真实HTML结构</span></div><div class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;tagOpen.join(<span class="string">" "</span>)&#125;</span> <span class="subst">$&#123;childrenMarkups.join(<span class="string">" "</span>)&#125;</span> <span class="subst">$&#123;tagClose&#125;</span>`</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//	React自定义组件</span></div><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ReactCompositeComponent</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(element) &#123;</div><div class="line">        <span class="comment">//  存放元素element对象</span></div><div class="line">        <span class="keyword">this</span>._currentElement = element;</div><div class="line">        <span class="comment">//  存放唯一标识</span></div><div class="line">        <span class="keyword">this</span>._rootNodeID = <span class="literal">null</span>;</div><div class="line">        <span class="comment">//  存放对应的ReactClass的实例</span></div><div class="line">        <span class="keyword">this</span>._instance = <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mountComponent(rootID, hostContainerInfo, context) &#123;</div><div class="line">        <span class="keyword">this</span>._rootNodeID = rootID;</div><div class="line">        <span class="keyword">const</span> &#123; props, type &#125; = <span class="keyword">this</span>._currentElement,</div><div class="line">            ReactClass = type,</div><div class="line">            <span class="comment">//	根据vnode中的type来实例化</span></div><div class="line">            <span class="comment">//	在instantiateReactComponent中可以看到,只有当vnode的type是一个方法类型(组件的constructor)时才会返回ReactCompositeComponent</span></div><div class="line">            inst = <span class="keyword">new</span> ReactClass(props);</div><div class="line">        <span class="keyword">let</span> renderedElement, renderedComponentInstance, renderedMarkup;</div><div class="line"></div><div class="line">      	<span class="comment">//	保持对当前组件实例的引用</span></div><div class="line">        <span class="keyword">this</span>._instance = inst;</div><div class="line">        inst._reactInternalInstance = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">      	<span class="comment">//	执行生命周期中的componentWillMount</span></div><div class="line">        <span class="keyword">if</span> (lodash.isFunction(inst.componentWillMount)) &#123;</div><div class="line">            inst.componentWillMount();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">      	<span class="comment">//	调用当前组件的render</span></div><div class="line">        renderedElement = <span class="keyword">this</span>._instance.render();</div><div class="line">      </div><div class="line">      	<span class="comment">//	根据render中返回的再去执行instantiateReactComponent</span></div><div class="line">        renderedComponentInstance = instantiateReactComponent(renderedElement);</div><div class="line">        <span class="keyword">this</span>._renderedComponent = renderedComponentInstance;</div><div class="line">      </div><div class="line">      	<span class="comment">//	挂载组件</span></div><div class="line">        renderedMarkup = renderedComponentInstance.mountComponent(<span class="keyword">this</span>._rootNodeID);</div><div class="line"></div><div class="line">      	<span class="keyword">if</span> (lodash.isFunction(inst.componentDidMount)) &#123;</div><div class="line">            inst.componentDidMount();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> renderedMarkup;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    receiveComponent(nextElement, newState) &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面就是我们对三种组件的一个实现，下面我们用一个图简单表示下具体的渲染过程，第一次画图，不足之处多多包涵。</p>
<p><img src="/imgs/react-render.png" alt="渲染逻辑"></p>
<p>接下来我们需要写一个<code>Component</code>基类，去给所有的子类继承：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>() &#123;&#125;</div><div class="line"></div><div class="line">    setState(newState) &#123;</div><div class="line">        <span class="keyword">this</span>._reactInternalInstance.receiveComponent(<span class="literal">null</span>, newState);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     *  组件即将被挂载到DOM上</div><div class="line">     */</div><div class="line">    componentWillMount() &#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     *  组件已经被挂载到DOM上</div><div class="line">     */</div><div class="line">    componentDidMount() &#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     *  组件即将收到新的props</div><div class="line">     *  @param   &#123;Object&#125;  nextProps  [新的props]</div><div class="line">     *  @param   &#123;Object&#125;  nextState  [新的state]</div><div class="line">     */</div><div class="line">    componentWillReceiveProps(nextProps, nextState) &#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     *  组件是否应该更新</div><div class="line">     *  @param   &#123;Object&#125;  nextProps  [新的props]</div><div class="line">     *  @param   &#123;Object&#125;  nextState  [新的state]</div><div class="line">     *  @return  &#123;Boolean&#125;            [标记组件是否应该更新]</div><div class="line">     */</div><div class="line">    shouldComponentUpdate(nextProps, nextState) &#123;</div><div class="line">        <span class="keyword">return</span> lodash.isEqual(<span class="keyword">this</span>.state, nextState) || lodash.isEqual(<span class="keyword">this</span>.props, nextProps);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     *  组件即将更新</div><div class="line">     */</div><div class="line">    componentWillUpdate() &#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     *  组件已经更新</div><div class="line">     */</div><div class="line">    componentDidUpdate() &#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     *  组件即将被卸载</div><div class="line">     */</div><div class="line">    componentWillUnmount() &#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     *  返回组件内部的jsx</div><div class="line">     *  @return  &#123;JSX&#125;  [组件布局]</div><div class="line">     */</div><div class="line">    render() &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面我们一起根据上面的代码来完成一个初始化渲染的demo：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">"./src/react"</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputComponnet</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    keyUpHandler(ev) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">			&lt;input</div><div class="line">		        type = "text"</div><div class="line">                ref="textInput"</div><div class="line">		        placeholder = &#123; "请输入..." &#125;</div><div class="line">		        onKeyUp = &#123; this.keyUpHandler.bind(this) &#125;</div><div class="line">		        style = &#123;&#123;</div><div class="line">	                display: "block",</div><div class="line">	                width: "200px",</div><div class="line">	                height: "30px",</div><div class="line">	                fontSize: "14px",</div><div class="line">	                lineHeight: "30px"</div><div class="line">		        &#125;&#125; /&gt;</div><div class="line">    	   );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class App extends Component &#123;</div><div class="line">    constructor() &#123;</div><div class="line">        super();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    render() &#123;</div><div class="line">        return ( </div><div class="line">            &lt;div style = &#123; "background: red;" &#125; &gt;</div><div class="line">        		App Component &lt;InputComponnet placeholder = &#123; "请输入..." &#125;/&gt; </div><div class="line">        	 &lt;/div&gt;</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">React.render( &lt; App / &gt; , document.querySelector("#root"));</div></pre></td></tr></table></figure>
<p>到这里我们的初始化渲染已经完成了，我们实现了组件中的事件绑定（事件代理），简单的生命周期（<code>componentWillMout</code>， <code>componentDidMount</code>），将<code>virtual-dom</code>转换成真实的<code>DOM</code>并且挂载到页面的过程。</p>
<p><a href="https://github.com/rwson/little-react" target="_blank" rel="external">这里</a>可以查看相对完整的代码。</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a href="http://www.ahonn.me/2017/06/08/write-a-react-from-scratch-init-render/" target="_blank" rel="external">从零开始写一个 React：初始化渲染</a></li>
<li><a href="https://segmentfault.com/a/1190000010822571" target="_blank" rel="external">从0实现一个tiny react</a></li>
<li><a href="http://purplebamboo.github.io/2015/09/15/reactjs_source_analyze_part_one/" target="_blank" rel="external">reactjs源码分析-上篇</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道&lt;code&gt;React&lt;/code&gt;组件返回的是&lt;code&gt;JSX&lt;/code&gt;，而&lt;code&gt;JSX&lt;/code&gt;将被&lt;code&gt;babel&lt;/code&gt;转换，在&lt;code&gt;React&lt;/code&gt;中是将&lt;code&gt;JSX&lt;/code&gt;中转换成&lt;code&gt;Reac
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
      <category term="React" scheme="http://yoursite.com/categories/javascript/React/"/>
    
    
  </entry>
  
  <entry>
    <title>实现你自己的Promise</title>
    <link href="http://yoursite.com/2017/08/04/2017-08-04-write-your-promise/"/>
    <id>http://yoursite.com/2017/08/04/2017-08-04-write-your-promise/</id>
    <published>2017-08-03T16:00:00.000Z</published>
    <updated>2017-09-04T08:08:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>在现代化前端开发中，经常会用到<code>Promise</code>模式，<code>Promise</code>最大的好处就是可以使异步代码看起来如同步般清新易读，从而从回调地狱中解脱出来，<code>ES6</code>已经原生支持<code>Promise</code>对象，但在未支持的浏览器中还需要通过 polyfill 模拟实现。下面一起实现一个<code>Promise</code>。</p>
<p>一般我们用<code>Promise</code>会写成类似下面的样子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> ins = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">  	<span class="comment">//	...</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">ins.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</div><div class="line">  <span class="comment">//   ...</span></div><div class="line">&#125;, (ex) =&gt; &#123;&#125;);</div></pre></td></tr></table></figure>
<p>在<code>Promise</code>中一共存在三种状态，<code>PENDING</code>, <code>FULFILLED</code>,<code>REJECTED</code>，在实例化一个<code>Promise</code>后，它的状态会变成<code>PENDING</code>，执行<code>resolve</code>或者<code>reject</code>方法会把状态改成<code>FULFILLED</code>或者<code>REJECTED</code>，此过程不可逆，也就是说每个<code>Promise</code>只能调用一次<code>resolve</code>或者<code>reject</code>。</p>
<p>先来搭个骨架:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> PENDING = <span class="string">"PENDING"</span>,</div><div class="line">    FULFILLED = <span class="string">"FULFILLED"</span>,</div><div class="line">    REJECTED = <span class="string">"REJECTED"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">resolver</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!isFunction(resolver)) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"TypeError: resolver must be a function"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//	实例的值</span></div><div class="line">    <span class="keyword">this</span>.value = <span class="literal">null</span>;</div><div class="line"></div><div class="line">    <span class="comment">//	实例的状态</span></div><div class="line">    <span class="keyword">this</span>.status = PENDING;</div><div class="line"></div><div class="line">    <span class="comment">//	缓存then和catch中传入的方法</span></div><div class="line">    <span class="keyword">this</span>._doneCallbacks = [];</div><div class="line">    <span class="keyword">this</span>._failCallbacks = [];</div><div class="line"></div><div class="line">    <span class="comment">//	在执行resolver内部抛出异常, try ... catch 包裹</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        resolver(resolve.bind(<span class="keyword">this</span>), reject.bind(<span class="keyword">this</span>));</div><div class="line">    &#125; <span class="keyword">catch</span> (ex) &#123;</div><div class="line">        reject.bind(<span class="keyword">this</span>)(ex);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">Promise</span>.prototype = &#123;</div><div class="line">  <span class="attr">constructor</span>: <span class="built_in">Promise</span>,</div><div class="line">  </div><div class="line">  <span class="attr">then</span>: <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;&#125;,</div><div class="line">  </div><div class="line">  <span class="attr">catch</span>: <span class="function"><span class="keyword">function</span>(<span class="params">onRejected</span>) </span>&#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFunction</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">"function"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面实现了一个<code>Promise</code>构造器并且在它原型上声明了<code>then</code>和<code>catch</code>两个空方法，下面我们一起来实现一下<code>then</code>和<code>catch</code>两个方法, <code>Promise</code>中的<code>then</code>支持调用，所以<code>then</code>方法需要返回一个<code>Promise</code>实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.prototype = &#123;</div><div class="line">  <span class="attr">constructor</span>: <span class="built_in">Promise</span>,</div><div class="line">  </div><div class="line">  <span class="comment">//	then方法接受onFulfilled, onRejected两个回调, 并且返回一个新的Promise实例</span></div><div class="line">  then: <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</div><div class="line">    <span class="comment">//	要返回的新Promise</span></div><div class="line">    <span class="keyword">let</span> ins = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;);</div><div class="line">	<span class="keyword">if</span> (isFunction(onFulfilled)) &#123;</div><div class="line">      <span class="comment">//	将onFulfilled缓存到_doneCallbacks中</span></div><div class="line">      <span class="keyword">this</span>._doneCallbacks.push(makeCallback(ins, onFulfilled, <span class="string">"resolve"</span>));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (isFunction(onRejected)) &#123;</div><div class="line">      <span class="keyword">this</span>._failCallbacks.push(makeCallback(ins, onFulfilled, <span class="string">"reject"</span>));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ins;</div><div class="line">  &#125;,</div><div class="line">  </div><div class="line">  <span class="attr">catch</span>: <span class="function"><span class="keyword">function</span>(<span class="params">onRejected</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在实例化一个<code>Promise</code>时，我们的<code>resolver</code>有<code>resolve</code>和<code>reject</code>两个参数(也就是上面构造器中的最后)，在实例化完成后其中有一个将被立即调用，用于结束当前<code>Promise</code>。下面一起实现下<code>resolve</code>和<code>reject</code>，这两个函数完成的功能就是接受<code>resolver</code>中异步处理返回的值并且传递给<code>then</code>或者<code>catch</code>，并且将当前<code>PENDING</code>的状态改掉，刚才上面说到<code>Promise</code>的状态从<code>PENDING</code>到<code>FULFILLED</code>或者<code>REJECTED</code>是一个不可逆的过程，所以为了确保<code>resolve</code>或者<code>reject</code>不被多次调用，需要在方法开头提前判断下<code>status</code>是不是<code>PENDING</code>状态。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status !== PENDING) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">this</span>.value = data;</div><div class="line">  <span class="keyword">this</span>.status = FULFILLED;</div><div class="line">  run.call(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">ex</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status !== PENDING) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">this</span>.value = ex;</div><div class="line">  <span class="keyword">this</span>.status = REJECTED;</div><div class="line">  run.call(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>resolve</code>和<code>reject</code>中，我们都调用了<code>run</code>方法，该方法的作用是用于触发接下来的<code>Promise</code>的执行。<code>run</code>函数中需要注意的一点是，需要异步执行相关的回调函数，下面一起来实现一个<code>run</code>方法，需要注意的是每个<code>Promise</code>只能被执行一次，所以在<code>run</code>方法最后，把<code>_doneCallbacks</code>和<code>_failCallbacks</code>置空。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">//	获取到异步处理后的值, 根据当前状态获取要执行的回调</span></div><div class="line">  <span class="keyword">const</span> &#123; value &#125; = <span class="keyword">this</span>,</div><div class="line">		callbacks = <span class="keyword">this</span>.status === FULFILLED ? <span class="keyword">this</span>._doneCallbacks : <span class="keyword">this</span>._failCallbacks；</div><div class="line">  </div><div class="line">  <span class="comment">//	Promise异步执行</span></div><div class="line">  <span class="keyword">let</span> timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> fn <span class="keyword">of</span> callbacks) &#123;</div><div class="line">	  <span class="comment">//	值穿透到每个then或者catch</span></div><div class="line">      fn(value);</div><div class="line">    &#125;</div><div class="line">    clearTimeout(timeout);</div><div class="line">  &#125;);</div><div class="line">  </div><div class="line">  <span class="keyword">this</span>._doneCallbacks = [];</div><div class="line">  <span class="keyword">this</span>._failCallbacks = [];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面<code>run</code>里执行的每个<code>fn</code>都是<code>then</code>方法中<code>push</code>进<code>_doneCallbacks</code>或<code>_failCallbacks的</code>makeCallback<code>返回值，</code>makeCallback`是整个代码中比较复杂的一部分，下面一起看下具体实现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeCallback</span>(<span class="params">promise, callback, action</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">promiseCallback</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    	<span class="comment">//	callback是个函数</span></div><div class="line">        <span class="keyword">if</span> (isFunction(callback)) &#123;</div><div class="line">        	<span class="comment">//	定义个变量去接受返回值</span></div><div class="line">        	<span class="comment">//	防止抛出异常, try ... catch 包裹, catch 时直接调用reject</span></div><div class="line">            <span class="keyword">let</span> x;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                x = callback(value);</div><div class="line">            &#125; <span class="keyword">catch</span> (ex) &#123;</div><div class="line">                reject.bind(promise)(ex);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//	callback中返回的是this, 会引发死循环</span></div><div class="line">            <span class="comment">//	抛出类型异常到reject</span></div><div class="line">            <span class="comment">/**</span></div><div class="line">             * const ins = new Promise((resolve, reject) =&gt; &#123;&#125;);</div><div class="line">             * ins.then(() =&gt; &#123;</div><div class="line">             * 		return ins;</div><div class="line">             * &#125;);</div><div class="line">             */</div><div class="line">            <span class="keyword">if</span> (x === promise) &#123;</div><div class="line">                <span class="keyword">let</span> reason = <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"TypeError: The return value could not be same with the promise"</span>);</div><div class="line">                reject.bind(promise)(reason);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</div><div class="line"></div><div class="line">            	<span class="comment">//	callback中返回一个新的Promise</span></div><div class="line">            	<span class="comment">//	执行该Promise的then和catch</span></div><div class="line">            	<span class="comment">/**</span></div><div class="line">            	 * const ins = new Promise((resolve, reject) =&gt; &#123;&#125;);</div><div class="line">            	 * ins.then(() =&gt; &#123;</div><div class="line">            	 * 		return new Promise((resolve, reject) =&gt; &#123;&#125;);</div><div class="line">            	 * &#125;);</div><div class="line">            	 */</div><div class="line">                x.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</div><div class="line">                    resolve.bind(promise)(data);</div><div class="line">                &#125;, (ex) =&gt; &#123;</div><div class="line">                    reject.bind(promise)(ex);</div><div class="line">                &#125;);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">let</span> then;</div><div class="line">                (<span class="function"><span class="keyword">function</span> <span class="title">resolveThenable</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">                    <span class="comment">// 如果返回的是一个Thenable对象(Promise)</span></div><div class="line">                    <span class="keyword">if</span> (x &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">"object"</span> || isFunction(x))) &#123;</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            then = x.then;</div><div class="line">                        &#125; <span class="keyword">catch</span> (ex) &#123;</div><div class="line">                            reject.bind(promise)(ex);</div><div class="line">                            <span class="keyword">return</span>;</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        <span class="keyword">if</span> (isFunction(then)) &#123;</div><div class="line">                            <span class="comment">// 调用Thenable对象的then方法时,传递进去的resolvePromise和rejectPromise方法（及下面的两个匿名方法）</span></div><div class="line">                            <span class="comment">// 可能会被重复调用。 但Promise+规范规定这两个方法有且只能有其中的一个被调用一次,多次调用将被忽略</span></div><div class="line">                            <span class="comment">// 此处通过invoked来处理重复调用</span></div><div class="line">                            <span class="keyword">let</span> invoked = <span class="literal">false</span>;</div><div class="line">                            <span class="keyword">try</span> &#123;</div><div class="line">                                then.call( x, (y) =&gt; &#123;</div><div class="line">                                		<span class="comment">//	如果已经被调用了，直接return掉</span></div><div class="line">                                        <span class="keyword">if</span> (invoked) &#123;</div><div class="line">                                            <span class="keyword">return</span>;</div><div class="line">                                        &#125;</div><div class="line">                                        invoked = <span class="literal">true</span>;</div><div class="line"></div><div class="line">                                        <span class="comment">// 避免死循环</span></div><div class="line">                                        <span class="keyword">if</span> (y === x) &#123;</div><div class="line">                                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"TypeError: The return value could not be same with the previous thenable object"</span>);</div><div class="line">                                        &#125;</div><div class="line"></div><div class="line">                                        <span class="comment">// y仍有可能是thenable对象，递归调用</span></div><div class="line">                                        resolveThenable(y);</div><div class="line">                                    &#125;, (e) =&gt; &#123;</div><div class="line">                                        <span class="keyword">if</span> (invoked) &#123;</div><div class="line">                                            <span class="keyword">return</span>;</div><div class="line">                                        &#125;</div><div class="line">                                        invoked = <span class="literal">true</span>;</div><div class="line">                                        reject.bind(promise)(e);</div><div class="line">                                    &#125;</div><div class="line">                                );</div><div class="line">                            &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">                                <span class="comment">// 如果resolvePromise和rejectPromise方法被调用后,再抛出异常,则忽略异常</span></div><div class="line">                                <span class="comment">// 否则用异常对象reject此Promise对象</span></div><div class="line">                                <span class="keyword">if</span> (!invoked) &#123;</div><div class="line">                                    reject.bind(promise)(e);</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            resolve.bind(promise)(x);</div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        resolve.bind(promise)(x);</div><div class="line">                    &#125;</div><div class="line">                &#125;(x));</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">        	<span class="comment">//	根据action判断执行resolve或者reject</span></div><div class="line">        	action === <span class="string">"resolve"</span> ? resolve.bind(promise)(value) : reject.bind(promise)(value);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面就是我对于一个<code>Promise</code>的实现，完整代码请移步我的<a href="https://github.com/rwson/My-Promise" target="_blank" rel="external">GitHub</a></p>
<p>参考：</p>
<ul>
<li><a href="http://www.ituring.com.cn/article/66566" target="_blank" rel="external">Promises/A+规范</a></li>
<li><a href="http://bruce-xu.github.io/blogs/js/promise" target="_blank" rel="external">JS Promise的实现原理</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在现代化前端开发中，经常会用到&lt;code&gt;Promise&lt;/code&gt;模式，&lt;code&gt;Promise&lt;/code&gt;最大的好处就是可以使异步代码看起来如同步般清新易读，从而从回调地狱中解脱出来，&lt;code&gt;ES6&lt;/code&gt;已经原生支持&lt;code&gt;Promise&lt;/cod
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
      <category term="Promise" scheme="http://yoursite.com/categories/javascript/Promise/"/>
    
    
  </entry>
  
  <entry>
    <title>编写你自己的async.waterfall</title>
    <link href="http://yoursite.com/2017/05/14/2017-05-14-write-your-async.waterfall/"/>
    <id>http://yoursite.com/2017/05/14/2017-05-14-write-your-async.waterfall/</id>
    <published>2017-05-13T16:00:00.000Z</published>
    <updated>2017-06-14T08:43:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>在早期的异步开发中，如果有一些异步任务需要处理，难免会遇到回调地狱，为了解决这种问题，也出现过很多第三方库来避免，其中<a href="[https://caolan.github.io/async/]">async.js</a>就是比较有名的一个，里面有个<code>waterfall</code>方法，本文我们一起来模拟实现一个类似的</p>
<p>先来看下调用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">waterfall([</div><div class="line">	<span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>);</div><div class="line">		setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">			cb(<span class="literal">null</span>, <span class="number">123</span>);</div><div class="line">		&#125;, <span class="number">2000</span>);</div><div class="line">	&#125;,</div><div class="line">	<span class="function"><span class="keyword">function</span>(<span class="params">arg, cb</span>) </span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>);</div><div class="line">		setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">			<span class="built_in">console</span>.log(arg);</div><div class="line">			cb(<span class="literal">null</span>, <span class="number">123</span>, <span class="number">456</span>);</div><div class="line">		&#125;, <span class="number">2000</span>);</div><div class="line">	&#125;,</div><div class="line">	<span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2, cb</span>) </span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>);</div><div class="line">		<span class="built_in">console</span>.log(arg1, arg2);</div><div class="line">	&#125;</div><div class="line">], <span class="function"><span class="keyword">function</span>(<span class="params">ex</span>) </span>&#123;</div><div class="line">	<span class="keyword">if</span> (ex) &#123;</div><div class="line">		<span class="keyword">throw</span> ex;</div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>下面我们一起来看下实现下<code>waterfall</code>这个方法 : </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * @param task 任务队列</div><div class="line"> * @param callback 最后的回调</div><div class="line"> **/</div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">task = [], callback = noop</span>) </span>&#123;</div><div class="line">  	<span class="comment">//	类型判断</span></div><div class="line">    <span class="keyword">if</span> (!(task <span class="keyword">instanceof</span> <span class="built_in">Array</span>)) &#123;</div><div class="line">        <span class="keyword">return</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"task should be an array!"</span>));</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">  </div><div class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">...args</span>) </span>&#123;</div><div class="line">        <span class="comment">//  第一个参数如果不为空就直接执行callback</span></div><div class="line">        <span class="keyword">if</span> (args[<span class="number">0</span>]) &#123;</div><div class="line">            <span class="keyword">return</span> callback(args[<span class="number">0</span>]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (task.length) &#123;</div><div class="line">            <span class="comment">//  取得当前要执行的函数</span></div><div class="line">            <span class="keyword">let</span> fn = task.shift();</div><div class="line">          	<span class="comment">//	第一个参数是error相关的,所以从第二个开始截取</span></div><div class="line">            fn.apply(<span class="literal">null</span>, [...args.slice(<span class="number">1</span>), onlyOnce(next)]);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            callback.apply(<span class="literal">null</span>, args);</div><div class="line">        &#125;</div><div class="line">    &#125;)();</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 包装一个函数确保它只被执行一次</div><div class="line"> **/</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onlyOnce</span>(<span class="params">cb</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> flag = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (flag) &#123;</div><div class="line">            <span class="keyword">return</span> cb(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'cb already called'</span>));</div><div class="line">        &#125;</div><div class="line">        cb.apply(<span class="literal">null</span>, args);</div><div class="line">        flag = <span class="literal">true</span>;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">noop</span>(<span class="params"></span>) </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>上面就是对<code>waterfall</code>方法的实现，在<a href="[https://caolan.github.io/async/]">async.js</a>还有很多其他很有用的方法，后面有机会继续模拟实现。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在早期的异步开发中，如果有一些异步任务需要处理，难免会遇到回调地狱，为了解决这种问题，也出现过很多第三方库来避免，其中&lt;a href=&quot;[https://caolan.github.io/async/]&quot;&gt;async.js&lt;/a&gt;就是比较有名的一个，里面有个&lt;code&gt;wa
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
      <category term="异步流控制" scheme="http://yoursite.com/categories/javascript/%E5%BC%82%E6%AD%A5%E6%B5%81%E6%8E%A7%E5%88%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>实现一个new函数</title>
    <link href="http://yoursite.com/2017/04/20/2017-04-20-write-a-new-operator/"/>
    <id>http://yoursite.com/2017/04/20/2017-04-20-write-a-new-operator/</id>
    <published>2017-04-19T16:00:00.000Z</published>
    <updated>2017-09-25T02:50:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>在日常javaScript开发中，我们多多少少都会用到<code>new</code>，最常见的比如<code>new Date</code>等等，在一些<code>js</code>面向对象中，用到<code>new</code>的地方更多了，比如我们通过<code>function</code>来模拟声明一个类，需要实例化的时候就需要用<code>new xxx()</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Class</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//	...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> inst = <span class="keyword">new</span> Class();</div></pre></td></tr></table></figure>
<p>在<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="external">MDN</a>上对在执行了<code>new</code>之后的介绍如下:</p>
<ul>
<li>一个新对象被创建。它继承自<code>*foo*.prototype</code></li>
<li>构造函数 <code>*foo*</code> 被执行。执行的时候，相应的传参会被传入，同时上下文(<code>this)会被指定为这个新实例。``new *foo*</code> 等同于 <code>new *foo*()</code>, 只能用在不传递任何参数的情况。</li>
<li>如果构造函数返回了一个“对象”，那么这个对象会取代整个<code>new</code>出来的结果。如果构造函数没有返回对象，那么<code>new</code>出来的结果为步骤1创建的对象。(一般情况下构造函数不返回任何值，不过用户如果想覆盖这个返回值，可以自己选择返回一个普通对象来覆盖。当然，返回数组也会覆盖，因为数组也是对象。)</li>
</ul>
<p>在知道了<code>new</code>之后发生的事情，我们的<code>_new</code>函数就可以按照上面的几个步骤来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  		<span class="comment">//	获取到所有参数</span></div><div class="line">	<span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>),</div><div class="line">        <span class="comment">//	创建一个空对象</span></div><div class="line">		obj = <span class="built_in">Object</span>.create(&#123;&#125;),</div><div class="line">        <span class="comment">//	把第一个参数作为构造器</span></div><div class="line">		Constructor = args[<span class="number">0</span>],</div><div class="line">		res;</div><div class="line">  	<span class="comment">//	继承构造器下的原型</span></div><div class="line">	obj.__proto__ = args[<span class="number">0</span>].prototype;</div><div class="line">  	<span class="comment">//	执行构造器，并传入相关参数</span></div><div class="line">	res = Constructor.apply(obj, args.slice(<span class="number">1</span>));</div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是第一版，我们把构造器的执行结果作为返回值返回出去，下面我们一起写个模拟类测试下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Class</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">	<span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Class.prototype = &#123;</div><div class="line">	<span class="attr">constructor</span>: Class,</div><div class="line">	<span class="attr">method</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">"I'm method under Class.prototype"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> inst = _new(Class, <span class="string">"rwson"</span>, <span class="number">24</span>);</div><div class="line">inst.method();</div><div class="line"><span class="built_in">console</span>.log(inst);</div></pre></td></tr></table></figure>
<p>可以看到在控制台打出的类似下图的东西</p>
<p><img src="/imgs/new-1.png" alt="new-1"></p>
<p>我们现在实现了一个版本，只是把在<code>_new</code>方法中的<code>obj</code>对象返回出来了，刚才上面第三步骤说到，<code>如果构造函数返回了一个“对象”，那么这个对象会取代整个</code>new<code>出来的结果。如果构造函数没有返回对象，那么</code>new<code>出来的结果为步骤1创建的对象。(一般情况下构造函数不返回任何值，不过用户如果想覆盖这个返回值，可以自己选择返回一个普通对象来覆盖。当然，返回数组也会覆盖，因为数组也是对象。)</code>，针对构造函数有返回值的情况，我们需要把该返回值返回，下面我们把之前的代码改改，以适配有返回值的情况：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>),</div><div class="line">		obj = <span class="built_in">Object</span>.create(&#123;&#125;),</div><div class="line">		Constructor = args[<span class="number">0</span>],</div><div class="line">		res;</div><div class="line">	obj.__proto__ = args[<span class="number">0</span>].prototype;</div><div class="line">	res = Constructor.apply(obj, args.slice(<span class="number">1</span>));</div><div class="line">  </div><div class="line">  	<span class="comment">//	判断Constructor的返回值类型</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> res === <span class="string">"object"</span> ? res : obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样我们写个类做测试</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Class</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">	<span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">       <span class="attr">name</span>: name,</div><div class="line">       <span class="attr">age</span>: age</div><div class="line">	&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> inst = _new(Class, <span class="string">"rwson"</span>, <span class="number">24</span>);</div><div class="line"><span class="built_in">console</span>.log(inst);</div></pre></td></tr></table></figure>
<p>观察在控制台的输出应该和下面的类似：</p>
<p><img src="/imgs/new-2.png" alt="new-2"></p>
<p>到这里我们的<code>_new</code>方法就实现了，但是由于<code>Object.create</code>的原因，在<code>IE9-</code>的版本中可能不太支持，所以我们需要把<code>Object.create</code>改成<code>new Object</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>),</div><div class="line">		obj = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;&#125;),</div><div class="line">		Constructor = args[<span class="number">0</span>],</div><div class="line">		res;</div><div class="line">	obj.__proto__ = args[<span class="number">0</span>].prototype;</div><div class="line">	res = Constructor.apply(obj, args.slice(<span class="number">1</span>));</div><div class="line">  </div><div class="line">  	<span class="comment">//	判断Constructor的返回值类型</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> res === <span class="string">"object"</span> ? res : obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在日常javaScript开发中，我们多多少少都会用到&lt;code&gt;new&lt;/code&gt;，最常见的比如&lt;code&gt;new Date&lt;/code&gt;等等，在一些&lt;code&gt;js&lt;/code&gt;面向对象中，用到&lt;code&gt;new&lt;/code&gt;的地方更多了，比如我们通过&lt;code&gt;fu
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
      <category term="new操作符" scheme="http://yoursite.com/categories/javascript/new%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>NodeJs读取windows注册表来对软件进行卸载</title>
    <link href="http://yoursite.com/2017/03/29/2017-03-29-node-read-regedit-uninstall-software/"/>
    <id>http://yoursite.com/2017/03/29/2017-03-29-node-read-regedit-uninstall-software/</id>
    <published>2017-03-28T16:00:00.000Z</published>
    <updated>2017-03-30T13:28:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在基于node-webkit(以下简称NW)开发windows桌面app,里面有个类似于软件市场的功能,后台管理员提供一些软件,可以从该app上进行下载、安装、卸载、升级等等。</p>
<p>安装或升级可以直接通过把下载好的zip包解压出来然后执行里面的exe程序安装就好,但是卸载相对来说比较麻烦,几乎每个第三方exe在安装后的目录里面都有一个uninstall.exe,但是我们不知道这个软件具体安装在哪,所以要卸载也无从下手,这时候就想到了注册表,通过注册表可以获取到某个软件的安装目录,所以可以先把当前注册表的目录取得,再去相应目录下找卸载该软件的那个exe并执行。</p>
<p>由于NW是基于nodejs的,所以可以通过一些第三方的npm包来操作,在这里主要主要用到的包是<a href="https://github.com/fresc81/node-winreg" target="_blank" rel="external">winreg</a>,首先我们先分析下注册表:</p>
<p><img src="/imgs/regedit-nalysis.png" alt="注册表分析"></p>
<p>可以看到根下面有5个大项(HKEY_CLASSES_ROOT、HKEY_CURRENT_USER、HKEY_LOCAL_MACHINE、HKEY_USERS、HKEY_CURRENT_CONFIG),第三方软件基本上都是在HKEY_LOCAL_MACHINE下面的,所以读取的时候就从HKEY_LOCAL_MACHINE下面开始找,这里以搜狗输入法为例:</p>
<p><img src="/imgs/sogouinput.png" alt="搜狗输入法分析"></p>
<p>从上图中看到该项的全路径为”HKEY_LOCAL_MACHINE\SOFTWARE\SogouInput”,注册项里的第一项就是安装路径,对应的名称是默认,所以我们读取的时候从就可以读取刚才的那个路径,下面是主要的实现:</p>
<pre><code>const Registry = require(&quot;winreg&quot;),
    child_process = require(&quot;child_process&quot;),
    path = require(&quot;path&quot;),
    key = new Registry({
        //  打开HKEY_LOCAL_MACHINE这个大类
        //  一共有5个属性,分别是&apos;HKLM&apos;, &apos;HKCU&apos;, &apos;HKCR&apos;, &apos;HKU&apos;, &apos;HKCC&apos;
        //  就是上面那5大项的简称
        hive: Registry.HKLM,
        //  反斜杠前面需要加&quot;\&quot;进行转义
        key: &quot;\\SOFTWARE\\SogouInput&quot;
    });

let pre, end, cur, target;

//  获取到注册项中中所有配置项,以键值对的形式返回
//  每一小项分别包含(host、hive、key、name、type、value、arch)这几个属性
key.values((err, res) =&gt; {
    if (err) {
        console.log(err);
    } else {
        for(var i in res) {
            cur = res[i];
            //  判断当前项的名称是否包含default或者version
            if (/default/gi.test(cur.name)) {
                pre = cur.value;
            } else if (/^version$/gi.test(cur.name)) {
                end = cur.value;
            }
        }

        //  拼接软件的安装全路径
        target = `${pre}\\${end}`;

        //  结合nodejs中子进程模块中的execFile方法执行卸载的exe
        child_process.execFile(path.join(target, &quot;Uninstall.exe&quot;), (err, res) =&gt; {
            if (err) {
                console.log(&quot;卸载失败,请重试!&quot;);
            }
        });
    }
});
</code></pre><p>最后执行写好的js文件,就会顺利打开相关卸载窗口:</p>
<p><img src="/imgs/uninstall-screenshoot.png" alt="卸载窗口"></p>
<p>当然这只是一个简单的实现,是分析好了软件安装目录下的卸载文件在什么地方去调用它的,肯定不能应用于所有场景,应该遍历该软件安装的根目录和子目录搜索卸载程序所在的最终目录来执行并进行卸载。</p>
<h5 id="记在2017-03-30"><a href="#记在2017-03-30" class="headerlink" title="记在2017-03-30"></a>记在2017-03-30</h5><p>今天尝试用昨天的写法来实现软件卸载,发现实现起来并不是那么简单,而且遍历文件的话面临一个性能问题,层级一多,递归循环就可能导致需要等好久才能开始卸载,所以又深入研究了下注册表,真是得来全不费工夫,注册表里面就给我们提供了某个软件的卸载路径,具体位置在</p>
<pre><code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\
</code></pre><p>这边都是我们安装的所有软件,需要注意的是在64位系统中该路径有所不同,大问题解决了,我们又面临一个其他问题,就是有些软件在安装后,卸载那一级的最后一层并不是它自己的名字,而是一串花括号开始花括号结尾的字符串,类似于下图所示:</p>
<p><img src="/imgs/uninstall-id.png" alt="卸载id"></p>
<p>于是又在好几种不同版本的windows电脑上进行尝试,发现这个id始终是唯一的,最后和需求商量决定后台管理员在提供软件的时候把这个id也带上,这样就解决了问题,这样唯一的不好就是后台管理员的工作可能会稍微繁琐点。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在基于node-webkit(以下简称NW)开发windows桌面app,里面有个类似于软件市场的功能,后台管理员提供一些软件,可以从该app上进行下载、安装、卸载、升级等等。&lt;/p&gt;
&lt;p&gt;安装或升级可以直接通过把下载好的zip包解压出来然后执行里面的exe程序安装就
    
    </summary>
    
      <category term="nodejs" scheme="http://yoursite.com/categories/nodejs/"/>
    
      <category term="桌面exe" scheme="http://yoursite.com/categories/nodejs/%E6%A1%8C%E9%9D%A2exe/"/>
    
    
  </entry>
  
  <entry>
    <title>decorator的学习</title>
    <link href="http://yoursite.com/2017/02/17/2017-02-17-es7-decorator-tourial/"/>
    <id>http://yoursite.com/2017/02/17/2017-02-17-es7-decorator-tourial/</id>
    <published>2017-02-16T16:00:00.000Z</published>
    <updated>2017-02-17T12:44:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>随着前端技术的发展,越来越多人把ES6、7用在日常开发中,在ES7中除了广为人知的async/await之外,还有一大特性 — decorator(装饰器)。</p>
<p>在之前原生javascript设计模式中的一篇文章(<a href="http://rwson.github.io/2015/07/15/2015-07-15-js-design-mode-decorator/" target="_blank" rel="external">javascript装饰者模式</a>)中说道: js装饰者模式可以把一个对象(类/函数)透明地包装在另外一个对象上,完成对被装饰者添加一些新功能的作用。简单的说我们可以在不修改类/函数内部代码的情况下,来达到给类/函数加入一些新功能。</p>
<p>装饰器可以作用于类或者类的成员属性/方法上,下面我们通过两段代码来分别解释:</p>
<pre><code>//  作用于类

/**
 * 需求:
 * 封装4个方法,分别实现加减乘除四个功能
 * 通过装饰器给类添加这四个方法,并且可指定是否作为类的静态方法添加
 **/

//  加减乘除的实现

function add() {
    return [].slice.call(arguments).reduce((a, b) =&gt; a + b);
}

function reduce() {
    return [].slice.call(arguments).reduce((a, b) =&gt; a - b);
}

function mul() {
    return [].slice.call(arguments).reduce((a, b) =&gt; a * b);
}

function div() {
    return [].slice.call(arguments).reduce((a, b) =&gt; a / b);
}


@bindCal(add, true)
@bindCal(reduce, true)
@bindCal(mul, false)
@bindCal(div, false)
class MyMath {

}
</code></pre><p>上面我们完成了需求中的四个函数的封装以及对MyMath类应用了装饰器,下面我们就来实现这个装饰器:</p>
<pre><code>/**
 * @param    {Function}   method    指向需要被添加方法的指针
 * @param    {String}     isStatic  是否添加为静态属性,默认为true
 * @return   {Function}
 */
function bindCal(method, isStatic = true) {
    //  获取到方法名
    const {name} = method;
    //  当作用于类上时,会返回一个匿名函数,将类的构造函数作为第一个参数
    return function(target) {
        //  获取类的原型
        const {prototype} = target;
        //  添加为原型属性(非静态属性)
        if (!isStatic) {
            //  检测要添加的属性是否存在
            if (prototype[name]) {
                throw `${prototype.name}.${name} already exits!`;
            } else {
                //  利用ES5中的Object.defineProperty来添加相关属性
                Object.defineProperty(target.prototype, name, {
                    value: method
                });
            }
        } else {
            //  添加为静态属性
            //  检测要添加的属性是否存在
            if (target[name]) {
                throw `${target}.${name} already exits!`;
            }
            //  利用ES5中的Object.defineProperty来添加相关属性
            Object.defineProperty(target, name, {
                value: method
            });
        }
        //  返回类的构造器
        return target;
    }
}
</code></pre><p>我们把add和reduce作为静态方法添加给MyMath类,把mul和div作为原型方法给了MyMath类,所以调用应该看起来像下面的样子:</p>
<pre><code>const math = new MyMath();

console.log(MyMath.add(1, 2, 3, 4));        //  10
console.log(MyMath.reduce(1, 2, 3, 4));     //  -8


console.log(math.mul(1, 2, 3, 4));          //  24
console.log(math.div(10000, 1000, 10, 5));  //  0.2
</code></pre><p>上面就是我们在类上应用装饰器的一个例子,下面再一起看下如果在成员属性/方法上应用构造器的例子:</p>
<pre><code>/**
 * 需求:
 * 实现在类中可以冻结成员属性(外部无法修改,只读)
 * 实现修改类中成员方法中的this指向
 **/


//  实现一个类,并且对其成员属性/方法应用装饰器、定义一个对象,作为成员方法中的this指向


const obj = {
    name: &quot;rwson&quot;,
    age: 24,
    sex: &quot;male&quot;,
    job: &quot;web developer&quot;
};

class Context {

    constructor() {

    }

    @readonly
    version = &quot;1.0.0&quot;;

    @bindContext(obj)
    showContext() {
        console.log(this);
    }

} 
</code></pre><p>上面我们完成了对装饰器应用过程,下面一起看下readonly和bindContext两个装饰器的实现:</p>
<pre><code>/**
 * @param    {Object}   target    当前类的prototype
 * @param    {String}   key       将要被装饰的属性名
 * @param    {Object}   decorator ES5中Object.defineProperty的最后一个参数
 * @return   {Object}   decorator
 */
function readonly(target, key, decorator) {
    decorator.configurable = false;
    decorator.enumerable = false;
    decorator.writable = false;
    decorator.value = decorator.value;
    return decorator;
}

/**
 * @param    {Object}   context    需要绑定成this的对象
 * @return   {Function}
 */
function bindContext(context) {
    /**
     * @param    {Object}   target    当前类的prototype
     * @param    {String}   key       将要被装饰的属性名
     * @param    {Object}   decorator ES5中Object.defineProperty的最后一个参数
     * @return   {Object}   decorator
     */
    return function(target, key, decorator) {
        if (typeof context === &quot;undefined&quot;) {
            context = target;
        }
        decorator.value = decorator.value.bind(context);
        return decorator;
    }
}
</code></pre><p>好了上面就是我们的两个作用于成员属性/方法上的装饰器,下面一起来看下简单的调用吧:</p>
<pre><code>const context = new Context();

context.showContext();          //  打印出刚才定义的obj对象
context.version = &quot;1.1.0&quot;;      //  抛出异常 Uncaught TypeError: Cannot assign to read only property &apos;version&apos; of object &apos;#&lt;Context&gt;&apos;
</code></pre><p>好了,上面就装饰器的几种用法和实现,我们可能会发现刚才在定义装饰器函数的时候,当该装饰器作用于类上的时候返回出的匿名函数都是一个参数;而作用于成员属性或者成员方法上的,都是三个参数,这又是为啥呢?</p>
<p>一起来分析下编译后的代码:</p>
<pre><code>/**
 * @param    {Object}               target     当前类的prototype
 * @param    {String}               property   将要被装饰的属性名
 * @param    {Array.&lt;Function&gt;}       decorators 装饰器函数列表
 * @param    {Object}               descriptor ES5中Object.defineProperty的最后一个参数
 * @param    {[type]}   context    [description]
 * @return   {[type]}              [description]
 * @private
 */
function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {

    //    属性对象
    var desc = {};

    //    Object[&quot;keys&quot;]    -&gt; [&quot;value&quot;, &quot;writable&quot;, &quot;enumerable&quot;, &quot;configurable&quot;]
    //    把ES5中Object.defineProperty的最后一个参数的属性变成外部指定的
    Object[&apos;ke&apos; + &apos;ys&apos;](descriptor).forEach(function (key) {
        desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;

    if (&apos;value&apos; in desc || desc.initializer) {
        desc.writable = true;
    }

    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
        return decorator(target, property, desc) || desc;
    }, desc);

    if (context &amp;&amp; desc.initializer !== void 0) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = undefined;
    }

    //    利用Object.defineProperty定义属性
    if (desc.initializer === void 0) {
        Object[&apos;define&apos; + &apos;Property&apos;](target, property, desc);
        desc = null;
    }

    //    返回当前属性对象
    return desc;
}
</code></pre><p>可以看出其实decorator最后也是通过Object.defineProperty实现的,所以参数和Object.defineProperty是一致的。</p>
<p>那日常开发中,我们可能需要借助babel来对带有decorator的代码进行编译,首先我们需要安装babel:</p>
<pre><code>npm install babel -g
</code></pre><p>然后切换到项目目录运行:</p>
<pre><code>npm install babel-plugin-transform-decorators-legacy --save-dev
</code></pre><p>然后创建.babelrc配置文件,在plugins选项中添加以下配置:</p>
<pre><code>//  ...
&quot;plugins&quot;: [
    &quot;transform-decorators-legacy&quot;
]
//  ...
</code></pre><p>最后我们就可以编译之前写的代码了:</p>
<pre><code>babel decorator.js &gt; decorator.es5.js
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着前端技术的发展,越来越多人把ES6、7用在日常开发中,在ES7中除了广为人知的async/await之外,还有一大特性 — decorator(装饰器)。&lt;/p&gt;
&lt;p&gt;在之前原生javascript设计模式中的一篇文章(&lt;a href=&quot;http://rwson.gi
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
      <category term="ES7" scheme="http://yoursite.com/categories/javascript/ES7/"/>
    
      <category term="decorator" scheme="http://yoursite.com/categories/javascript/ES7/decorator/"/>
    
    
  </entry>
  
  <entry>
    <title>实现一个拷贝文件夹以及文件夹下所有文件的方法</title>
    <link href="http://yoursite.com/2017/01/20/2017-01-20-copy-a-directory-and-files-under-it/"/>
    <id>http://yoursite.com/2017/01/20/2017-01-20-copy-a-directory-and-files-under-it/</id>
    <published>2017-01-19T16:00:00.000Z</published>
    <updated>2017-03-30T12:19:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>实现这个方法依赖了<a href="https://www.npmjs.com/package/fs-extra" target="_blank" rel="external">fs-extra</a>模块,实现目的是为了一个方法拷贝所有当前目录下所有文件,具体实现如下:</p>
<pre><code>let fs = require(&quot;fs-extra&quot;);

/**
 * 批量拷贝文件
 * @param src           源目录          String
 * @param target        目标目录        String
 * @param filetypes     文件类型        RegExp
 * @param ignorefiles   忽略文件列表    Array
 **/
fs.copyAllFiles = (src, target, filetypes, ignorefiles) =&gt; {
    let argus = arguments,
        readSrc = src,
        targetSrc = target,
        fileSrc, targeFileSrc;

    fs.readdir(readSrc, (ex, files) =&gt; {
        if (files.length) {
            files.forEach((file) =&gt; {

                //  当前文件不在忽略列表中
                if (!(~ignoreFiles.indexOf(file))) {
                    fileSrc = path.resolve(readSrc, file);
                    if (filetypes.test(file)) {
                        targeFileSrc = path.resolve(targetSrc, file);
                        fs.copySync(fileSrc, targeFileSrc);
                    } else {
                        targeFileSrc = path.resolve(targetSrc, file);
                        fs.copySync(fileSrc, targeFileSrc);
                        //  递归拷贝下一级目录
                        fs.copyAllFiles.call(fileSrc, targeFileSrc, filetypes, ignorefiles);
                    }
                }
            });
        }
    });
};
</code></pre><p>上面的就是要实现的方法,调用的方法就看起来像下面的样子:</p>
<pre><code>const ignoreFiles = [&quot;.DS_Store&quot;, &quot;.idea&quot;, &quot;.git&quot;, &quot;.svn&quot;];
fs.copyAllFiles(&quot;a&quot;, &quot;b&quot;, /\.jpe?g|\.png/, ignoreFiles);
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实现这个方法依赖了&lt;a href=&quot;https://www.npmjs.com/package/fs-extra&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;fs-extra&lt;/a&gt;模块,实现目的是为了一个方法拷贝所有当前目录下所有文件,具体实现如下:&lt;
    
    </summary>
    
      <category term="nodejs" scheme="http://yoursite.com/categories/nodejs/"/>
    
      <category term="文件操作" scheme="http://yoursite.com/categories/nodejs/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>实现一个webpack loader</title>
    <link href="http://yoursite.com/2017/01/18/2017-01-18-wrire-a-webpack-loader/"/>
    <id>http://yoursite.com/2017/01/18/2017-01-18-wrire-a-webpack-loader/</id>
    <published>2017-01-17T16:00:00.000Z</published>
    <updated>2017-03-30T12:19:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>在React,ES6开发模式越来越普及的今天,webpack就成了前端构建的一个标配。webpack有两大重要部分组成: loader和plugin。loader是用在应用源码上的转换原件,比如最常用到的babel-loader/jsx-loader/file-loader/css-loader/url-loader等等。</p>
<p>loader可链式执行,一种文件类型可以用多个loader(比如css文件,可能就需要用到css-loader和style-loader),loader之间用”!”分隔,当前loader处理完,把处理结果带到下一个loader,最后一个loader返回一个String或者String Buffer返回给compiler。</p>
<p>loader调用方式大体有3种形式:</p>
<ol>
<li><p>引用时调用</p>
<pre><code>//  a.js

require(&quot;style-loader/url!css-loader!./xxx.css&quot;);
</code></pre></li>
<li><p>webpack直接调用</p>
<pre><code>//  webpack.config.js

//  ...

module: {
    loaders: [
        //  ...

        {
            test: /\.css$/,
            loader: &quot;style-loader!css-loader&quot;
        }
    ]
}
</code></pre></li>
<li><p>指定loaders数组</p>
<pre><code>//  webpack.config.js

//  ...

module: {
    loaders: [
        //  ...

        {
            test: /\.css$/,
            loaders: [
                &quot;style-loader&quot;,
                &quot;css-loader&quot;
            ]
        }
    ]
}
</code></pre></li>
</ol>
<p>webpack官网上说”A loader is a node module exporting a function”,也就是说一个loader就是一个暴露出去的node模块,既然是一个node module,也就基本可以写成下面的样子:</p>
<pre><code>module.exports = function() {

    //  ...
};
</code></pre><p>需要注意的是,在该模块被调用时,传入的第一个参数是文件的内容,所以我们可以再改改:</p>
<pre><code>/**
 * @param content  将被处理的内容
 *
 **/
module.exports = function(content) {

    //  ...

    //  运行下一个loader
    this.callback(content);
};
</code></pre><p>知道了大体写法,现在我们就来实现一个简单的loader,主要功能就是把css中的px单位转换成rem单位</p>
<pre><code>//  px2rem-loader/index.js

&quot;use strict&quot;;

//  用来获取调用loader时传入的参数等等
var loaderUtils = require(&quot;loader-utils&quot;);

//  css解析模块
var css = require(&quot;css&quot;);

//  乘除模块,防止在计算中出现精度丢失的问题
var privateMath = {

    mul: function(num1, num2) {
        var m = 0,
            s1 = num1.toString(),
            s2 = num2.toString();
        try {
            m += s1.split(&quot;.&quot;)[1].length
        } catch (e) {}
        try {
            m += s2.split(&quot;.&quot;)[1].length
        } catch (e) {}
        return Number(s1.replace(&quot;.&quot;, &quot;&quot;)) * Number(s2.replace(&quot;.&quot;, &quot;&quot;)) / Math.pow(10, m);
    },
    div: function(num1, num2) {
        var t1, t2, r1, r2;
        try {
            t1 = num1.toString().split(&apos;.&apos;)[1].length;
        } catch (e) {
            t1 = 0;
        }
        try {
            t2 = num2.toString().split(&quot;.&quot;)[1].length;
        } catch (e) {
            t2 = 0;
        }
        r1 = Number(num1.toString().replace(&quot;.&quot;, &quot;&quot;));
        r2 = Number(num2.toString().replace(&quot;.&quot;, &quot;&quot;));
        return (r1 / r2) * Math.pow(10, t2 - t1);
    }
};

module.exports = function(content) {

    //  把当成css内容解析成AST对象
    var contentAST = css.parse(content);

    //  使用loader时的queryString(相关参数)
    var query = loaderUtils.parseQuery(this.query);

    //  最小px值,当数组小于它是忽略计算
    var minSize = query.minSize || 1;

    //  基数(最后计算出的结果 = (原先的大小 / base / scale) + &quot;rem&quot;)
    var base = query.base || 37.5;

    //  忽略的样式规则名称
    var ignore = query.ignore.length ? query.ignore.split(&quot;|&quot;) : [];

    //  缩放比
    var scale = query.scale || 1;

    //  匹配10px或者10.5px这种单位
    var pxUnitReg = /\d+[\.{1}\d+]?px/gi;

    var tmp;

    //  遍历样式树
    contentAST.stylesheet.rules.forEach(function(rule) {
        //  遍历样式表
        rule.declarations.forEach(function(style) {
            if (ignore.indexOf(style.property) &lt; 0) {
                style.value = style.value.replace(pxUnitReg, function(match) {
                    tmp = parseFloat(match);
                    if(tmp &gt; minSize) {
                        return privateMath.div(tmp, privateMath.mul(base, scale)) + &quot;rem&quot;;
                    }
                });
            }
        });
    });


    //  再把处理好的AST对象转成css String
    content = css.stringify(contentAST);

    //  调用下一个loader
    this.callback(null, content);

};
</code></pre><p>到这里,一个简单的load就算实现了,一起来看下调用把:</p>
<pre><code>//  webpack.config.js
const webpack = require(&quot;webpack&quot;);

module.exports = {
    entry: &quot;./src/js/entry.js&quot;,
    output: {
        path: __dirname,
        filename: &quot;build/bundle.js&quot;
    },
    module: {
        loaders: [{
            test: /\.js$/,
            loader: &apos;babel-loader?presets[]=es2015&apos;
        }, {
            test: /\.css$/,
            loader: &apos;style-loader!css-loader!px2rem-loader?base=37.5&amp;scale=2&amp;minSize=1&amp;ignore=border|margin|padding&apos;
        }]
    },
    plugins: [
    ]
};
</code></pre><p>之前的css:</p>
<p><img src="/imgs/webpack-loader-1.png" alt=""></p>
<p>打包之后:</p>
<p><img src="/imgs/webpack-px-2rem-compiled.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在React,ES6开发模式越来越普及的今天,webpack就成了前端构建的一个标配。webpack有两大重要部分组成: loader和plugin。loader是用在应用源码上的转换原件,比如最常用到的babel-loader/jsx-loader/file-loader
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
      <category term="构建工具" scheme="http://yoursite.com/categories/javascript/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    
      <category term="webpack" scheme="http://yoursite.com/categories/javascript/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/webpack/"/>
    
    
  </entry>
  
  <entry>
    <title>Shadow DOM研究</title>
    <link href="http://yoursite.com/2016/12/12/2016-12-12-chrome-shadow-dom-tourial/"/>
    <id>http://yoursite.com/2016/12/12/2016-12-12-chrome-shadow-dom-tourial/</id>
    <published>2016-12-11T16:00:00.000Z</published>
    <updated>2017-02-11T03:55:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://github.com/Polymer/polymer" target="_blank" rel="external">Polymer</a>中,提出了<a href="https://developer.mozilla.org/zh-CN/docs/Web/Web_Components" target="_blank" rel="external">Web Component</a>的概念,旨在让开发者可以封装出很多可复用的组件。现在,webkit添加了对该API支持,也就意味着我们不用借助框架,也可以自己封装出可复用的组件(通过自定义元素的形式),而不需要依赖其他框架来实现。</p>
<p>假设我们这边需要封装一个进度条组件,实现代码大概是这样的:</p>
<pre><code>//  javascript

class CustomProgressBar extends HTMLElement {

    constructor(args) {
        super(args);

        //  createShadowRoot用来创建一个shadowDOM实例
        const shadowRoot = this.createShadowRoot();

        //  设置组件内的布局结构和样式
        shadowRoot.innerHTML = `
            &lt;style type=&quot;text/css&quot;&gt;
                :host {
                    display: inline-block;
                    width: 200px;
                    height: 30px;
                    box-sizing: border-box;
                    padding: 1px;
                }
                :host * {
                    -webkit-touch-callout: none;
                    -webkit-user-select: none;
                    -khtml-user-select: none;
                    -moz-user-select: none;
                    -ms-user-select: none;
                    user-select: none;
                }
                .progress {
                    display: inline-block;
                    width: 200px;
                    height: 30px;
                    position: relative;
                    border: 1px solid #000;
                }
                .progress &gt; .bar {
                    background: red;
                    height: 100%;
                    width: 0;
                    transition: all 0.2s;
                }

                .progress .label {
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    text-align: center;
                    font-size: 14px;
                    line-height: 30px;
                    color: #000;
                }
            &lt;/style&gt;
            &lt;div class=&quot;progress&quot; aria-valuenow=&quot;0&quot; aria-valuemin=&quot;0&quot; aria-valuemax=&quot;100&quot;&gt;
                &lt;div class=&quot;bar&quot;&gt;&lt;/div&gt;
                &lt;div class=&quot;label&quot;&gt;0%&lt;/div&gt;
            &lt;/div&gt;
        `;

        //  将相关元素存储到成员变量中
        this._progressElement = shadowRoot.querySelector(&quot;.progress&quot;);
        this._bar = shadowRoot.querySelector(&quot;.bar&quot;);
        this._label = shadowRoot.querySelector(&quot;.label&quot;);
    }

    /**
     * 取得当前进度
     * @return {string}
     */
    get progress() {
        return Number(this._progressElement.getAttribute(&quot;aria-valuenow&quot;));
    }

    /**
     * 设置进度
     * @param value
     */
    set progress(value) {
        //  最大值值最小值
        const max = this._progressElement.getAttribute(&quot;aria-valuemax&quot;),
              min = this._progressElement.getAttribute(&quot;aria-valuemin&quot;);

        //  类型判断
        if(Number.isNaN(Number(value))) {
            throw new Error(`value must be an number type, you specified ${value} which is ${{}.toString.call(value).slice(8, -1).toLowerCase()}!`);
        }

        //  范围检测
        if(value &gt; max || value &lt; min) {
            throw new Error(`value must between ${min} to ${max} , you specified ${value}!`);
        }

        //  设置相关属性
        this._progressElement.setAttribute(&quot;aria-valuenow&quot;, value);
        this._bar.style.width = `${value}%`;
        this._label.textContent = `${value}%`;
    }

    /**
     * 提供可以绑定onclick的接口
     * @param callback
     */
    set onclick(callback) {
        if(typeof callback === &quot;function&quot;) {
            this._progressElement.addEventListener(&quot;click&quot;, e =&gt; {
                callback.call(this, e);
            }, false);
        }
    }

}

//  调用 customElements.define定义自定义元素,第一个参数自定义元素名,第二个参数是HTMLElement的一个子类
customElements.define(&quot;custom-progress-bar&quot;, CustomProgressBar);

window.onload = () =&gt; {

    let customProgressBar = document.querySelector(&quot;custom-progress-bar&quot;),
        progress;

    /**
     * 给进度条组件绑定onclick事件,每次点击进度加10
     * @param e
     */
    customProgressBar.onclick = (e) =&gt; {
        progress = Number(this.progress);
        if(progress &gt;= 100) {
            progress = 0;
        } else {
            progress += 10;
        }
        this.progress = progress;
    };

};

//  HTML
//  现在我们可以通过new CustomProgressBar()或者custom-progress-bar来使用自定义元素了

&lt;custom-progress-bar&gt;&lt;/custom-progress-bar&gt;
</code></pre><p>至此我们的一个进度条组件就算封装完成了,需要注意的是,customElements.define方法对第一个参数有一些要求:</p>
<ul>
<li>必须以小写字母 a-z 开头</li>
<li>不能包含大写字母 A-Z</li>
<li>必须包含”-“</li>
</ul>
<p>最后渲染出来是如下的布局结构:</p>
<p><img src="/imgs/shadow-dom-rendered.png" alt=""></p>
<p>一起看看实际的效果:</p>
<p><img src="/imgs/shadow-dom-gif.gif" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;https://github.com/Polymer/polymer&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Polymer&lt;/a&gt;中,提出了&lt;a href=&quot;https://developer.mozilla.org/zh-CN
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
      <category term="Shadow DOM" scheme="http://yoursite.com/categories/javascript/Shadow-DOM/"/>
    
      <category term="Web Component" scheme="http://yoursite.com/categories/javascript/Shadow-DOM/Web-Component/"/>
    
    
  </entry>
  
  <entry>
    <title>Gulp插件的研究</title>
    <link href="http://yoursite.com/2016/11/29/2016-11-29-gulp-plugin-tourial/"/>
    <id>http://yoursite.com/2016/11/29/2016-11-29-gulp-plugin-tourial/</id>
    <published>2016-11-28T16:00:00.000Z</published>
    <updated>2017-03-30T12:19:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>在网页端功能越来越繁杂的今天,随着功能的增多,代码量也必不可少的多个,代码量一多,web性能就显得尤为重要,尤其是加载方面,时间太长,可能用户就没心情等下去,所以现在的web项目一般都在发布的时候进行一版自动构建,从原来的grunt到gulp,再到现在的webpack。</p>
<p>今天研究了下gulp插件,写点心得体会吧。看了两个gulp插件源码,发现里面都引入了<a href="https://github.com/rvagg/through2" target="_blank" rel="external">through2</a>这个包,官方的说法就是”Node Stream的简单封装，目的是让链式流操作更加简单;”,就也照葫芦画瓢,引用了这个包,简单实现一个gulp插件,功能就是压缩css,并且把css中的”background: url(xxxx.png)”中的”xxxx.png”转换成base64编码的形式,减少http请求数。</p>
<pre><code>&quot;use strict&quot;;

const through = require(&quot;through2&quot;),
    path = require(&quot;path&quot;),
    fs = require(&quot;fs&quot;),

    //  引用async/await,方便处理文件读写的异步操作
    async = require(&quot;asyncawait&quot;).async,
    await = require(&quot;asyncawait&quot;).await,

    //  匹配url(../xxx.yyy)这种表达式
    imgReg = /url\s*\((\s*[A-Za-z0-9\-\_\.\/\:]+\s*)\);?/gi,

    //  将fs.readFile封装成Promise
    readFile = (path) =&gt; {
        return new Promise((resolve, reject) =&gt; {
            fs.readFile(path, (ex, file) =&gt; {
                if (ex) {
                    reject(ex);
                }
                resolve(file);
            });
        });
    };

let base, contents, match, tmp, url;

//  暴露出去的函数
module.exports = (opt) =&gt; {

    return through.obj(function(file, enc, cb) {

        //  文件为空直接执行回调函数
        if (file.isNull()) {
            cb(null, file);
        }

        //  取得当前css的绝对路径
        base = file.base;

        //  匹配css中的无效字符,并且转换成buffer
        file.contents = new Buffer(file._contents.toString()
            //  去换行符
            .replace(/\n/gm, &quot;&quot;)

            //  去&quot;{&quot;之后到第一条样式间的空白字符
            .replace(/\{\s+/g, &quot;{&quot;)

            //  去&quot;;&quot;之后的空白字符
            .replace(/\;\s+/g, &quot;;&quot;));

        //  将文件内容转换成普通字符串并缓存
        contents = file.contents.toString();

        //  取得url(../../xxx.yyy),并且缓存
        match = contents.match(imgReg);

        //  async-await读取图片文件成base64编码
        async(() =&gt; {

            //  遍历之前的缓存项
            match.forEach((item) =&gt; {

                //  拼凑文件绝对路径
                url = item.replace(&quot;url(&quot;, &quot;&quot;).replace(&quot;)&quot;, &quot;&quot;).trim();

                //  用await读取文件,避免嵌套
                tmp = await (readFile(path.resolve(base, url)));

                //  替换之前匹配的字符串
                contents = contents.replace(item, `url(data:image/png;base64,${tmp.toString(&quot;base64&quot;)})`);
            });

            //  把文件内容转成buffer
            file.contents = new Buffer(contents);

            //  回调函数
            cb(null, file);

        })();
    });

};
</code></pre><p>至此,一个简单的插件就实现了,当然,还有很多不足,比如对图片进行压缩,减少base64字符串的长度,用request模块处理对网络图片的引用等等。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在网页端功能越来越繁杂的今天,随着功能的增多,代码量也必不可少的多个,代码量一多,web性能就显得尤为重要,尤其是加载方面,时间太长,可能用户就没心情等下去,所以现在的web项目一般都在发布的时候进行一版自动构建,从原来的grunt到gulp,再到现在的webpack。&lt;/
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
      <category term="Gulp" scheme="http://yoursite.com/categories/javascript/Gulp/"/>
    
      <category term="构建工具" scheme="http://yoursite.com/categories/javascript/Gulp/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>javascript模块化编程-同步模式</title>
    <link href="http://yoursite.com/2016/11/29/2016-11-23-js-sync-module-mode/"/>
    <id>http://yoursite.com/2016/11/29/2016-11-23-js-sync-module-mode/</id>
    <published>2016-11-28T16:00:00.000Z</published>
    <updated>2017-03-30T12:19:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>在日常开发中,为了便于多人协作开发,我们通常都会采用模块化开发的模式,今天看张荣铭的《javascript设计模式》的时候,看到同步模式这一章,结合自己之前的立即,也来实现一个简单的同步模块化模式。</p>
<pre><code>const module = (() =&gt; {

    //  缓存之前声明的模块
    let modules = {};

    /**
     * [description]
     * @param  deps     依赖列表
     * @return Array
     */
    let _loadDeps = (deps) =&gt; {
        return deps.map((dep) =&gt; {
            return modules[dep];
        });
    };

    return {

        /**
         * 声明一个模块
         * @param   id      模块id
         * @param   deps    依赖数组(模块id)
         * @param   factory 构造函数
         */
        define: (id, deps, factory) =&gt; {

            //  获取依赖,并且取得模块返回的对象
            deps = _loadDeps(deps);

            deps.map(function(dep) {
                return dep.factory.apply(window, dep.deps);
            });

            //  判断模块名是否重复
            if (modules[id]) {
                 throw new Error(&quot;module &quot; + id + &quot; has been declared!&quot;);
            }

            //  缓存模块
            modules[id] = {
                id: id,
                factory: factory,
                deps: deps
            };
        },

        /**
         * 使用定义好的模块
         * @param   depArr  依赖数组(模块id)
         * @param   factory 构造函数
         */
        use: (depArr, factory) =&gt; {

            //  获取依赖,并且取得模块返回的对象
            depArr = depArr.map((dep) =&gt; {
                return modules[dep].factory.apply(window, modules[dep].deps);
            });

            //  运行构造函数
            factory.apply(window, depArr);
        }

    };

})();
</code></pre><p>下面我们声明几个模块做测试:</p>
<pre><code>//  A模块
module.define(&quot;A&quot;, [], () =&gt; {
    return {
        method: () =&gt; {
            console.log(&quot;method under module A&quot;);
        }
    };
});

//  B模块
module.define(&quot;B&quot;, [], () =&gt; {
    return {
        method: () =&gt; {
            console.log(&quot;method under module B&quot;);
        }
    };
});

//  Person类
module.define(&quot;PersonClass&quot;, [], () =&gt; {

    class Person {
        constructor(name, age, sex, job) {
            this.name = name;
            this.age = age;
            this.sex = sex;
            this.job = job;
        }

        hello() {
            console.log(&quot;hello &quot; + this.name);
        }

        eat() {
            console.log(this.name + &quot; will eat&quot;);
        }

        getProfile() {
            return {
                name: this.name,
                age: this.age,
                sex: this.sex,
                job: this.job
            };
        }
    }

    return Person;
});
</code></pre><p>最后我们调用module.use来使用这些模块:</p>
<pre><code>module.use([&quot;A&quot;, &quot;B&quot;, &quot;PersonClass&quot;], (A, B, PersonClass) =&gt; {

    A.method();
    B.method();

    let person = new PersonClass(&quot;rwson&quot;, 24, &quot;male&quot;, &quot;web developer&quot;);
    person.hello();

    setTimeout(function() {
        person.eat();
    }, 5000);

    console.log(person.getProfile());

});
</code></pre><p>最后浏览器控制台输出如下图的结果:</p>
<p><img src="/imgs/sync-module-mode.png" alt="javascript模块化-同步模式"></p>
<p>至此一个简单的模块化工具就开发完成了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在日常开发中,为了便于多人协作开发,我们通常都会采用模块化开发的模式,今天看张荣铭的《javascript设计模式》的时候,看到同步模式这一章,结合自己之前的立即,也来实现一个简单的同步模块化模式。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const module = (() =&amp;g
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
      <category term="模块化" scheme="http://yoursite.com/categories/javascript/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>一起写一个npm命令行工具</title>
    <link href="http://yoursite.com/2016/11/20/2016-11-20-write-a-client/"/>
    <id>http://yoursite.com/2016/11/20/2016-11-20-write-a-client/</id>
    <published>2016-11-19T16:00:00.000Z</published>
    <updated>2017-09-22T03:17:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>自从nodejs问世之后，随着前端不断的发展，出现过很多的命令行工具，就比如前端构建工具，从最开始的<code>grunt</code>，再到<code>gulp</code>，然后到现在的<code>webpack</code>等等，它们都有自己的命令行，接下来我们一起分析并实现一个简单的命令行工具</p>
<p>首先需要建一个目录，在这里我们暂且叫<code>cli-starter</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkdir cli-starter</div></pre></td></tr></table></figure>
<p>然后我们需要去用<code>npm</code>初始化这个目录，这里我们用默认的就好</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm init -y</div></pre></td></tr></table></figure>
<p>普通的 node.js 脚本需要使用<code>node 文件名</code>的形式执行，在脚本首行加上<code>#!/usr/bin/env node</code>可以在<code>linux</code>环境中指定脚本的解释程序</p>
<p>一切从<code>hello world</code>开始，我们现在新建一个<code>bin</code>目录，在下面用建一个<code>hello.js</code>，写入下面内容</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/usr/bin/env node</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"hello world"</span>);</div></pre></td></tr></table></figure>
<p>然后去<code>node ./bin/hello</code>，可以看到控制台会输出<code>hello world</code></p>
<p>当然这个只是在特定目录下去执行这个文件，如果想和其他命令行工具做到无处不在，可以在<code>package.json</code>中做如下指定</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"name"</span>: <span class="string">"hello"</span>,</div><div class="line">  <span class="attr">"bin"</span>: &#123;</div><div class="line">    <span class="attr">"hello"</span>: <span class="string">"./bin/hello"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后再通过<code>npm link</code>去添加到系统<code>PATH</code>，不要担心会污染系统，既然有<code>npm link</code>，肯定就有<code>npm unlink</code>，就是把我们添加的删除，这样，我们就可以在任何一个目录下使用这个<code>hello</code>命令了</p>
<p>上面就是一个最简单的命令行了，接下来我们需要对它进行完善，最常见的就是参数，有很多<code>npm</code>模块可以解析我们传入的参数，常用的有<a href="https://www.npmjs.com/package/commander" target="_blank" rel="external">commander</a>、<a href="https://www.npmjs.com/package/minimist" target="_blank" rel="external">minimist</a>等</p>
<p>在这里我用的<code>minimist</code>这个模块，用法<code>npm</code>上已经有了这里不再赘述，下面我们一起完成一个翻译小工具，调用谷歌的翻译接口，这里我直接用的<code>translate-api</code>这个<code>npm</code>包,一起看下实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/usr/bin/env node</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> minimist = <span class="built_in">require</span>(<span class="string">"minimist"</span>),</div><div class="line">    translate = <span class="built_in">require</span>(<span class="string">"translate-api"</span>);</div><div class="line"></div><div class="line"><span class="comment">//	获取参数</span></div><div class="line"><span class="keyword">var</span> args = minimist((process.argv.slice(<span class="number">2</span>)), &#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     *  参数别名</div><div class="line">     * hello --target=abc &lt;=&gt; hello -t=abc</div><div class="line">     */</div><div class="line">    alias: &#123;</div><div class="line">        <span class="attr">t</span>: <span class="string">"target"</span>,</div><div class="line">        <span class="attr">i</span>: <span class="string">"input"</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//	存储输入的参数</span></div><div class="line"><span class="keyword">var</span> target = args.target,</div><div class="line">    input = args.input;</div><div class="line"></div><div class="line"><span class="comment">//	调用封装好的Google Translate API</span></div><div class="line">translate.getText(input, &#123; <span class="attr">to</span>: target &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(res.text);</div><div class="line">	<span class="comment">//	退出进程</span></div><div class="line">    process.exit(<span class="number">1</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>到这里我们一个简单的命令行工具就写好了，只是一个小玩具，还有很多没实现，比如子命令等。</p>
<p>那么如果感觉这个工具写的还行，想分享到<code>npm</code>仓库里面给更多人使用，这时候我们就要用到<code>npm</code>的一些子命令了，首先我们需要用<code>npm adduser</code>去登录<code>npm</code>，让它知道这个包是谁发布的，然后用<code>npm publish</code>去推送到仓库，这里需要注意的是，在发布<code>npm</code>包时我们需要把镜像源切换成官方的，推荐使用<a href="https://www.npmjs.com/package/nrm" target="_blank" rel="external">nrm</a>去管理镜像，在用<code>publish</code>之前，先<code>nrm use npm</code>切下镜像，等发布成功之后别人就可以用<code>npm install &lt;package-name&gt; -g</code>去把我们的命令行工具安装到全局使用啦😜</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自从nodejs问世之后，随着前端不断的发展，出现过很多的命令行工具，就比如前端构建工具，从最开始的&lt;code&gt;grunt&lt;/code&gt;，再到&lt;code&gt;gulp&lt;/code&gt;，然后到现在的&lt;code&gt;webpack&lt;/code&gt;等等，它们都有自己的命令行，接下来我们一起分
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
      <category term="命令行工具" scheme="http://yoursite.com/categories/javascript/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>async/await学习</title>
    <link href="http://yoursite.com/2016/11/09/2016-11-09-async:await-tourial/"/>
    <id>http://yoursite.com/2016/11/09/2016-11-09-async:await-tourial/</id>
    <published>2016-11-08T16:00:00.000Z</published>
    <updated>2017-03-30T12:19:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>在处理javascript中异步的时候,回调往往是最让人恶心的,之前介绍过用<a href="http://123.207.98.169:81/2016/05/04/2016-05-04-es6-promise/" target="_blank" rel="external">Promise</a>来处理异步的问题,但是即使用上了Promise,在处理回调上还是会有各种嵌套,今天来介绍下ES7中的async/await,由于在Nodejs中还未得到支持,所以需要借助一些npm包来实践,在这里用的是<a href="https://github.com/yortus/asyncawait" target="_blank" rel="external">asyncawait</a>。</p>
<p>先来个原生文件读取的例子:</p>
<pre><code>const fs = require(&quot;fs&quot;);
fs.readFile(&quot;test.txt&quot;, (ex, res) =&gt; {
   console.log(res.toString()); 

   //   do something...

   fs.readFile(&quot;test2.txt&quot;, (ex, res) =&gt; {
        console.log(res.toString());

        //  do something
   });
});

//  控制台输出
xxxxx
yyyyy
</code></pre><p>下面我们再用async/await实现一遍:</p>
<pre><code>const async = require(&quot;asyncawait&quot;).async;
const await = require(&quot;asyncawait&quot;).await;
let readFile = function(path) {
    return new Promise((resolve, reject) =&gt; {
        fs.readFile(path, (ex, res) =&gt; {
            if (ex) {
                reject(ex);
            }
            resolve(res);
        });
    });
}

let asyncReadFile = async(() =&gt; {

    let fs = await (readFile(&quot;test.txt&quot;));
    let fs2 = await (readFile(&quot;test2.txt&quot;));

    console.log(fs.toString());
    console.log(fs2.toString());
});

asyncReadFile();
</code></pre><p>虽然代码可能比上面的多了一点,但是已经完全看不到回调嵌套的影子了,也能完成同样的功能,何乐而不为。😉</p>
<p>下面我们再来模拟一个异步请求的例子:</p>
<pre><code>const async = require(&quot;asyncawait&quot;).async;
const await = require(&quot;asyncawait&quot;).await;
const http = require(&quot;http&quot;);

http.createServer((req, res) =&gt; {

    switch (req.url) {

        case &quot;/async-await&quot;:
            setTimeout(() =&gt; {
                res.writeHead(200, { &quot;Content-Type&quot;: &quot;text/plain&quot; });
                res.end(&quot;request end&quot;);
            }, 5000);
            break;

        case &quot;/async-await2&quot;:
            setTimeout(() =&gt; {
                res.writeHead(200, { &quot;Content-Type&quot;: &quot;text/plain&quot; });
                res.end(&quot;request end2&quot;);
            }, 8000);
            break;

        default:
            break;

    }
}).listen(3000, &quot;127.0.0.1&quot;);

let requestUrl = function(path) {
    return new Promise((resolve, reject) =&gt; {
        http.get({
            hostname: &apos;localhost&apos;,
            port: 3000,
            path: path,
            agent: false
        }, (res) =&gt; {
            res.on(&quot;data&quot;, (data) =&gt; {
                resolve(data);
            });
            res.on(&quot;error&quot;, (ex) =&gt; {
                reject(ex);
            })
        });
    });
}

let asyncRequest = async(() =&gt; {
    let resp, resp2;
    await (requestUrl(&quot;/async-await&quot;).then((res) =&gt; {
        console.log(res.toString());
        resp = res.toString();
    }).catch((ex) =&gt; {
        resp = &quot;发生错误!&quot;;
    }));

    await (requestUrl(&quot;/async-await2&quot;).then((res) =&gt; {
        resp2 = res.toString();
    }).catch((ex) =&gt; {
        resp = &quot;发生错误!&quot;;
    }));
    console.log(resp);
    console.log(resp2);
});

asyncRequest();

//  控制台输出
request end
request end2
</code></pre><p>由此我们可以将async/await用在很多地方,比如例子中的文件读取、异步请求、nodejs中的查询数据库等等。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在处理javascript中异步的时候,回调往往是最让人恶心的,之前介绍过用&lt;a href=&quot;http://123.207.98.169:81/2016/05/04/2016-05-04-es6-promise/&quot; target=&quot;_blank&quot; rel=&quot;external
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
      <category term="ES7" scheme="http://yoursite.com/categories/javascript/ES7/"/>
    
      <category term="async/await" scheme="http://yoursite.com/categories/javascript/ES7/async-await/"/>
    
    
  </entry>
  
  <entry>
    <title>IE下AngularJs中的ajax缓存</title>
    <link href="http://yoursite.com/2016/11/02/2016-11-02-ie-ajax-cache/"/>
    <id>http://yoursite.com/2016/11/02/2016-11-02-ie-ajax-cache/</id>
    <published>2016-11-01T16:00:00.000Z</published>
    <updated>2017-03-30T12:19:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>在单页应用越来越普及的今天,越来越多的项目都会采用这种方案,这几天用AngularJs做了一个PC端应用,有登录注册的功能,登录注册的功能是通过ajax实现的,在登录注册以后页面不刷新,只修改$rootScope下的某些属性值,然后在页面里面通过ng-if之类的指令来控制相关元素的显示隐藏。</p>
<p>之前的大概实现如下:</p>
<pre><code>//  js
var app = angular.module(&quot;app&quot;, []);
app.run([&quot;$rootScope&quot;, &quot;$http&quot;, function($rootScope, $http) {
    $rootScope.isLogin = false;
    $rootScope.$on(&quot;$routeChangeStart&quot;, function (event, next, current) {
    $http.get(&quot;xxxx&quot;)
        .success(function(res) {
            $rootScope.isLogin = !!(res.isLogin);
            //  ...
        })
        .error(function() {
            //  ...
        });
    });
}]);

//  HTML
&lt;div class=&quot;container&quot;&gt;
    &lt;a href=&quot;/user/center&quot; ng-if=&quot;isLogin&quot;&gt;用户中心&lt;/a&gt;
    &lt;a href=&quot;javascript:;&quot; ng-click=&quot;logout()&quot; ng-if=&quot;isLogin&quot;&gt;登出&lt;/a&gt;
    &lt;a href=&quot;/login&quot; ng-if=&quot;!isLogin&quot;&gt;登录&lt;/a&gt;
&lt;/div&gt;
</code></pre><p>后来发现在Chrome/Firefox下都是好的,到了IE下登录以后不刷新就显示不对。原来以为是ng-if在IE下重新渲染过慢的问题,改成ng-show以后还是不行,然后看http状态码,发现是304,想到可能和缓存有关系,后来改了配置中关键ajax请求那边的东西,发现可以了,核心代码如下:</p>
<pre><code>app.config([&quot;$routeProvider&quot;, &quot;$httpProvider&quot;, function($routeProvider, $httpProvider){
    //  ...

    if (!$httpProvider.defaults.headers.get) {
        $httpProvider.defaults.headers.get = {};
    }
    $httpProvider.defaults.headers.common[&quot;X-Requested-With&quot;] = &quot;XMLHttpRequest&quot;;
    $httpProvider.defaults.headers.get[&quot;Cache-Control&quot;] = &quot;no-cache&quot;;
    $httpProvider.defaults.headers.get[&quot;Pragma&quot;] = &quot;no-cache&quot;;
}]);
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在单页应用越来越普及的今天,越来越多的项目都会采用这种方案,这几天用AngularJs做了一个PC端应用,有登录注册的功能,登录注册的功能是通过ajax实现的,在登录注册以后页面不刷新,只修改$rootScope下的某些属性值,然后在页面里面通过ng-if之类的指令来控制相
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
      <category term="AngularJs" scheme="http://yoursite.com/categories/javascript/AngularJs/"/>
    
      <category term="ajax" scheme="http://yoursite.com/categories/javascript/AngularJs/ajax/"/>
    
    
  </entry>
  
  <entry>
    <title>javascript中的序列化</title>
    <link href="http://yoursite.com/2016/09/17/2016-09-17-javascript-serialize/"/>
    <id>http://yoursite.com/2016/09/17/2016-09-17-javascript-serialize/</id>
    <published>2016-09-16T16:00:00.000Z</published>
    <updated>2017-03-30T12:19:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>在用jQuery发送ajax(POST)请求的时候,最常见的提交方式就是”application/x-www-form-urlencoded”,通常都会传入一个data属性作为传输给后端的数据,在ajax发送之前,那么我们直接如果直接传入把这个对象传递给后端,后端就不能对该对象进行解析,因为对象会被转成字符串”[object Object]”,所以就需要我们对该对象进行url编码,并且转换成字符串,再传给后端。</p>
<p>假设我们先传递一个简单的对象(所有的key对应的value都不是引用类型[Array、Object]),就像下面这样:</p>
<pre><code>{
    string: &quot;string&quot;,
    number: 1
}
</code></pre><p>用jQuery中的$.ajax方法,POST提交,打开请求面板,在form data那边,点击view source,可以看到下面这一串字符串,就像下面的样子:</p>
<pre><code>string=string&amp;number=1
</code></pre><p>在jQuery中,$.param这个方法可以实现进行url编码的作用。</p>
<p>现在可以自己实现一个:</p>
<pre><code>//  获取对象上的类名
function _typeOf(obj) {
    return {}.toString.call(obj).slice(8, -1);
}

//  encodeURIComponent简写
function _encode(data) {
    data = data || &quot;&quot;;
    return encodeURIComponent(data);
}

//  序列化主函数
function _serializenData(data) {
    var res = data,
        typeIn;

    //  判断传入的是否是一个Object类型的数据
    if (_typeOf(data) === &quot;Object&quot;) {
        res = [];
        for (var i in data) {
            typeIn = _typeOf(data[i]);
            switch (typeIn) {

                //  遇到Object、Array时需要进行遍历或者枚举,对其内部元素、属性做处理后再放到结果集数组中
                case &quot;Object&quot;:
                    res.push(_loopObject(data[i], i));
                    break;

                case &quot;Array&quot;:
                    res.push(_loopArray(data[i], i));
                    break;

                //  其他类型直接推到结果集数组
                default:
                    res.push(_encode(i) + &quot;=&quot; + _encode(data[i]));
                    break;

            }
        }
        //  把结果集数组转换成&quot;xxx=111&amp;yyy=333&amp;zzz=444&quot;的形式
        res = res.join(&quot;&amp;&quot;).replace(&quot;%20&quot;, &quot;+&quot;)
    }
    return (&quot;&quot; + res);
}

/**
 * 深层遍历一个数组
 * @param  {[type]} array [description]
 * @param  {[type]} key   [description]
 * @return {[type]}       [description]
 */
function _loopArray(array, key) {
    var res = [],
        typeIn;
    for (var i = 0, len = array.length; i &lt; len; i++) {

        //  获取每一项的类名,如果是Object/则递归调用_loopArray/_loopObject,传入当前项和属性名,处理子项,再放到结果集中
        typeIn = _typeOf(array[i]);
        switch (typeIn) {

            case &quot;Array&quot;:
                res.push(_loopArray(array[i], (key + &quot;[&quot; + i + &quot;]&quot;)));
                break;

            case &quot;Object&quot;:
                res.push(_loopObject(array[i], (key + &quot;[&quot; + i + &quot;]&quot;)));
                break;

            //    其他类型的直接推到结果集数组
            default:
                res.push(_encode(key + &quot;[]&quot;) + &quot;=&quot; + _encode((&quot;&quot; + array[i])));
                break;

        }
    }

    //  把结果集转换成&quot;xxx=111&amp;yyy=333&amp;zzz=444&quot;的形式
    return res.join(&quot;&amp;&quot;);
}

/**
 * 深层遍历一个对象
 * @param  {[type]} object [description]
 * @param  {[type]} key    [description]
 * @return {[type]}        [description]
 */
function _loopObject(object, key) {
    var res = [],
        typeIn;
    for (var i in object) {
        //  取得一个当前key对应value的类名,如果是Object/Array,则进行递归调用
        typeIn = _typeOf(object[i]);
        switch (typeIn) {
            case &quot;Array&quot;:
                res.push(_loopArray(object[i], key + &quot;[&quot; + i + &quot;]&quot;));
                break;

            case &quot;Object&quot;:
                res.push(_loopObject(object[i], key + &quot;[&quot; + i + &quot;]&quot;));
                break;

            //    其他类型的直接推到结果集数组中
            default:
                res.push(_encode(key + &quot;[&quot; + i + &quot;]&quot;) + &quot;=&quot; + _encode((&quot;&quot; + object[i])));
                break;
        }
    }

    //  把结果集转换成&quot;xxx=111&amp;yyy=333&amp;zzz=444&quot;的形式
    return res.join(&quot;&amp;&quot;);
}
</code></pre><p>下面我们模拟几个复杂点的对象,调用封装的序列化方法,和$.param进行对比:</p>
<pre><code>var obj = {
    string: &quot;string&quot;,
    number: 1,
    array: [1, 2, 3, 4, 5]
};

var obj2 = {
    string: &quot;string&quot;,
    number: 1,
    array: [
        1, 2, 3, 4, 5, {
            key1: &quot;value1&quot;,
            key2: &quot;value2&quot;,
            key3: &quot;value3&quot;
        }
    ]
};

var obj3 = {
    array: [1, 2, 3, 4, 5],
    arrayobject: [{
        key1: &quot;value1&quot;,
        key2: &quot;value2&quot;,
        key3: &quot;value3&quot;
    }, {
        key1: &quot;value1&quot;,
        key2: &quot;value2&quot;,
        key3: &quot;value3&quot;
    }, {
        key1: &quot;value1&quot;,
        key2: &quot;value2&quot;,
        key3: &quot;value3&quot;
    }]
};

var deepObj1 = {
    arr: [{
        string: &quot;string&quot;,
        number: 1,
        arr: [1, 2, 3, 4],
        mixArr: [{
            key1: &quot;value1&quot;,
            key2: &quot;value2&quot;
        }, {
            key1: &quot;value1&quot;,
            key2: &quot;value2&quot;
        }, {
            key1: &quot;value1&quot;,
            key2: &quot;value2&quot;
        }]
    }]
};

var deepObj2 = {
    obj: {
        key1: &quot;value1&quot;,
        key2: &quot;value2&quot;,
        key3: &quot;value3&quot;
    },
    array: [1, 2, 3, 4, 5],
    objectArray: {
        array: [1, 2, 3, 4, 5, {
            key1: &quot;value1&quot;,
            key2: &quot;value2&quot;,
            key3: &quot;value3&quot;
        }]
    },
    arrayObj: [{
        key1: &quot;value1&quot;,
        key2: &quot;value2&quot;,
        key3: &quot;value3&quot;
    }, {
        key1: &quot;value1&quot;,
        key2: &quot;value2&quot;,
        key3: &quot;value3&quot;
    }, {
        key1: &quot;value1&quot;,
        key2: &quot;value2&quot;,
        key3: &quot;value3&quot;
    }]
};

//  打开控制台的console面板,查看输出

console.group(&quot;serialize obj&quot;);
console.log(_serializenData(obj));  //  ...
console.log($.param(obj));  //  ...
console.log(_serializenData(obj) === $.param(obj)); //  true
console.groupEnd();

console.group(&quot;serialize obj2&quot;);
console.log(_serializenData(obj2)); //  ...
console.log($.param(obj2)); //  ...
console.log(_serializenData(obj2) === $.param(obj2));   //  true
console.groupEnd();    

console.group(&quot;serialize obj3&quot;);
console.log(_serializenData(obj3)); //  ...
console.log($.param(obj3)); //  ...
console.log(_serializenData(obj3) === $.param(obj3));   //  true
console.groupEnd();

console.group(&quot;serialize deepObj1&quot;);
console.log(_serializenData(deepObj1)); //  ...
console.log($.param(deepObj1)); //  ...
console.log(_serializenData(deepObj1) === $.param(deepObj1));   //  true
console.groupEnd();

console.group(&quot;serialize deepObj2&quot;);
console.log(_serializenData(deepObj2)); //  ...
console.log($.param(deepObj2)); //  ...
console.log(_serializenData(deepObj2) === $.param(deepObj2));   //  true
console.groupEnd();
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在用jQuery发送ajax(POST)请求的时候,最常见的提交方式就是”application/x-www-form-urlencoded”,通常都会传入一个data属性作为传输给后端的数据,在ajax发送之前,那么我们直接如果直接传入把这个对象传递给后端,后端就不能对该
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
      <category term="序列化" scheme="http://yoursite.com/categories/javascript/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>javascript中Date细节</title>
    <link href="http://yoursite.com/2016/08/30/2016-08-30-something-about-javascript-Date/"/>
    <id>http://yoursite.com/2016/08/30/2016-08-30-something-about-javascript-Date/</id>
    <published>2016-08-29T16:00:00.000Z</published>
    <updated>2017-03-30T12:19:21.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="Safri浏览器new-Date-“yyyy-mm-dd”-返回invalid-Date"><a href="#Safri浏览器new-Date-“yyyy-mm-dd”-返回invalid-Date" class="headerlink" title="Safri浏览器new Date(“yyyy-mm-dd”)返回invalid Date"></a>Safri浏览器new Date(“yyyy-mm-dd”)返回invalid Date</h5><p>许多时候我们需要初始化一个具体某天的日期对象的时候,会用到new Date(),这个方法,我们可以传入一个字符串作为参数来指定具体的日期,而一般我们会传入一个”yyyy-mm-dd hh:ii:ss”这种格式作为一个初始日期,但到了Safri浏览器下,就会返回一个invalid Date,调用该Date实例下的所有方法都会返回NaN值,原因是Safri不能正常解析中间的”-“分隔符,解决办法也很简单,有两种:</p>
<p>直接</p>
<pre><code>var myDate1 = Date.parseExact(&quot;29-11-2010&quot;, &quot;dd-MM-yyyy&quot;);
var myDate2 = Date.parseExact(&quot;11-29-2010&quot;, &quot;MM-dd-yyyy&quot;);
var myDate3 = Date.parseExact(&quot;2010-11-29&quot;, &quot;yyyy-MM-dd&quot;);
var myDate4 = Date.parseExact(&quot;2010-29-11&quot;, &quot;yyyy-dd-MM&quot;);
</code></pre><p>或者</p>
<pre><code>new Date(&quot;2011-04-12&quot;.replace(/-/g, &quot;/&quot;));
</code></pre><h5 id="setMonth溢出问题"><a href="#setMonth溢出问题" class="headerlink" title="setMonth溢出问题"></a>setMonth溢出问题</h5><p>实例化一个Date对象,通过如下的方式,然后调用该实例的setMonth方法,把当前月份加1,就像下面这样</p>
<pre><code>var date = new Date(&quot;2016/01/30&quot;);
date.setMonth(date.getMonth() + 1);
console.log(date.getMonth());       //  Tue Mar 01 2016 00:00:00 GMT+0800 (CST)
</code></pre><p>或者</p>
<pre><code>var date = new Date(&quot;2016/10/31&quot;);
date.setMonth(date.getMonth() + 1);
console.log(date);                 //  Thu Dec 01 2016 00:00:00 GMT+0800 (CST)
</code></pre><p>上面两段我们都希望是返回的是2月和11月,但是真正返回了3月和12月</p>
<p>出现这种情况的原因是2月没有28/29号以后的日期,而当前日期对象的日期为30号,调用setMonth,就导致溢出,下面的例子同理。</p>
<p>解决办法也很简单,在调用setMonth之前,拿下个月的最后一天和当前的比较下,再做相应处理就好,或者更简单粗暴的方法,把当前Date对象的date改成1,哈哈。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;Safri浏览器new-Date-“yyyy-mm-dd”-返回invalid-Date&quot;&gt;&lt;a href=&quot;#Safri浏览器new-Date-“yyyy-mm-dd”-返回invalid-Date&quot; class=&quot;headerlink&quot; title=&quot;Safr
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
      <category term="Date" scheme="http://yoursite.com/categories/javascript/Date/"/>
    
    
  </entry>
  
  <entry>
    <title>javascript函数节流</title>
    <link href="http://yoursite.com/2016/07/20/2016-07-20-javascript-function-throttle/"/>
    <id>http://yoursite.com/2016/07/20/2016-07-20-javascript-function-throttle/</id>
    <published>2016-07-19T16:00:00.000Z</published>
    <updated>2017-03-30T12:19:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>如果我们需要做一个过滤的功能,类似于下面这个效果</p>
<p><img src="/imgs/screen.gif" alt=""></p>
<p>我们需要给input绑定一个keyup事件,然后根据它的value操作页面或者过滤数据重新渲染页面,但是在数据比较多的时候,如果在keyup里面不做一定限制的话,在性能方面就会有一些影响,这时候,就需要”函数节流”这个东西。</p>
<p>在underscore这个库中提供了一个函数节流的方法,其实就是在一定时间内判断某个函数是否被执行过。</p>
<p>就拿我们上面的效果来说:</p>
<pre><code>//  HTML
&lt;input type=&quot;text&quot; id=&quot;input&quot; /&gt;
&lt;ul id=&quot;ul&quot;&gt;
    &lt;li&gt;111111111&lt;/li&gt;
    &lt;li&gt;22222222&lt;/li&gt;
    &lt;li&gt;333333&lt;/li&gt;
    &lt;li&gt;4444&lt;/li&gt;
    &lt;li&gt;1234&lt;/li&gt;
    &lt;li&gt;5678&lt;/li&gt;
    &lt;li&gt;9999&lt;/li&gt;
    &lt;li&gt;6789&lt;/li&gt;
    &lt;li&gt;01234&lt;/li&gt;
&lt;/ul&gt;


//  javascript
    window.onload = function() {
        var input = document.getElementById(&quot;input&quot;);
        var ul = document.getElementById(&quot;ul&quot;);
        var li = ul.getElementsByTagName(&quot;li&quot;);
        var len = li.length;
        var value, timeout = null;
        input.onkeyup = function(ev) {
            //  上次的还没执行
            if(timeout) {
                return;
            }
            timeout = setTimeout(function() {
                clearTimeout(timeout);
                value = ev.target.value.trim();
                for(var i = 0; i &lt; len; i ++) {
                    if(li[i].innerHTML.indexOf(value) &gt; -1) {
                        li[i].style.display = &quot;block&quot;;
                    } else {
                        li[i].style.display = &quot;none&quot;;
                    }
                }
            }, 200);
        };

};
</code></pre><p>下面可以把这个函数再次进行封装:</p>
<pre><code>/**
 * 函数节流
 * @param fn        回调函数
 * @param delay     延迟多久
 * @param atleast   至少多久触发一次
 * @return Function
 */
function throttle(fn, delay, atleast) {
    var timer = null;
    var previous = null;

    return function () {
        var now = +(new Date());

        if ( !previous ) {
            previous = now;
        }

        if ( now - previous &gt; atleast ) {
            fn();
            // 重置上一次开始时间为本次结束时间
            previous = now;
        } else {
            clearTimeout(timer);
            timer = setTimeout(function() {
                fn();
            }, delay);
        }
    }
};
</code></pre><p>在平时可以有好多地方用到函数节流,比如浏览器的resize,鼠标滚轮事件等等。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果我们需要做一个过滤的功能,类似于下面这个效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/imgs/screen.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们需要给input绑定一个keyup事件,然后根据它的value操作页面或者过滤数据重新渲染页面,但是在数据比较多的时候,
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
      <category term="函数节流" scheme="http://yoursite.com/categories/javascript/%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81/"/>
    
    
  </entry>
  
  <entry>
    <title>fetch中的Timeout</title>
    <link href="http://yoursite.com/2016/07/10/2016-07-10-fetch-timeout/"/>
    <id>http://yoursite.com/2016/07/10/2016-07-10-fetch-timeout/</id>
    <published>2016-07-09T16:00:00.000Z</published>
    <updated>2017-03-30T12:19:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>随着ES6的普及,fetch已经渐渐取代了普通ajax在异步请求中的位置,以前在用jQuery中的ajax时,可以指定一个timeout属性,设置该请求的超时时间,但是原生的fetch并不支持该属性,如果遇到遇到一个请求一直pedding状态,就只能干等着,什么也干不了。由于fetch本身在被初始化后返回一个Promise对象,我们就可以对其再包一层Promise来实现在fetch请求中加入timeout的功能。</p>
<p>先来看下fetch的基本用法:</p>
<pre><code>fetch(&quot;some url&quot;, {
    &quot;method&quot;: &quot;POST&quot;,
    &quot;body&quot;: JSON.stringify({
        &quot;key&quot;: &quot;value&quot;,
        &quot;arr&quot;: [1,2,3]
    }),
    ...
})
//  parse response to JSON object
.then((res) =&gt; res.json())
.then((res) =&gt; {
    //   success dome something
})
.catch((ex) =&gt; {
    //  exception occurded
});
</code></pre><p>在Promise中有个静态方法,叫<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/race" target="_blank" rel="external">Promise.race()</a>,该方法接受一个数组作为参数,数组中的每个元素都是一个Promise的实例,大致用法如下:</p>
<pre><code>let promise1 = new Promise((resoleve, reject) =&gt; {
    //  do something
});

let promise2 = new Promise((resoleve, reject) =&gt; {
    //  do something
});

//  ...

let race = Promise.race([promise1, promise2, ...]);
</code></pre><p>它返回一个Promise,该Promise根据传入的Promise的第一个完成状态(resolve/reject),只要该Promise已完成,就将其返回。</p>
<p>看个下面的例子:</p>
<pre><code>const promise1 = new Promise((resolve, reject) =&gt; {
    //  1s后执行reject
    setTimeout(() =&gt; {
        reject(&quot;reject&quot;);
    }, 1000);
});

const promise2 = new Promise((resolve, reject) =&gt; {
    //  2s后执行resolve
    setTimeout(() =&gt; {
        resolve(&quot;success&quot;);
    }, 2000);
});

const racedPromise = Promise.race([promise1, promise2]);

racedPromise()
.then(() =&gt; {
    alert(&quot;success&quot;);
})
.catch(() =&gt; {
    alert(&quot;fail&quot;);
});
</code></pre><p>//  显然上面的代码最终会弹出fail,因为promise1的状态比promise2先确定,所以Promise.race最终返回的是Promise1,由于状态是reject,所以走到了catch回调。</p>
<p>上面说了好多废话:</p>
<p>下面实现一个可设置timeout的fetch:</p>
<pre><code>/**
  * @param url      请求地址
  * @param opt      配置参数
  * @param timeout  
  **/
function abortFetch(url, opt, timeout) {
    if(typeof url !== &quot;string&quot;) {
    }
    const fetchIns = fetch(url, opt || {});
    const abortIns = new Promise((resolve, reject) =&gt; {
        if(typeof timeout === &quot;number&quot; &amp;&amp; timeout &gt; 0) {
            setTimeout(() =&gt; {
                reject({
                    &quot;type&quot;: &quot;abord&quot;
                });
            }, timeout);
        }
    });
    const finalPromise = Promise.race([fetchIns, abortIns]);
    return finalPromise;
}

//  用法

fetch(&quot;/fetch-timeout&quot;, {
    &quot;method&quot;: &quot;POST&quot;
})
.then((res) =&gt; res.json())
.then((res) =&gt; {
    if(res.status &gt;= 200 &amp;&amp; res.status &lt; 300 || res.status === 302) {
        //  do something response success
    } else {
        //  do something response failed
    }
})
.catch((ex) =&gt; {
    switch (ex.type) {
        case &quot;abord&quot;: 
            //  do something when request abord
        break;

            ...

        default:
            //  ...
        break;
    }
});
</code></pre><p>到这里,就利用Promise.race实现了一个可配置超时时间的fetch</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着ES6的普及,fetch已经渐渐取代了普通ajax在异步请求中的位置,以前在用jQuery中的ajax时,可以指定一个timeout属性,设置该请求的超时时间,但是原生的fetch并不支持该属性,如果遇到遇到一个请求一直pedding状态,就只能干等着,什么也干不了。由
    
    </summary>
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
      <category term="fetch" scheme="http://yoursite.com/categories/ES6/fetch/"/>
    
    
  </entry>
  
  <entry>
    <title>实现一个迷你MVVM</title>
    <link href="http://yoursite.com/2016/06/23/2016-06-23-mvvm-tourial/"/>
    <id>http://yoursite.com/2016/06/23/2016-06-23-mvvm-tourial/</id>
    <published>2016-06-22T16:00:00.000Z</published>
    <updated>2017-03-30T12:19:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>在近几年,MVVM模式一直很火热,其全称为”Model-View-ViewModel”,MVVM火的主要原因就是在用这种模式开发的,更多的只需要关注数据层的东西,不需要花额外的时间去维护视图,包括angular/Vue都是这种开发模式,但是两者的原理是截然不同的,现在参考Vue的实现原理,简单实现一个MVVM框架,支持的指令有”vm-modle”、”vm-click”、”vm-bind”,代码量大概在300行左右,先来看下用法:</p>
<pre><code>//  HTML
...

        &lt;div id=&quot;app&quot;&gt;
            &lt;input type=&quot;text&quot; class=&quot;text-filed&quot; vm-model=&quot;text&quot; /&gt;
            &lt;p class=&quot;bind-text&quot; vm-bind=&quot;text&quot;&gt;&lt;/p&gt;
            &lt;div class=&quot;click-area&quot; vm-click=&quot;clicked()&quot;&gt;点我&lt;/div&gt;
            &lt;div class=&quot;click-area&quot; vm-click=&quot;clickWitharguments(text)&quot;&gt;点我(带参数)&lt;/div&gt;
        &lt;/div&gt;

...

//  javascript

window.onload = function() {

    var clickTimes = 0, e;

    //  调用MVVM
    MVVM({
        el: document.querySelector(&quot;#app&quot;),
        data: {
            text: &quot;I&apos;m an attribute named &apos;text&apos; under data&quot;
        },
        methods: {
            clicked: function () {
                e = event;
                clickTimes ++;
                e.target.innerHTML += &quot;&lt;p&gt;第&quot; + clickTimes  + &quot;次点击 - &quot; + Date.now() + &quot;&lt;/p&gt;&quot;;
            },
            clickWitharguments: function (text) {
                e = event;
                e.target.innerHTML += &quot;&lt;p&gt;此时data.text = &quot; + text + &quot;&lt;/p&gt;&quot;;
            }
        }
    });
};
</code></pre><p>上面就是一个简单的调用了,下面我们先实现几个工具方法和定义一些基本变量:</p>
<pre><code>//  MVVM.js

//  用匿名函数自执行的方式,前面加分号的原因是为了防止压缩后的保存
;(function(root) {

    //  ...


        //  匹配指令开头(&quot;vm-click&quot;,&quot;vm-model&quot;等)
    var direcivePrefix = /^vm\-/,

        //  缓存document
        doc = document,

        //  缓存document.body
        body = doc.body,

        //  指令Map对象,用于分类存储每个表达式,方便后期更新视图
        dirsMap = {},

        //  缓存Array.prototype
        arr2 = [],

        //  缓存Object.prototype
        obj2 = {};


    /**
     * 获取对象上的类名
     * @param obj
     * @return {String}
     */
    function typeOf(obj) {
        return obj2.toString.call(obj).slice(8, -1);
    }

   /**
    * 把元素上绑定的指令转换成数组返回
    * @param el
    * @return {Array.&lt;Object&gt;}
    */
    function mapAttributeToArray(el) {
        var res = [],
            attributes, i, len;
        if (el &amp;&amp; el.nodeType === 1) {
            attributes = arr2.slice.call(el.attributes);
            attributes.forEach(function (attr) {
                if (direcivePrefix.test(attr.name)) {
                    res.push({
                        name: attr.name,
                        value: attr.value,
                        el: el
                    });
                }
            });
        }
        return res;
    }

    /**
     * 转换成驼峰写法(vm-bind -&gt; VMBind)
     * @param str
     */
    function toCamelCase(str) {
        if (str.length) {
            return str.split(&quot;-&quot;).map(function (str, index) {
                if(index &gt; 0) {
                    return str.slice(0,1).toUpperCase() + str.slice(1);
                }
                return str.toUpperCase();
            }).join(&quot;&quot;);
        }
        return &quot;&quot;;
    }


    /**
     * 递归扫描节点
     * @param rootEl        根节点
     * @param callback      扫描后的回调
     */
    function scanNode(rootEl, callback) {
        var child = arr2.slice.call(rootEl.childNodes),
            deepChild;
        if(child.length) {
            child.forEach(function (el) {
                if(el.nodeType === 1 &amp;&amp; !el.vmcomplied) {
                    callback(el);
                    scanNode(el, callback);
                }
            });
        }
    }

    /**
     * ES5(Object.defineProperty)
     * @param target
     * @param key
     */
    function defineProperty(target, key) {
        //  同时设置一个&quot;_&quot; + key的属性值,后面取值直接用
        target[&quot;_&quot; + key] = target[key];
        Object.defineProperty(target, key, {
            get: function() {
                return this[&quot;_&quot; + key];
            },
            set: function(newV) {
                //  用之前设置的&quot;_&quot; + key的值来比较
                if(newV !== this[&quot;_&quot; + key]) {
                    this[&quot;_&quot; + key] = newV;
                    this[key] = newV;

                    //  取得当前属性绑定的指令并且判断,更新视图
                    if(typeOf(dirsMap[key]) === &quot;Array&quot; &amp;&amp; dirsMap[key].length) {
                        dirsMap[key].forEach(function(dir) {
                            dir.update();
                        });
                    }
                }
            }
        });
        return target;
    }

    //  ...


})(window)
</code></pre><p>上面实现了一些工具方法,完成的功能主要有扫描子节点,把元素上绑定 的属性绑定的指令取出来变成一个数组,转驼峰等等,下面就是MVVM的入口了:</p>
<pre><code>//  MVVM.js

//  ...

/**
 * MVVM构造函数
 * @param opt
 * @return {MVVM.init}
 * @constructor
 */
function MVVM(opt) {
    //  模仿jQuery中的无&quot;new&quot;操作符
    return new MVVM.fn.init(opt);
}

MVVM.fn = MVVM.prototype = {

    //  修正原型下的构造器
    constructor: MVVM,

    /**
     * MVVM入口
     * @param opt
     */
    init: function (opt) {
        //    参数校验,转换
        this.el = (opt.el &amp;&amp; opt.el.nodeType === 1) ? opt.el : body;
        this.data = (typeOf(opt.data) === &quot;Object&quot;) ? opt.data : {};
        this.methods = (typeOf(opt.methods) === &quot;Object&quot;) ? opt.methods : {};
        this.scan();
    },

    /**
     * 扫描编译
     */
    scan: function () {

        //  从根节点开始扫描
        scanNode(this.el, function (currentEl) {

            //  取得当前元素上的指令数组
            var dirList = mapAttributeToArray(currentEl);
            if(dirList.length) {

                //  循环编译指令
                dirList.forEach(function (dir) {
                    dir.dirName = toCamelCase(dir.name);
                    if(directiveMap[dir.dirName]) {

                        //  实例化指令
                        dir.dirIns = new directiveMap[dir.dirName](currentEl, dir.value, this.data, this.methods);

                        //  给当前属性指定getter/setter
                        if(this.data[dir.value]) {
                            defineProperty(this.data, dir.value);
                           }

                        //  dirsMap[dir.value]类型判断
                        if(typeOf(dirsMap[dir.value]) !== &quot;Array&quot;) {
                            dirsMap[dir.value] = [];
                        }

                        //  vm-modle之类不需要更新视图
                        if(dir.name !== &quot;vm-model&quot;) {
                            dirsMap[dir.value].push(dir.dirIns);
                        }
                    } else {
                        //  没有找到相关指令构造函数
                        throw new Error(&quot;unsupported directive&quot; + dir.name + &quot;!&quot;);
                    }
                }, this);
            }
        }.bind(this));
    }

};

//  修改MVVM.fn.init的prototype
MVVM.fn.init.prototype = MVVM.fn;

//  挂载到全局对象
root.MVVM = MVVM;

//  ...
</code></pre><p>上面就是MVVM.js的全部内容了,MVVM的入口算是完成了,下面我们一起构造之前提到的指令:</p>
<pre><code>//  directive.js

;(function (root) {

        //  匹配指令值中的&quot;clicked()&quot;后面的&quot;()&quot;
    var bracketsReg = /\(\)/,

        //  匹配指令值中的&quot;clickWitharguments(text)&quot;后面的&quot;(text)&quot;
        bracketsArguReg = /\([\s\S]+\)/;

    /**
     * vm-bind指令
     * @param el
     * @param expr
     * @param data
     * @param methods
     * @constructor
     */
    function VMBind(el, expr, data, methods) {
        this.el = el;
        this.expr = expr;
        this.data = data;
        this.methods = methods;
        this.init();
    }

    VMBind.prototype = {

        constructor: VMBind,

        /**
         * 初始化方法
         */
        init: function () {
            this.el.textContent = this.data[&quot;_&quot; + this.expr];
        },

        /**
         * 更新视图
         */
        update: function () {
            this.init();
        }

    };

    /**
     * vm-model指令
     * @param el
     * @param expr
     * @param data
     * @param methods
     * @constructor
     */
    function VMModel(el, expr, data, methods) {
        this.oldVal = &quot;&quot;;
        this.el = el;
        this.expr = expr;
        this.data = data;
        this.methods = methods;
        this.init();
    }

    VMModel.prototype = {

        constructor: VMModel,

        /**
         * 初始化方法
         */
        init: function () {
            var currentVal;
            this.oldVal = this.data[this.expr];
            this.el.value = this.oldVal;

            //  input元素的校验
            if (this.el.tagName.toLowerCase() === &quot;input&quot;) {
                this.el.addEventListener(&quot;keyup&quot;, function () {
                    currentVal = this.el.value;

                    //  输入值较之前有变化
                    if (currentVal !== this.oldVal) {
                        this.update(currentVal);
                        this.oldVal = currentVal;
                    }
                }.bind(this), false);
            }
        },

        /**
         * 更新model中的相关属性值,触发其他指令实例下的update方法
         */
        update: function (newV) {
            this.data[this.expr] = newV;
        }

    };

    /**
     * vm-click指令
     * @param el
     * @param expr
     * @param data
     * @param methods
     * @constructor
     */
    function VMClick(el, expr, data, methods) {
        this.el = el;
        this.expr = expr;
        this.data = data;
        this.methods = methods;
        this.init();
    }

    VMClick.prototype = {
        constructor: VMClick,

        /**
         * 初始化方法
         */
        init: function () {
            //  取得方法相对于methods中的指针
            var callback = this.methods[this.expr.replace(bracketsReg, &quot;&quot;).replace(bracketsArguReg, &quot;&quot;)],
                data = this.data,
                tmp = &quot;&quot;,
                args = [];

            //  类型校验
            if (typeof callback === &quot;function&quot;) {
                this.el.addEventListener(&quot;click&quot;, function (e) {
                    //  参数处理,当前指令对应的值是&quot;abc(de)&quot;而不是&quot;abc&quot;的形式
                    if(!bracketsReg.test(this.expr) &amp;&amp; bracketsArguReg.test(this.expr)) {
                        tmp = this.expr.match(bracketsArguReg)[0].replace(&quot;)&quot;, &quot;&quot;).replace(&quot;(&quot;, &quot;&quot;).split(&quot;,&quot;);

                        //  依次取得相关参数
                        args = tmp.map(function (name) {
                            return data[&quot;_&quot; + name.trim()];
                        });
                    }

                    //  执行相关方法
                    callback.apply(root, args);
                }.bind(this), false);
            }
        }
    };

    //  挂载到window对象下
    root.directiveMap = {
        VMBind: VMBind,
        VMModel: VMModel,
        VMClick: VMClick,
    };

})(window)
</code></pre><p>好了,到这里我们的MVVM入口和指令都全部实现好了,下面一起看下效果吧:</p>
<p><img src="/imgs/mvvm-run.gif" alt="运行效果"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在近几年,MVVM模式一直很火热,其全称为”Model-View-ViewModel”,MVVM火的主要原因就是在用这种模式开发的,更多的只需要关注数据层的东西,不需要花额外的时间去维护视图,包括angular/Vue都是这种开发模式,但是两者的原理是截然不同的,现在参考V
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
      <category term="MVVM" scheme="http://yoursite.com/categories/javascript/MVVM/"/>
    
    
  </entry>
  
</feed>
