<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 从零开始写一个React - setState和生命周期 · 小宋</title><meta name="description" content="从零开始写一个React - setState和生命周期 - rwson"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="小宋"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/rwson" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">从零开始写一个React - setState和生命周期</h1><div class="post-info">Sep 14, 2017</div><div class="post-content"><p>在前面一篇中我们用<code>instantiateReactComponent</code>方法来根据<code>node</code>的不同来返回不同的组件实例，之前的分类可能有些问题，就是当该组件中<code>JSX</code>部分有返回<code>null</code>的情况，<code>instantiateReactComponent</code>就不能返回正确的组件，所以在这里加了一种新的组件类型：<code>ReactEmptyComponent</code>，作用就是返回一段空的注释，标记这是一个空组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">instantiateReactComponent</span>(<span class="params">node</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (lodash.isNull(node) || lodash.isUndefined(node)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReactEmptyComponent(<span class="literal">null</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//  ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//  空组件</span></div><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ReactEmptyComponent</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(node) &#123;</div><div class="line">        <span class="keyword">this</span>.type = <span class="string">"ReactEmptyComponent"</span>;</div><div class="line">        <span class="keyword">this</span>._currentElement = <span class="literal">null</span>;</div><div class="line">        <span class="keyword">this</span>._rootNodeID = <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     *  空组件挂载直接返回一段空注释回去</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    mountComponent(rootID) &#123;</div><div class="line">        <span class="keyword">this</span>._rootNodeID = rootID;</div><div class="line">        <span class="keyword">return</span> <span class="string">`&lt;!-- empty component data-reactid="<span class="subst">$&#123;<span class="keyword">this</span>._rootNodeID&#125;</span>" --&gt;`</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们之前简单实现了一个初始化渲染的过程，现在我们一起实现一个<code>setState</code>方法以及组件后面的更新逻辑。<code>setState</code>是在组件中被调用的，所以我们需要在之前的<code>Component</code>类中加入一个<code>setState</code>方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">//	...</span></div><div class="line"></div><div class="line">    setState(newState, callback) &#123;</div><div class="line">        <span class="keyword">const</span> stacks = StackTrace.getSync();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> &#123;functionName, source&#125; <span class="keyword">of</span> stacks) &#123;</div><div class="line">            <span class="keyword">if</span>(RENDER_REG.test(functionName) &amp;&amp; RENDER_REG.test(source)) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"callStack Error: you can't call setState in render method!"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>._reactInternalInstance.receiveComponent(<span class="literal">null</span>, newState);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (lodash.isFunction(callback)) &#123;</div><div class="line">            callback();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="comment">//	...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之前一篇我们说到一共可分成文本组件，浏览器标签组件，自定义标签组件，所以我们需要在这三个组件中各实现一个<code>receiveComponent</code>来接收新组件并且实现相应更新：</p>
<p>对于普通的文本节点，要做的相对简单，就是在<code>receiveComponent</code>中去更新相关<code>DOM</code>的<code>textContent</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ReactDOMTextComponent</span> </span>&#123;</div><div class="line">  	<span class="comment">//	...</span></div><div class="line">  </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     *  接收到新组件</span></div><div class="line"><span class="comment">     *  @param   &#123;String&#125;  text  [接收到的新组件]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    receiveComponent(text) &#123;</div><div class="line">        <span class="keyword">const</span> nextStringText = (<span class="string">""</span> + text);</div><div class="line">        <span class="keyword">if</span> (nextStringText !== <span class="keyword">this</span>._currentElement) &#123;</div><div class="line">            <span class="keyword">this</span>._currentElement = nextStringText;</div><div class="line">          	<span class="comment">//	更新相关DOM的textContent</span></div><div class="line">            $(<span class="string">`[data-reactid='<span class="subst">$&#123;<span class="keyword">this</span>._rootNodeID&#125;</span>']`</span>).textContent = nextStringText;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在自定标签组件中，我们需要做的事情大概如下</p>
<ul>
<li>如果调用时传入了新的<code>Vnode</code>就把当前的<code>_currentElement</code>改成新传入的<code>Vnode</code></li>
<li>合并新老<code>state</code></li>
<li>调用组件实例下的<code>shouldComponentUpdate</code>根据返回的布尔值去判断是否需要更新组件</li>
<li>调用组件实例下的<code>componentWillUpdate</code></li>
<li>调用组件的<code>render</code>去拿到新的<code>Vnode</code>，和之前的做对比，如果之前的组件<code>Vnode</code>不存在，就直接调用<code>instantiateReactComponent</code>返回新的组件实例</li>
<li>调用组件生命周期下的<code>componentDidUpdate</code>方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ReactCompositeComponent</span> </span>&#123;</div><div class="line">    <span class="comment">//	...</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     *  接收到新组件, 更新实例下的state, 组件生命周期方法调用</span></div><div class="line"><span class="comment">     *  @param   &#123;ReactElement&#125;  nextElement  [新的Vnode]</span></div><div class="line"><span class="comment">     *  @param   &#123;Object&#125;        newState     [this.setState(state)中的state]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    receiveComponent(nextElement, newState) &#123;</div><div class="line">        <span class="comment">//  如果接受了新的, 就使用最新的element</span></div><div class="line">        <span class="keyword">this</span>._currentElement = nextElement || <span class="keyword">this</span>._currentElement;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> &#123; _rootNodeID &#125; = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">        <span class="keyword">let</span> inst = <span class="keyword">this</span>._instance,</div><div class="line"></div><div class="line">            <span class="comment">//  nextState和nextProps的处理</span></div><div class="line">            nextState = <span class="built_in">Object</span>.assign(inst.state || &#123;&#125;, newState),</div><div class="line">            nextProps = lodash.clone(<span class="keyword">this</span>._currentElement.props),</div><div class="line">            finalProps,</div><div class="line">            prevComponentInstance,</div><div class="line">            prevRenderedElement,</div><div class="line">            nextRenderedElement,</div><div class="line">            nextMarkup,</div><div class="line">            child;</div><div class="line"></div><div class="line">        <span class="comment">//  修改组件的state和props</span></div><div class="line">        <span class="keyword">this</span>._instance.state = nextState;</div><div class="line">        <span class="keyword">this</span>._instance.props = nextProps;</div><div class="line">        inst.state = nextState;</div><div class="line">        inst.props = nextProps;</div><div class="line"></div><div class="line">        <span class="comment">//  声明周期shouldComponentUpdate</span></div><div class="line">        <span class="keyword">if</span> (!inst.shouldComponentUpdate(nextProps, nextState)) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//  声明周期componentWillUpdate</span></div><div class="line">        inst.componentWillUpdate(nextProps, nextState);</div><div class="line"></div><div class="line">        <span class="comment">//  之前的组件组件实例</span></div><div class="line">        prevComponentInstance = <span class="keyword">this</span>._renderedComponent;</div><div class="line"></div><div class="line">        <span class="comment">//  之前的组件元素</span></div><div class="line">        prevRenderedElement = prevComponentInstance._currentElement;</div><div class="line"></div><div class="line">        <span class="comment">//  即将被渲染的新组件元素</span></div><div class="line">        nextRenderedElement = inst.render();</div><div class="line"></div><div class="line">        <span class="comment">//  判断是需要更新还是直接就重新渲染</span></div><div class="line">        <span class="keyword">if</span> (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) &#123;</div><div class="line">            prevComponentInstance.receiveComponent(nextRenderedElement);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//  重新new一个对应的component</span></div><div class="line">            <span class="keyword">this</span>._renderedComponent = instantiateReactComponent(nextRenderedElement);</div><div class="line"></div><div class="line">            <span class="comment">//  重新生成对应的元素内容</span></div><div class="line">            nextMarkup = <span class="keyword">this</span>._renderedComponent.mountComponent(_rootNodeID);</div><div class="line"></div><div class="line">            <span class="comment">//  替换整个节点</span></div><div class="line">            $(<span class="string">`[data-reactid="<span class="subst">$&#123;_rootNodeID&#125;</span>"]`</span>).innerHTML = nextMarkup;</div><div class="line">        &#125;</div><div class="line">        inst.componentDidUpdate();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在组件的<code>render</code>被重新调用之后，最后还是需要要更新<code>DOM</code>的，所以在<code>ReactDOMComponent</code>下的<code>receiveComponent</code>里我们需要对组件里的<code>DOM</code>下的属性和结构进行更新。</p>
<p>在<code>React</code>中，有一套<code>diff</code>算法来比较新老组件间的差异，返回需要更新的队列，然后统一对<code>DOM</code>结构进行更新，在<code>ReactDOMComponent</code>下的<code>receiveComponent</code>中，我们需要完成下面的几件事情</p>
<ul>
<li>拿到老的<code>props</code>和新的<code>props</code>做，在<code>_updateDOMProperties</code>中对<code>DOM</code>下的属性进行更新</li>
<li>调用<code>_updateDOMChildren</code>，传入新的组件子节点，去拼凑差异队列，然后更新<code>DOM</code></li>
<li>修改<code>currentElement</code>变成本次渲染的，供下次使用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ReactDOMComponent</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     *  接收到新组件</span></div><div class="line"><span class="comment">     *  @param   &#123;Object&#125;  nextElement  [新组件]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    receiveComponent(nextElement) &#123;</div><div class="line">        <span class="keyword">const</span> lastProps = lodash.clone(<span class="keyword">this</span>._currentElement.props),</div><div class="line">            nextProps = nextElement.props;</div><div class="line"></div><div class="line">        <span class="comment">//  需要单独的更新属性</span></div><div class="line">        <span class="keyword">this</span>._updateDOMProperties(lastProps, nextProps);</div><div class="line"></div><div class="line">        <span class="comment">//  再更新子节点</span></div><div class="line">        <span class="keyword">this</span>._updateDOMChildren(nextElement.props.children);</div><div class="line"></div><div class="line">        <span class="comment">//  修改currentElement变成本次渲染的</span></div><div class="line">        <span class="keyword">this</span>._currentElement = nextElement;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     *  更新组件中相关DOM的属性</span></div><div class="line"><span class="comment">     *  @param    &#123;Object&#125;  lastProps  [旧属性]</span></div><div class="line"><span class="comment">     *  @param    &#123;Object&#125;  nextProps  [新属性]</span></div><div class="line"><span class="comment">     *  @private</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    _updateDOMProperties(lastProps, nextProps) &#123;</div><div class="line">        <span class="keyword">const</span> &#123; _rootNodeID &#125; = <span class="keyword">this</span>,</div><div class="line">        element = $(<span class="string">`[data-reactid="<span class="subst">$&#123;_rootNodeID&#125;</span>"]`</span>);</div><div class="line">        <span class="keyword">let</span> propKey, propValue, eventType, removed;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (propKey <span class="keyword">in</span> lastProps) &#123;</div><div class="line">            <span class="comment">//  只删除老属性中有但是新属性中没有的</span></div><div class="line">            <span class="keyword">if</span> (hasOwnProperty(lastProps, propKey) &amp;&amp; !hasOwnProperty(nextProps, propKey)) &#123;</div><div class="line">                propValue = lastProps[propKey];</div><div class="line"></div><div class="line">                <span class="comment">//  之前的事件代理需要解除</span></div><div class="line">                <span class="keyword">if</span> (EVENT_REG.test(propKey)) &#123;</div><div class="line">                    eventType = propKey.replace(<span class="string">"on"</span>, <span class="string">""</span>);</div><div class="line">                    Event.undelegate(&#123;</div><div class="line">                        element: doc,</div><div class="line">                        type: eventType,</div><div class="line">                        selector: <span class="string">`[data-reactid="<span class="subst">$&#123;_rootNodeID&#125;</span>"]`</span></div><div class="line">                    &#125;);</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === <span class="string">"className"</span>) &#123;</div><div class="line">                    removed = <span class="string">"class"</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    removed = propKey;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">//  删除DOM上的相关属性</span></div><div class="line">                element.removeAttribute(removed);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//  开始遍历新属性集合</span></div><div class="line">        <span class="keyword">for</span> (propKey <span class="keyword">in</span> nextProps) &#123;</div><div class="line">            <span class="keyword">if</span> (hasOwnProperty(nextProps, propKey) &amp;&amp; propKey !== <span class="string">"children"</span>) &#123;</div><div class="line">                propValue = lastProps[propKey];</div><div class="line">              	<span class="comment">//	重新代理事件</span></div><div class="line">                <span class="keyword">if</span> (EVENT_REG.test(propKey)) &#123;</div><div class="line">                    eventType = propKey.replace(<span class="string">"on"</span>, <span class="string">""</span>);</div><div class="line">                    Event.undelegate(&#123;</div><div class="line">                        element: doc,</div><div class="line">                        type: eventType,</div><div class="line">                        selector: <span class="string">`[data-reactid="<span class="subst">$&#123;_rootNodeID&#125;</span>"]`</span></div><div class="line">                    &#125;);</div><div class="line">                    Event.delegate(&#123;</div><div class="line">                        element: doc,</div><div class="line">                        type: eventType,</div><div class="line">                        selector: <span class="string">`[data-reactid="<span class="subst">$&#123;_rootNodeID&#125;</span>"]`</span>,</div><div class="line">                        handler: propValue,</div><div class="line">                        context: <span class="literal">null</span></div><div class="line">                    &#125;);</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === <span class="string">"className"</span>) &#123;</div><div class="line">                    element.setAttribute(<span class="string">"class"</span>, propValue);</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === <span class="string">"style"</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (lodash.isObject(propValue)) &#123;</div><div class="line">                        propValue = toStyle.string(propValue);</div><div class="line">                    &#125;</div><div class="line">                    element.setAttribute(propKey, propValue);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    element.setAttribute(propKey, propValue);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     *  更新子元素</span></div><div class="line"><span class="comment">     *  @param    &#123;Array&#125;  nextChildrenElements  [被更新的组件队列]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    _updateDOMChildren(nextChildrenElements) &#123;</div><div class="line">        <span class="keyword">if</span> (nextChildrenElements &amp;&amp; nextChildrenElements.length) &#123;</div><div class="line"></div><div class="line">            update.updateDepth++;</div><div class="line">            <span class="comment">//  递归找出差别, 组装差异对象</span></div><div class="line">            update.diff(update.diffQueue, nextChildrenElements, <span class="keyword">this</span>);</div><div class="line">            update.updateDepth--;</div><div class="line"></div><div class="line">            <span class="comment">//  应用更新</span></div><div class="line">            <span class="keyword">if</span> (update.updateDepth === <span class="number">0</span>) &#123;</div><div class="line">                update.patch(update.diffQueue);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>_updateDOMChildren</code>中我们调用了<code>update.diff</code>和<code>update.patch</code>方法，一个对比一个应用，这里我是把<code>diff</code>和<code>patch</code>放到一个对象下作为一个模块暴露出去的，下面就是具体的实现代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//	定义更新类型(移动已经存在的，删除节点，插入的新标签)</span></div><div class="line"><span class="keyword">const</span> UPDATE_TYPES = &#123;</div><div class="line">    MOVE_EXISTING: <span class="number">1</span>,</div><div class="line">    REMOVE_NODE: <span class="number">2</span>,</div><div class="line">    INSERT_MARKUP: <span class="number">3</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> update = &#123;</div><div class="line">    <span class="comment">//  更新深度标识</span></div><div class="line">    updateDepth: <span class="number">0</span>,</div><div class="line"></div><div class="line">    <span class="comment">//  更新队列</span></div><div class="line">    diffQueue: [],</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     *  递归找出差别, 组装差异对象, 添加到更新队列diffQueue</span></div><div class="line"><span class="comment">     *  @param   &#123;Array&#125;  diffQueue             [更新队列]</span></div><div class="line"><span class="comment">     *  @param   &#123;Array&#125;  nextChildrenElements  [新的子组件集合]</span></div><div class="line"><span class="comment">     *  @param   &#123;Object&#125; component             [被diff的组件]</span></div><div class="line"><span class="comment">     *  @return  &#123;Array&#125;                        [需要更新的内容]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    diff(diffQueue, nextChildrenElements, component) &#123;</div><div class="line">        <span class="comment">//  获取到当前组件下已经渲染的组件集合，把component._renderedChildren扁平成一个对象，如果child有key，就拿key作为对应的属性名，否则用下标做属性名，具体实现可以看下面</span></div><div class="line">        <span class="keyword">const</span> prevChildren = flattenChildren(component._renderedChildren),</div><div class="line"></div><div class="line">            <span class="comment">//  生成新的子节点的component对象集合(如果是组件有更新, 就复用原来的, 如果是新增就是新的组件实例)</span></div><div class="line">            nextChildren = generateComponentChildren(prevChildren, nextChildrenElements);</div><div class="line"></div><div class="line">        <span class="keyword">let</span> lastIndex = <span class="number">0</span>,</div><div class="line">            nextIndex = <span class="number">0</span>,</div><div class="line">            prevChild = <span class="literal">null</span>,</div><div class="line">            nextChild = <span class="literal">null</span>,</div><div class="line">            name, props, propKey, eventType;</div><div class="line"></div><div class="line">        <span class="comment">//  枚举nextChildren</span></div><div class="line">        <span class="keyword">for</span> (name <span class="keyword">in</span> nextChildren) &#123;</div><div class="line">            <span class="keyword">if</span> (!hasOwnProperty(nextChildren, name)) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            prevChild = prevChildren &amp;&amp; prevChildren[name];</div><div class="line">            nextChild = nextChildren[name];</div><div class="line"></div><div class="line">            <span class="comment">//  两个相同说明是使用的同一个component,所以我们需要做移动的操作</span></div><div class="line">            <span class="keyword">if</span> (lodash.isEqual(prevChild, nextChild)) &#123;</div><div class="line">                <span class="keyword">if</span> (prevChild._mountIndex &lt; lastIndex) &#123;</div><div class="line">                    <span class="keyword">this</span>.diffQueue.push(&#123;</div><div class="line">                        parentId: component._rootNodeID,</div><div class="line">                        parentNode: $(<span class="string">`[data-reactid="<span class="subst">$&#123;component._rootNodeID&#125;</span>"]`</span>),</div><div class="line">                        type: UPDATE_TYPES.MOVE_EXISTING,</div><div class="line">                      	<span class="comment">//	从组件原来的mountIndex</span></div><div class="line">                        fromIndex: prevChild._mountIndex,</div><div class="line">                      	<span class="comment">//	到nextIndex</span></div><div class="line">                        toIndex: nextIndex</div><div class="line">                    &#125;);</div><div class="line">                &#125;</div><div class="line">              </div><div class="line">              	<span class="comment">//	缓存上次遍历时最大的index</span></div><div class="line">                lastIndex = <span class="built_in">Math</span>.max(prevChild._mountIndex, lastIndex);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//  之前存在子节点, 需要先将子节点移除</span></div><div class="line">                <span class="keyword">if</span> (prevChild) &#123;</div><div class="line">                    <span class="keyword">this</span>.diffQueue.push(&#123;</div><div class="line">                        parentId: component._rootNodeID,</div><div class="line">                        parentNode: $(<span class="string">`[data-reactid="<span class="subst">$&#123;component._rootNodeID&#125;</span>"]`</span>),</div><div class="line">                        type: UPDATE_TYPES.REMOVE_NODE,</div><div class="line">                        fromIndex: prevChild._mountIndex,</div><div class="line">                        toIndex: <span class="literal">null</span></div><div class="line">                    &#125;);</div><div class="line">                    lastIndex = <span class="built_in">Math</span>.max(prevChild._mountIndex, lastIndex);</div><div class="line"></div><div class="line">                    props = (prevChild._currentElement &amp;&amp; prevChild._currentElement.props) ? prevChild._currentElement.props : &#123;&#125;;</div><div class="line"></div><div class="line">                  	<span class="comment">//	对移除的子节点需要进行事件代理的接触，防止重复</span></div><div class="line">                    <span class="keyword">for</span> (propKey <span class="keyword">in</span> props) &#123;</div><div class="line">                        <span class="keyword">if</span> (hasOwnProperty(props, propKey) &amp;&amp; EVENT_REG.test(propKey)) &#123;</div><div class="line">                            eventType = propKey.replace(<span class="string">"on"</span>, <span class="string">""</span>);</div><div class="line">                            Event.undelegate(&#123;</div><div class="line">                                element: doc,</div><div class="line">                                type: eventType,</div><div class="line">                                selector: <span class="string">`[data-reactid="<span class="subst">$&#123;prevChild._rootNodeID&#125;</span>"]`</span></div><div class="line">                            &#125;);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">//  新增的节点, 需要push到diffQueue</span></div><div class="line">                <span class="keyword">if</span> (nextChild) &#123;</div><div class="line">                    <span class="keyword">this</span>.diffQueue.push(&#123;</div><div class="line">                        parentId: component._rootNodeID,</div><div class="line">                        parentNode: $(<span class="string">`[data-reactid="<span class="subst">$&#123;component._rootNodeID&#125;</span>"]`</span>),</div><div class="line">                        type: UPDATE_TYPES.INSERT_MARKUP,</div><div class="line">                        fromIndex: <span class="literal">null</span>,</div><div class="line">                        toIndex: nextIndex,</div><div class="line">                        markup: nextChild.mountComponent(<span class="string">`<span class="subst">$&#123;component._rootNodeID&#125;</span>.<span class="subst">$&#123;name&#125;</span>`</span>)</div><div class="line">                    &#125;);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//  更新_mountIndex和nextIndex</span></div><div class="line">            nextChild._mountIndex = nextIndex;</div><div class="line">            nextIndex++;</div><div class="line"></div><div class="line">            <span class="comment">//  把nextChildren克隆一份给_renderedChildren</span></div><div class="line">            component._renderedChildren = makeArray(nextChildren);</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     *  应用更新, 执行DOM操作</span></div><div class="line"><span class="comment">     *  @param   &#123;Array&#125;  updates  [差异对象集合]</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    patch(updates) &#123;</div><div class="line">        <span class="keyword">let</span> initialChildren = &#123;&#125;,</div><div class="line">            deleteChildren = [],</div><div class="line">            updatedIndex, updatedChild, parentID;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> update <span class="keyword">of</span> updates) &#123;</div><div class="line">            updatedIndex = update.fromIndex;</div><div class="line">            updatedChild = update.parentNode.children[updatedIndex];</div><div class="line">            parentID = update.parentID;</div><div class="line"></div><div class="line">            <span class="comment">//  把所有需要更新的节点都保存下来</span></div><div class="line">            initialChildren[parentID] = initialChildren[parentID] || [];</div><div class="line"></div><div class="line">            <span class="comment">//  使用parentID作为简易命名空间</span></div><div class="line">            initialChildren[parentID][updatedIndex] = updatedChild;</div><div class="line"></div><div class="line">            <span class="comment">//  所有需要修改的节点先删除,对于move的,后面再重新插入到正确的位置即可</span></div><div class="line">            <span class="keyword">if</span> (!lodash.isNull(updatedChild) &amp;&amp; !lodash.isUndefined(updatedChild)) &#123;</div><div class="line">                deleteChildren.push(updatedChild);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//  删除需要删除的节点</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> child <span class="keyword">of</span> deleteChildren) &#123;</div><div class="line">            child.parentNode.removeChild(child);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> updateItem <span class="keyword">of</span> updates) &#123;</div><div class="line">            <span class="keyword">switch</span> (updateItem.type) &#123;</div><div class="line">                <span class="comment">//  插入新元素</span></div><div class="line">                <span class="keyword">case</span> UPDATE_TYPES.INSERT_MARKUP:</div><div class="line">                    insertChildAt(updateItem.parentNode, updateItem.markup, updateItem.toIndex);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line"></div><div class="line">                    <span class="comment">//  元素位置发生改变    </span></div><div class="line">                <span class="keyword">case</span> UPDATE_TYPES.MOVE_EXISTING:</div><div class="line">                    insertChildAt(updateItem.parentNode, initialChildren[updateItem.parentID][updateItem.fromIndex], updateItem.toIndex);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line"></div><div class="line">                    <span class="comment">//  上面已经删除, 所以不需要处理</span></div><div class="line">                <span class="keyword">case</span> UPDATE_TYPES.REMOVE_NODE:</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line"></div><div class="line">                <span class="keyword">default</span>:</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//  重置相关变量</span></div><div class="line">        <span class="keyword">this</span>.reset();</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     *  重置相关变量</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    reset() &#123;</div><div class="line">        <span class="keyword">this</span>.updateDepth = <span class="number">0</span>;</div><div class="line">        <span class="keyword">this</span>.diffQueue = [];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在<code>diff</code>中，我们看到了两个新方法，分别是<code>flattenChildren</code>和<code>generateComponentChildren</code>，我们先看下<code>flattenChildren</code>的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> *  把原来是数组的子组件集合转换成Map返回</span></div><div class="line"><span class="comment"> *  @param   &#123;Array&#125;  componentChildren     [子组件集合]</span></div><div class="line"><span class="comment"> *  @return  &#123;Object&#125;                       [输出的Map, 每个子组件的key或者一个随机数做key]</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">flattenChildren</span>(<span class="params">componentChildren</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> childrenMap = &#123;&#125;,</div><div class="line">        child, name, i, len;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, len = componentChildren.length; i &lt; len; i++) &#123;</div><div class="line">        child = componentChildren[i];</div><div class="line">        name = child &amp;&amp; child._currentelement &amp;&amp; child._currentelement.key ? child._currentelement.key : i.toString(<span class="number">36</span>);</div><div class="line">        childrenMap[name] = child;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> childrenMap;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>generateComponentChildren</code>我们大概需要完成下面几件事情：</p>
<ul>
<li>遍历拿到即将渲染的新组件<code>children</code>（做参数 <code>nextChildrenElements</code>传入）和老节点进行对比</li>
<li>如果老节点存在且和新节点有差异，即调用老节点下的<code>receiveComponent</code>去更新</li>
<li>否则如果老节点不存在，则重新调用<code>instantiateReactComponent</code>返回一个组件实例</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> *  生成子节点elements的component集合</span></div><div class="line"><span class="comment"> *  @param   &#123;Object&#125;  prevChildren          [flattenChildren返回的Map]</span></div><div class="line"><span class="comment"> *  @param   &#123;Array&#125;   nextChildrenElements  [即将要渲染的节点]</span></div><div class="line"><span class="comment"> *  @return  &#123;Object&#125;                        [子节点elements的component集合]</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateComponentChildren</span>(<span class="params">prevChildren, nextChildrenElements</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> nextChildren = &#123;&#125;,</div><div class="line">        index, len, name, prevChild, prevElement, nextElement, nextChildInstance, element;</div><div class="line">    nextChildrenElements = nextChildrenElements || [];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>, len = nextChildrenElements.length; index &lt; len; index++) &#123;</div><div class="line">        element = nextChildrenElements[index];</div><div class="line">        name = (element &amp;&amp; element.key) ? element.key : index;</div><div class="line">        prevChild = prevChildren &amp;&amp; prevChildren[name];</div><div class="line">        prevElement = prevChild &amp;&amp; prevChild._currentElement;</div><div class="line">        nextElement = element;</div><div class="line"></div><div class="line">        <span class="comment">//  组件有更新, 调用当前组件下的reciveComponent去更新组件</span></div><div class="line">        <span class="keyword">if</span> (shouldUpdateReactComponent(prevElement, nextElement)) &#123;</div><div class="line">            prevChild.receiveComponent(nextElement);</div><div class="line">            nextChildren[name] = prevChild;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//  新节点, 实例化新组件</span></div><div class="line">            nextChildInstance = instantiateReactComponent(nextElement);</div><div class="line">            nextChildren[name] = nextChildInstance;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> nextChildren;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在之前好几个地方我们都看到了<code>shouldUpdateReactComponent</code>这个方法，它完成的功能主要是判断两个<code>Vnode</code>之前是否有差异，返回布尔值，主要完成下面几件事情：</p>
<ul>
<li>如果新老<code>Vnode</code>有一个或者都为空，直接返回<code>false</code></li>
<li>文本节点之间的对比</li>
<li>当新的<code>Vnode</code>的<code>type</code>是<code>object</code>，比较老节点的<code>type</code>和<code>key</code>，并且拿到两者的<code>children</code>数组，做一个简单的长度对比</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> *  判断组件是否需要更新</span></div><div class="line"><span class="comment"> *  @param   &#123;Object&#125;  prevElement  [老的vnode]</span></div><div class="line"><span class="comment"> *  @param   &#123;Object&#125;  nextElement  [新的vnode]</span></div><div class="line"><span class="comment"> *  @return  &#123;Boolean&#125;              [标识组件是否需要更新]</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">shouldUpdateReactComponent</span>(<span class="params">prevElement, nextElement</span>) </span>&#123;</div><div class="line">    <span class="comment">//  排除为空的情况</span></div><div class="line">    <span class="keyword">if</span> (!lodash.isNull(prevElement) &amp;&amp; !lodash.isNull(nextElement) &amp;&amp; !lodash.isUndefined(prevElement) &amp;&amp; !lodash.isUndefined(nextElement)) &#123;</div><div class="line">        <span class="keyword">const</span> prevType = <span class="keyword">typeof</span> prevElement,</div><div class="line">            nextType = <span class="keyword">typeof</span> nextElement;</div><div class="line"></div><div class="line">        <span class="comment">//  纯文本组件</span></div><div class="line">        <span class="keyword">if</span> (prevType === <span class="string">"number"</span> || prevType === <span class="string">"string"</span>) &#123;</div><div class="line">            <span class="keyword">return</span> (nextType === <span class="string">"number"</span> || nextType === <span class="string">"number"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">let</span> prevChildren = [],</div><div class="line">                nextChildren = [],</div><div class="line">                childEqual = <span class="literal">true</span>;</div><div class="line"></div><div class="line">            <span class="keyword">if</span>(prevElement &amp;&amp; prevElement.props) &#123;</div><div class="line">                prevChildren = prevElement.props.children || [];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (nextElement &amp;&amp; nextElement.props) &#123;</div><div class="line">                nextChildren = nextElement.props.children || [];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            childEqual = prevChildren.length === nextChildren.length;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> (nextType === <span class="string">"object"</span> &amp;&amp;</div><div class="line">                (prevElement.type === nextElement.type) &amp;&amp;</div><div class="line">                (prevElement.key === nextElement.key) &amp;&amp;</div><div class="line">                childEqual);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里我们就实现一个<code>setState</code>和生命周期，在例子中实现了一个<code>Todo</code>，一起看下效果</p>
<p><img src="/imgs/todo.gif" alt="todo"></p>
<p>至此我们就实现了一个简单的<code>React</code>，但是仅仅实现了<code>虚拟节点</code>，<code>差异算法</code>，<code>props单向数据流</code>，还有很多更优秀的没实现，比如批量更新，事件优化，组件中的<code>refs</code>，服务端渲染等等，只是一个玩具，对于想深入了解<code>React</code>原理的可能会有些帮助。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/09/25/2017-09-25-read-webpack-source/" class="prev">上一篇</a><a href="/2017/09/04/2017-09-04-write-your-own-react-1/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://yoursite.com">rwson</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>