<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 从零开始写一个React - setState和生命周期 · 小宋</title><meta name="description" content="从零开始写一个React - setState和生命周期 - rwson"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="小宋"><link rel="alternate" href="/atom.xml" title="小宋" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">从零开始写一个React - setState和生命周期</h1><div class="post-info">Sep 14, 2017</div><div class="post-content"><p>在前面一篇中我们用<code>instantiateReactComponent</code>方法来根据<code>node</code>的不同来返回不同的组件实例，之前的分类可能有些问题，就是当该组件中<code>JSX</code>部分有返回<code>null</code>的情况，<code>instantiateReactComponent</code>就不能返回正确的组件，所以在这里加了一种新的组件类型：<code>ReactEmptyComponent</code>，作用就是返回一段空的注释，标记这是一个空组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">instantiateReactComponent</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lodash.isNull(node) || lodash.isUndefined(node)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReactEmptyComponent(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  空组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ReactEmptyComponent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(node) &#123;</span><br><span class="line">        <span class="keyword">this</span>.type = <span class="string">"ReactEmptyComponent"</span>;</span><br><span class="line">        <span class="keyword">this</span>._currentElement = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>._rootNodeID = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  空组件挂载直接返回一段空注释回去</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    mountComponent(rootID) &#123;</span><br><span class="line">        <span class="keyword">this</span>._rootNodeID = rootID;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`&lt;!-- empty component data-reactid="<span class="subst">$&#123;<span class="keyword">this</span>._rootNodeID&#125;</span>" --&gt;`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们之前简单实现了一个初始化渲染的过程，现在我们一起实现一个<code>setState</code>方法以及组件后面的更新逻辑。<code>setState</code>是在组件中被调用的，所以我们需要在之前的<code>Component</code>类中加入一个<code>setState</code>方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//	...</span></span><br><span class="line"></span><br><span class="line">    setState(newState, callback) &#123;</span><br><span class="line">        <span class="keyword">const</span> stacks = StackTrace.getSync();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> &#123;functionName, source&#125; <span class="keyword">of</span> stacks) &#123;</span><br><span class="line">            <span class="keyword">if</span>(RENDER_REG.test(functionName) &amp;&amp; RENDER_REG.test(source)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"callStack Error: you can't call setState in render method!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>._reactInternalInstance.receiveComponent(<span class="literal">null</span>, newState);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lodash.isFunction(callback)) &#123;</span><br><span class="line">            callback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//	...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前一篇我们说到一共可分成文本组件，浏览器标签组件，自定义标签组件，所以我们需要在这三个组件中各实现一个<code>receiveComponent</code>来接收新组件并且实现相应更新：</p>
<p>对于普通的文本节点，要做的相对简单，就是在<code>receiveComponent</code>中去更新相关<code>DOM</code>的<code>textContent</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ReactDOMTextComponent</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//	...</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  接收到新组件</span></span><br><span class="line"><span class="comment">     *  @param   &#123;String&#125;  text  [接收到的新组件]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    receiveComponent(text) &#123;</span><br><span class="line">        <span class="keyword">const</span> nextStringText = (<span class="string">""</span> + text);</span><br><span class="line">        <span class="keyword">if</span> (nextStringText !== <span class="keyword">this</span>._currentElement) &#123;</span><br><span class="line">            <span class="keyword">this</span>._currentElement = nextStringText;</span><br><span class="line">          	<span class="comment">//	更新相关DOM的textContent</span></span><br><span class="line">            $(<span class="string">`[data-reactid='<span class="subst">$&#123;<span class="keyword">this</span>._rootNodeID&#125;</span>']`</span>).textContent = nextStringText;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在自定标签组件中，我们需要做的事情大概如下</p>
<ul>
<li>如果调用时传入了新的<code>Vnode</code>就把当前的<code>_currentElement</code>改成新传入的<code>Vnode</code></li>
<li>合并新老<code>state</code></li>
<li>调用组件实例下的<code>shouldComponentUpdate</code>根据返回的布尔值去判断是否需要更新组件</li>
<li>调用组件实例下的<code>componentWillUpdate</code></li>
<li>调用组件的<code>render</code>去拿到新的<code>Vnode</code>，和之前的做对比，如果之前的组件<code>Vnode</code>不存在，就直接调用<code>instantiateReactComponent</code>返回新的组件实例</li>
<li>调用组件生命周期下的<code>componentDidUpdate</code>方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ReactCompositeComponent</span> </span>&#123;</span><br><span class="line">    <span class="comment">//	...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  接收到新组件, 更新实例下的state, 组件生命周期方法调用</span></span><br><span class="line"><span class="comment">     *  @param   &#123;ReactElement&#125;  nextElement  [新的Vnode]</span></span><br><span class="line"><span class="comment">     *  @param   &#123;Object&#125;        newState     [this.setState(state)中的state]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    receiveComponent(nextElement, newState) &#123;</span><br><span class="line">        <span class="comment">//  如果接受了新的, 就使用最新的element</span></span><br><span class="line">        <span class="keyword">this</span>._currentElement = nextElement || <span class="keyword">this</span>._currentElement;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> &#123; _rootNodeID &#125; = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> inst = <span class="keyword">this</span>._instance,</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  nextState和nextProps的处理</span></span><br><span class="line">            nextState = <span class="built_in">Object</span>.assign(inst.state || &#123;&#125;, newState),</span><br><span class="line">            nextProps = lodash.clone(<span class="keyword">this</span>._currentElement.props),</span><br><span class="line">            finalProps,</span><br><span class="line">            prevComponentInstance,</span><br><span class="line">            prevRenderedElement,</span><br><span class="line">            nextRenderedElement,</span><br><span class="line">            nextMarkup,</span><br><span class="line">            child;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  修改组件的state和props</span></span><br><span class="line">        <span class="keyword">this</span>._instance.state = nextState;</span><br><span class="line">        <span class="keyword">this</span>._instance.props = nextProps;</span><br><span class="line">        inst.state = nextState;</span><br><span class="line">        inst.props = nextProps;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  声明周期shouldComponentUpdate</span></span><br><span class="line">        <span class="keyword">if</span> (!inst.shouldComponentUpdate(nextProps, nextState)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  声明周期componentWillUpdate</span></span><br><span class="line">        inst.componentWillUpdate(nextProps, nextState);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  之前的组件组件实例</span></span><br><span class="line">        prevComponentInstance = <span class="keyword">this</span>._renderedComponent;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  之前的组件元素</span></span><br><span class="line">        prevRenderedElement = prevComponentInstance._currentElement;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  即将被渲染的新组件元素</span></span><br><span class="line">        nextRenderedElement = inst.render();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  判断是需要更新还是直接就重新渲染</span></span><br><span class="line">        <span class="keyword">if</span> (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) &#123;</span><br><span class="line">            prevComponentInstance.receiveComponent(nextRenderedElement);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//  重新new一个对应的component</span></span><br><span class="line">            <span class="keyword">this</span>._renderedComponent = instantiateReactComponent(nextRenderedElement);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  重新生成对应的元素内容</span></span><br><span class="line">            nextMarkup = <span class="keyword">this</span>._renderedComponent.mountComponent(_rootNodeID);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  替换整个节点</span></span><br><span class="line">            $(<span class="string">`[data-reactid="<span class="subst">$&#123;_rootNodeID&#125;</span>"]`</span>).innerHTML = nextMarkup;</span><br><span class="line">        &#125;</span><br><span class="line">        inst.componentDidUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在组件的<code>render</code>被重新调用之后，最后还是需要要更新<code>DOM</code>的，所以在<code>ReactDOMComponent</code>下的<code>receiveComponent</code>里我们需要对组件里的<code>DOM</code>下的属性和结构进行更新。</p>
<p>在<code>React</code>中，有一套<code>diff</code>算法来比较新老组件间的差异，返回需要更新的队列，然后统一对<code>DOM</code>结构进行更新，在<code>ReactDOMComponent</code>下的<code>receiveComponent</code>中，我们需要完成下面的几件事情</p>
<ul>
<li>拿到老的<code>props</code>和新的<code>props</code>做，在<code>_updateDOMProperties</code>中对<code>DOM</code>下的属性进行更新</li>
<li>调用<code>_updateDOMChildren</code>，传入新的组件子节点，去拼凑差异队列，然后更新<code>DOM</code></li>
<li>修改<code>currentElement</code>变成本次渲染的，供下次使用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ReactDOMComponent</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  接收到新组件</span></span><br><span class="line"><span class="comment">     *  @param   &#123;Object&#125;  nextElement  [新组件]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    receiveComponent(nextElement) &#123;</span><br><span class="line">        <span class="keyword">const</span> lastProps = lodash.clone(<span class="keyword">this</span>._currentElement.props),</span><br><span class="line">            nextProps = nextElement.props;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  需要单独的更新属性</span></span><br><span class="line">        <span class="keyword">this</span>._updateDOMProperties(lastProps, nextProps);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  再更新子节点</span></span><br><span class="line">        <span class="keyword">this</span>._updateDOMChildren(nextElement.props.children);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  修改currentElement变成本次渲染的</span></span><br><span class="line">        <span class="keyword">this</span>._currentElement = nextElement;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  更新组件中相关DOM的属性</span></span><br><span class="line"><span class="comment">     *  @param    &#123;Object&#125;  lastProps  [旧属性]</span></span><br><span class="line"><span class="comment">     *  @param    &#123;Object&#125;  nextProps  [新属性]</span></span><br><span class="line"><span class="comment">     *  @private</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    _updateDOMProperties(lastProps, nextProps) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; _rootNodeID &#125; = <span class="keyword">this</span>,</span><br><span class="line">        element = $(<span class="string">`[data-reactid="<span class="subst">$&#123;_rootNodeID&#125;</span>"]`</span>);</span><br><span class="line">        <span class="keyword">let</span> propKey, propValue, eventType, removed;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (propKey <span class="keyword">in</span> lastProps) &#123;</span><br><span class="line">            <span class="comment">//  只删除老属性中有但是新属性中没有的</span></span><br><span class="line">            <span class="keyword">if</span> (hasOwnProperty(lastProps, propKey) &amp;&amp; !hasOwnProperty(nextProps, propKey)) &#123;</span><br><span class="line">                propValue = lastProps[propKey];</span><br><span class="line"></span><br><span class="line">                <span class="comment">//  之前的事件代理需要解除</span></span><br><span class="line">                <span class="keyword">if</span> (EVENT_REG.test(propKey)) &#123;</span><br><span class="line">                    eventType = propKey.replace(<span class="string">"on"</span>, <span class="string">""</span>);</span><br><span class="line">                    Event.undelegate(&#123;</span><br><span class="line">                        element: doc,</span><br><span class="line">                        type: eventType,</span><br><span class="line">                        selector: <span class="string">`[data-reactid="<span class="subst">$&#123;_rootNodeID&#125;</span>"]`</span></span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === <span class="string">"className"</span>) &#123;</span><br><span class="line">                    removed = <span class="string">"class"</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    removed = propKey;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//  删除DOM上的相关属性</span></span><br><span class="line">                element.removeAttribute(removed);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  开始遍历新属性集合</span></span><br><span class="line">        <span class="keyword">for</span> (propKey <span class="keyword">in</span> nextProps) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasOwnProperty(nextProps, propKey) &amp;&amp; propKey !== <span class="string">"children"</span>) &#123;</span><br><span class="line">                propValue = lastProps[propKey];</span><br><span class="line">              	<span class="comment">//	重新代理事件</span></span><br><span class="line">                <span class="keyword">if</span> (EVENT_REG.test(propKey)) &#123;</span><br><span class="line">                    eventType = propKey.replace(<span class="string">"on"</span>, <span class="string">""</span>);</span><br><span class="line">                    Event.undelegate(&#123;</span><br><span class="line">                        element: doc,</span><br><span class="line">                        type: eventType,</span><br><span class="line">                        selector: <span class="string">`[data-reactid="<span class="subst">$&#123;_rootNodeID&#125;</span>"]`</span></span><br><span class="line">                    &#125;);</span><br><span class="line">                    Event.delegate(&#123;</span><br><span class="line">                        element: doc,</span><br><span class="line">                        type: eventType,</span><br><span class="line">                        selector: <span class="string">`[data-reactid="<span class="subst">$&#123;_rootNodeID&#125;</span>"]`</span>,</span><br><span class="line">                        handler: propValue,</span><br><span class="line">                        context: <span class="literal">null</span></span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === <span class="string">"className"</span>) &#123;</span><br><span class="line">                    element.setAttribute(<span class="string">"class"</span>, propValue);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === <span class="string">"style"</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (lodash.isObject(propValue)) &#123;</span><br><span class="line">                        propValue = toStyle.string(propValue);</span><br><span class="line">                    &#125;</span><br><span class="line">                    element.setAttribute(propKey, propValue);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    element.setAttribute(propKey, propValue);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  更新子元素</span></span><br><span class="line"><span class="comment">     *  @param    &#123;Array&#125;  nextChildrenElements  [被更新的组件队列]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    _updateDOMChildren(nextChildrenElements) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextChildrenElements &amp;&amp; nextChildrenElements.length) &#123;</span><br><span class="line"></span><br><span class="line">            update.updateDepth++;</span><br><span class="line">            <span class="comment">//  递归找出差别, 组装差异对象</span></span><br><span class="line">            update.diff(update.diffQueue, nextChildrenElements, <span class="keyword">this</span>);</span><br><span class="line">            update.updateDepth--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  应用更新</span></span><br><span class="line">            <span class="keyword">if</span> (update.updateDepth === <span class="number">0</span>) &#123;</span><br><span class="line">                update.patch(update.diffQueue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>_updateDOMChildren</code>中我们调用了<code>update.diff</code>和<code>update.patch</code>方法，一个对比一个应用，这里我是把<code>diff</code>和<code>patch</code>放到一个对象下作为一个模块暴露出去的，下面就是具体的实现代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//	定义更新类型(移动已经存在的，删除节点，插入的新标签)</span></span><br><span class="line"><span class="keyword">const</span> UPDATE_TYPES = &#123;</span><br><span class="line">    MOVE_EXISTING: <span class="number">1</span>,</span><br><span class="line">    REMOVE_NODE: <span class="number">2</span>,</span><br><span class="line">    INSERT_MARKUP: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> update = &#123;</span><br><span class="line">    <span class="comment">//  更新深度标识</span></span><br><span class="line">    updateDepth: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  更新队列</span></span><br><span class="line">    diffQueue: [],</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  递归找出差别, 组装差异对象, 添加到更新队列diffQueue</span></span><br><span class="line"><span class="comment">     *  @param   &#123;Array&#125;  diffQueue             [更新队列]</span></span><br><span class="line"><span class="comment">     *  @param   &#123;Array&#125;  nextChildrenElements  [新的子组件集合]</span></span><br><span class="line"><span class="comment">     *  @param   &#123;Object&#125; component             [被diff的组件]</span></span><br><span class="line"><span class="comment">     *  @return  &#123;Array&#125;                        [需要更新的内容]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    diff(diffQueue, nextChildrenElements, component) &#123;</span><br><span class="line">        <span class="comment">//  获取到当前组件下已经渲染的组件集合，把component._renderedChildren扁平成一个对象，如果child有key，就拿key作为对应的属性名，否则用下标做属性名，具体实现可以看下面</span></span><br><span class="line">        <span class="keyword">const</span> prevChildren = flattenChildren(component._renderedChildren),</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  生成新的子节点的component对象集合(如果是组件有更新, 就复用原来的, 如果是新增就是新的组件实例)</span></span><br><span class="line">            nextChildren = generateComponentChildren(prevChildren, nextChildrenElements);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> lastIndex = <span class="number">0</span>,</span><br><span class="line">            nextIndex = <span class="number">0</span>,</span><br><span class="line">            prevChild = <span class="literal">null</span>,</span><br><span class="line">            nextChild = <span class="literal">null</span>,</span><br><span class="line">            name, props, propKey, eventType;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  枚举nextChildren</span></span><br><span class="line">        <span class="keyword">for</span> (name <span class="keyword">in</span> nextChildren) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasOwnProperty(nextChildren, name)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            prevChild = prevChildren &amp;&amp; prevChildren[name];</span><br><span class="line">            nextChild = nextChildren[name];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  两个相同说明是使用的同一个component,所以我们需要做移动的操作</span></span><br><span class="line">            <span class="keyword">if</span> (lodash.isEqual(prevChild, nextChild)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (prevChild._mountIndex &lt; lastIndex) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.diffQueue.push(&#123;</span><br><span class="line">                        parentId: component._rootNodeID,</span><br><span class="line">                        parentNode: $(<span class="string">`[data-reactid="<span class="subst">$&#123;component._rootNodeID&#125;</span>"]`</span>),</span><br><span class="line">                        type: UPDATE_TYPES.MOVE_EXISTING,</span><br><span class="line">                      	<span class="comment">//	从组件原来的mountIndex</span></span><br><span class="line">                        fromIndex: prevChild._mountIndex,</span><br><span class="line">                      	<span class="comment">//	到nextIndex</span></span><br><span class="line">                        toIndex: nextIndex</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">              </span><br><span class="line">              	<span class="comment">//	缓存上次遍历时最大的index</span></span><br><span class="line">                lastIndex = <span class="built_in">Math</span>.max(prevChild._mountIndex, lastIndex);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//  之前存在子节点, 需要先将子节点移除</span></span><br><span class="line">                <span class="keyword">if</span> (prevChild) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.diffQueue.push(&#123;</span><br><span class="line">                        parentId: component._rootNodeID,</span><br><span class="line">                        parentNode: $(<span class="string">`[data-reactid="<span class="subst">$&#123;component._rootNodeID&#125;</span>"]`</span>),</span><br><span class="line">                        type: UPDATE_TYPES.REMOVE_NODE,</span><br><span class="line">                        fromIndex: prevChild._mountIndex,</span><br><span class="line">                        toIndex: <span class="literal">null</span></span><br><span class="line">                    &#125;);</span><br><span class="line">                    lastIndex = <span class="built_in">Math</span>.max(prevChild._mountIndex, lastIndex);</span><br><span class="line"></span><br><span class="line">                    props = (prevChild._currentElement &amp;&amp; prevChild._currentElement.props) ? prevChild._currentElement.props : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">                  	<span class="comment">//	对移除的子节点需要进行事件代理的接触，防止重复</span></span><br><span class="line">                    <span class="keyword">for</span> (propKey <span class="keyword">in</span> props) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (hasOwnProperty(props, propKey) &amp;&amp; EVENT_REG.test(propKey)) &#123;</span><br><span class="line">                            eventType = propKey.replace(<span class="string">"on"</span>, <span class="string">""</span>);</span><br><span class="line">                            Event.undelegate(&#123;</span><br><span class="line">                                element: doc,</span><br><span class="line">                                type: eventType,</span><br><span class="line">                                selector: <span class="string">`[data-reactid="<span class="subst">$&#123;prevChild._rootNodeID&#125;</span>"]`</span></span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//  新增的节点, 需要push到diffQueue</span></span><br><span class="line">                <span class="keyword">if</span> (nextChild) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.diffQueue.push(&#123;</span><br><span class="line">                        parentId: component._rootNodeID,</span><br><span class="line">                        parentNode: $(<span class="string">`[data-reactid="<span class="subst">$&#123;component._rootNodeID&#125;</span>"]`</span>),</span><br><span class="line">                        type: UPDATE_TYPES.INSERT_MARKUP,</span><br><span class="line">                        fromIndex: <span class="literal">null</span>,</span><br><span class="line">                        toIndex: nextIndex,</span><br><span class="line">                        markup: nextChild.mountComponent(<span class="string">`<span class="subst">$&#123;component._rootNodeID&#125;</span>.<span class="subst">$&#123;name&#125;</span>`</span>)</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  更新_mountIndex和nextIndex</span></span><br><span class="line">            nextChild._mountIndex = nextIndex;</span><br><span class="line">            nextIndex++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  把nextChildren克隆一份给_renderedChildren</span></span><br><span class="line">            component._renderedChildren = makeArray(nextChildren);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  应用更新, 执行DOM操作</span></span><br><span class="line"><span class="comment">     *  @param   &#123;Array&#125;  updates  [差异对象集合]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    patch(updates) &#123;</span><br><span class="line">        <span class="keyword">let</span> initialChildren = &#123;&#125;,</span><br><span class="line">            deleteChildren = [],</span><br><span class="line">            updatedIndex, updatedChild, parentID;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> update <span class="keyword">of</span> updates) &#123;</span><br><span class="line">            updatedIndex = update.fromIndex;</span><br><span class="line">            updatedChild = update.parentNode.children[updatedIndex];</span><br><span class="line">            parentID = update.parentID;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  把所有需要更新的节点都保存下来</span></span><br><span class="line">            initialChildren[parentID] = initialChildren[parentID] || [];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  使用parentID作为简易命名空间</span></span><br><span class="line">            initialChildren[parentID][updatedIndex] = updatedChild;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  所有需要修改的节点先删除,对于move的,后面再重新插入到正确的位置即可</span></span><br><span class="line">            <span class="keyword">if</span> (!lodash.isNull(updatedChild) &amp;&amp; !lodash.isUndefined(updatedChild)) &#123;</span><br><span class="line">                deleteChildren.push(updatedChild);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  删除需要删除的节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> child <span class="keyword">of</span> deleteChildren) &#123;</span><br><span class="line">            child.parentNode.removeChild(child);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> updateItem <span class="keyword">of</span> updates) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (updateItem.type) &#123;</span><br><span class="line">                <span class="comment">//  插入新元素</span></span><br><span class="line">                <span class="keyword">case</span> UPDATE_TYPES.INSERT_MARKUP:</span><br><span class="line">                    insertChildAt(updateItem.parentNode, updateItem.markup, updateItem.toIndex);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//  元素位置发生改变    </span></span><br><span class="line">                <span class="keyword">case</span> UPDATE_TYPES.MOVE_EXISTING:</span><br><span class="line">                    insertChildAt(updateItem.parentNode, initialChildren[updateItem.parentID][updateItem.fromIndex], updateItem.toIndex);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//  上面已经删除, 所以不需要处理</span></span><br><span class="line">                <span class="keyword">case</span> UPDATE_TYPES.REMOVE_NODE:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  重置相关变量</span></span><br><span class="line">        <span class="keyword">this</span>.reset();</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  重置相关变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    reset() &#123;</span><br><span class="line">        <span class="keyword">this</span>.updateDepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.diffQueue = [];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在<code>diff</code>中，我们看到了两个新方法，分别是<code>flattenChildren</code>和<code>generateComponentChildren</code>，我们先看下<code>flattenChildren</code>的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  把原来是数组的子组件集合转换成Map返回</span></span><br><span class="line"><span class="comment"> *  @param   &#123;Array&#125;  componentChildren     [子组件集合]</span></span><br><span class="line"><span class="comment"> *  @return  &#123;Object&#125;                       [输出的Map, 每个子组件的key或者一个随机数做key]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flattenChildren</span>(<span class="params">componentChildren</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> childrenMap = &#123;&#125;,</span><br><span class="line">        child, name, i, len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, len = componentChildren.length; i &lt; len; i++) &#123;</span><br><span class="line">        child = componentChildren[i];</span><br><span class="line">        name = child &amp;&amp; child._currentelement &amp;&amp; child._currentelement.key ? child._currentelement.key : i.toString(<span class="number">36</span>);</span><br><span class="line">        childrenMap[name] = child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> childrenMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>generateComponentChildren</code>我们大概需要完成下面几件事情：</p>
<ul>
<li>遍历拿到即将渲染的新组件<code>children</code>（做参数 <code>nextChildrenElements</code>传入）和老节点进行对比</li>
<li>如果老节点存在且和新节点有差异，即调用老节点下的<code>receiveComponent</code>去更新</li>
<li>否则如果老节点不存在，则重新调用<code>instantiateReactComponent</code>返回一个组件实例</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  生成子节点elements的component集合</span></span><br><span class="line"><span class="comment"> *  @param   &#123;Object&#125;  prevChildren          [flattenChildren返回的Map]</span></span><br><span class="line"><span class="comment"> *  @param   &#123;Array&#125;   nextChildrenElements  [即将要渲染的节点]</span></span><br><span class="line"><span class="comment"> *  @return  &#123;Object&#125;                        [子节点elements的component集合]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateComponentChildren</span>(<span class="params">prevChildren, nextChildrenElements</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> nextChildren = &#123;&#125;,</span><br><span class="line">        index, len, name, prevChild, prevElement, nextElement, nextChildInstance, element;</span><br><span class="line">    nextChildrenElements = nextChildrenElements || [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>, len = nextChildrenElements.length; index &lt; len; index++) &#123;</span><br><span class="line">        element = nextChildrenElements[index];</span><br><span class="line">        name = (element &amp;&amp; element.key) ? element.key : index;</span><br><span class="line">        prevChild = prevChildren &amp;&amp; prevChildren[name];</span><br><span class="line">        prevElement = prevChild &amp;&amp; prevChild._currentElement;</span><br><span class="line">        nextElement = element;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  组件有更新, 调用当前组件下的reciveComponent去更新组件</span></span><br><span class="line">        <span class="keyword">if</span> (shouldUpdateReactComponent(prevElement, nextElement)) &#123;</span><br><span class="line">            prevChild.receiveComponent(nextElement);</span><br><span class="line">            nextChildren[name] = prevChild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//  新节点, 实例化新组件</span></span><br><span class="line">            nextChildInstance = instantiateReactComponent(nextElement);</span><br><span class="line">            nextChildren[name] = nextChildInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nextChildren;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在之前好几个地方我们都看到了<code>shouldUpdateReactComponent</code>这个方法，它完成的功能主要是判断两个<code>Vnode</code>之前是否有差异，返回布尔值，主要完成下面几件事情：</p>
<ul>
<li>如果新老<code>Vnode</code>有一个或者都为空，直接返回<code>false</code></li>
<li>文本节点之间的对比</li>
<li>当新的<code>Vnode</code>的<code>type</code>是<code>object</code>，比较老节点的<code>type</code>和<code>key</code>，并且拿到两者的<code>children</code>数组，做一个简单的长度对比</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  判断组件是否需要更新</span></span><br><span class="line"><span class="comment"> *  @param   &#123;Object&#125;  prevElement  [老的vnode]</span></span><br><span class="line"><span class="comment"> *  @param   &#123;Object&#125;  nextElement  [新的vnode]</span></span><br><span class="line"><span class="comment"> *  @return  &#123;Boolean&#125;              [标识组件是否需要更新]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">shouldUpdateReactComponent</span>(<span class="params">prevElement, nextElement</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//  排除为空的情况</span></span><br><span class="line">    <span class="keyword">if</span> (!lodash.isNull(prevElement) &amp;&amp; !lodash.isNull(nextElement) &amp;&amp; !lodash.isUndefined(prevElement) &amp;&amp; !lodash.isUndefined(nextElement)) &#123;</span><br><span class="line">        <span class="keyword">const</span> prevType = <span class="keyword">typeof</span> prevElement,</span><br><span class="line">            nextType = <span class="keyword">typeof</span> nextElement;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  纯文本组件</span></span><br><span class="line">        <span class="keyword">if</span> (prevType === <span class="string">"number"</span> || prevType === <span class="string">"string"</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (nextType === <span class="string">"number"</span> || nextType === <span class="string">"number"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> prevChildren = [],</span><br><span class="line">                nextChildren = [],</span><br><span class="line">                childEqual = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(prevElement &amp;&amp; prevElement.props) &#123;</span><br><span class="line">                prevChildren = prevElement.props.children || [];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nextElement &amp;&amp; nextElement.props) &#123;</span><br><span class="line">                nextChildren = nextElement.props.children || [];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            childEqual = prevChildren.length === nextChildren.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (nextType === <span class="string">"object"</span> &amp;&amp;</span><br><span class="line">                (prevElement.type === nextElement.type) &amp;&amp;</span><br><span class="line">                (prevElement.key === nextElement.key) &amp;&amp;</span><br><span class="line">                childEqual);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里我们就实现一个<code>setState</code>和生命周期，在例子中实现了一个<code>Todo</code>，一起看下效果</p>
<p><img src="/imgs/todo.gif" alt="todo"></p>
<p>至此我们就实现了一个简单的<code>React</code>，但是仅仅实现了<code>虚拟节点</code>，<code>差异算法</code>，<code>props单向数据流</code>，还有很多更优秀的没实现，比如批量更新，事件优化，组件中的<code>refs</code>，服务端渲染等等，只是一个玩具，对于想深入了解<code>React</code>原理的可能会有些帮助。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/09/25/2017-09-25-read-webpack-source/" class="prev">上一篇</a><a href="/2017/09/04/2017-09-04-write-your-own-react-1/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2020 <a href="http://yoursite.com">rwson</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>