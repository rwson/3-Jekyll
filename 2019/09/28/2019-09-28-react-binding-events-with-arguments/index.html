<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> React事件绑定终极优化方案 · 小宋</title><meta name="description" content="React事件绑定终极优化方案 - rwson"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="小宋"><link rel="alternate" href="/atom.xml" title="小宋" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">React事件绑定终极优化方案</h1><div class="post-info">Sep 28, 2019</div><div class="post-content"><p><code>React</code>作为目前炙手可热的前端框架，里面有很多吸引人的地方，但是也有一些开发体验不太好的地方，比如我们平时做事件绑定的时候要显示的绑定<code>this</code>，否则就可能导致各种<code>bug</code>，关于事件<code>this</code>绑定也有很多种形式，各种方法都有优劣，下面我们将对照几种绑定方式来进行对比，最终实现一个适合自己的方案</p>
<h5 id="在构造函数中进行绑定"><a href="#在构造函数中进行绑定" class="headerlink" title="在构造函数中进行绑定"></a>在构造函数中进行绑定</h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      t: <span class="string">'t'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// this.bind1 = this.bind1.bind(this) 无参写法</span></span><br><span class="line">    <span class="keyword">this</span>.bind1 = <span class="keyword">this</span>.bind1.bind(<span class="keyword">this</span>, <span class="keyword">this</span>.state.t)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参写法 </span></span><br><span class="line">    <span class="comment">// bind1 () &#123;</span></span><br><span class="line">    <span class="comment">//   console.log('bind1', this)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">  bind1 (t, event) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'bind1'</span>, <span class="keyword">this</span>, t, event)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.bind1&#125;&gt;打印<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式的优点就是只会生成一个方法实例，并且绑定一次之后如果多次用到这个方法也不需要再绑定。缺点是如果我们直接在<code>constructor</code>中进行绑定的话，参数就无法动态化，只能固定死用<code>state</code>里的值，比如我们一个列表组件，  点击某一条某一个具体操作的时候，需要传入一个<code>id</code>之类的字段作为唯一标识，这种绑定形式就无法处理了，缺点二就是即使不用到<code>state</code>，也需要在构造器里做绑定</p>
<h5 id="行内匿名函数"><a href="#行内匿名函数" class="headerlink" title="行内匿名函数"></a>行内匿名函数</h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bind3 (t, event) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bind3'</span>, <span class="keyword">this</span>, t, event)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render () &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      <span class="comment">// &lt;button onClick=&#123;() =&gt; this.bind3()&#125;&gt;打印3&lt;/button&gt; 无参写法</span></span><br><span class="line">      &lt;button onClick=&#123;(event) =&gt; <span class="keyword">this</span>.bind3(<span class="keyword">this</span>.state.t, event)&#125;&gt;打印<span class="number">3</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式的优点就是比较简单，灵活，但是最大的缺点就是在每次<code>render</code>的时候都会执行这个匿名函数，当这个函数作为<code>props</code>传入低阶组件的时候，这些组件可能会进行额外的重新渲染，因为每一次都是新的方法实例作为的新的属性传递，带来了额外的性能开销</p>
<h5 id="在render中显示bind"><a href="#在render中显示bind" class="headerlink" title="在render中显示bind"></a>在<code>render</code>中显示<code>bind</code></h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bind3 (t, event) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'bind3'</span>, <span class="keyword">this</span>, t, event)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> render () &#123;</span><br><span class="line">   <span class="keyword">return</span> (</span><br><span class="line">     &lt;div&gt;</span><br><span class="line">       <span class="comment">// &lt;button onClick=&#123;this.bind3.bind(this)&#125;&gt;打印3&lt;/button&gt; 无参写法</span></span><br><span class="line">       &lt;button onClick=&#123;<span class="keyword">this</span>.bind3.bind(<span class="keyword">this</span>, xxx)&#125;&gt;打印<span class="number">3</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">     &lt;/</span>div&gt;</span><br><span class="line">   )</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这种写法虽然和匿名函数写法上完全不一样，但是缺点基本上可以认为是一样的 😂，也会带来额外的性能开销 </p>
<h5 id="使用属性初始化器语法绑定this"><a href="#使用属性初始化器语法绑定this" class="headerlink" title="使用属性初始化器语法绑定this"></a>使用属性初始化器语法绑定this</h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bind3 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">     xxx: <span class="string">'xxx'</span></span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> render () &#123;</span><br><span class="line">   <span class="keyword">return</span> (</span><br><span class="line">     &lt;div&gt;</span><br><span class="line">       &lt;button onClick=&#123;<span class="keyword">this</span>.bind3&#125;&gt;打印<span class="number">3</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">     &lt;/</span>div&gt;</span><br><span class="line">   )</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这种方法利用了箭头函数中<code>箭头函数内部的this是词法作用域，由上下文确定</code>的特点，写法上比较简单，且不会带来额外性能开销，并且不会像第一种那样带来多余代码，看似很完美，但是和在<code>constructor</code>一样，无法将参数动态化</p>
<h5 id="this-xxx"><a href="#this-xxx" class="headerlink" title="::this.xxx()"></a><code>::this.xxx()</code></h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> bind5()&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'bind5'</span>, <span class="keyword">this</span>)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">   &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;::<span class="keyword">this</span>.bind5&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">   &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"> )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这种方法我自己没用过，所以不知道具体有什么优缺点</p>
<p>上面几种是目前我们写<code>React</code>组件时，基本上都会用到的几种<code>this</code>绑定方式，通过分析来看，多多少少都有一点缺点，目前也有很多开源比如<a href="[https://www.npmjs.com/package/auto-bind](https://www.npmjs.com/package/auto-bind">autobind</a>或者<a href="[https://www.npmjs.com/package/memo-bind](https://www.npmjs.com/package/memo-bind">memo-bind</a>，但是也会有部分不足，所以决定自己实现一个：</p>
<h5 id="bind-with-arguments"><a href="#bind-with-arguments" class="headerlink" title="bind-with-arguments"></a>bind-with-arguments</h5><p>先来看看基础版本的:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindWithArguments</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">  	<span class="comment">//	缓存最终要执行的方法</span></span><br><span class="line">    <span class="keyword">const</span> excuter = target[name];</span><br><span class="line"></span><br><span class="line">		<span class="comment">//	对该方法进行重新包装</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.assign(target, descriptor, &#123;</span><br><span class="line">        value: <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">              	<span class="comment">//	用apply来绑定作用域以及传入外部参数, 并且把执行结果作为返回值</span></span><br><span class="line">                <span class="keyword">return</span> excuterType.apply(target, args);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在测试的过程中发现，上述版本只能满足同步的回调函数，但是很多时候，我们会根据用户操作来发起某个具体的异步请求，所以仅仅上面那部分是不行的，根据<a href="[https://developer.mozilla.org/](https://developer.mozilla.org/">MDN</a>上对<a href="[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction">async</a>的介绍，我们来完善代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindWithArguments</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">  	<span class="comment">//	缓存最终要执行的方法</span></span><br><span class="line">    <span class="keyword">const</span> excutor = target[name];</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">//	普通方法: [object Function] async: [object AsyncFunction]</span></span><br><span class="line">    <span class="keyword">const</span> excutorType = &#123;&#125;.toString.call(excutor).slice(<span class="number">8</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">const</span> isAsync = excutorType === <span class="string">'AsyncFunction'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.assign(target, descriptor, &#123;</span><br><span class="line">        value: <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> isAsync ? <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">              	<span class="comment">//	如果是异步方法，就用async/await包一层再返回出去</span></span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">await</span> excutor.apply(target, args));</span><br><span class="line">            &#125; : <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> excutor.apply(target, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在异步方法已经支持了，看下具体用法</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> deffer = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> asyncFn(a, b) &#123;</span><br><span class="line">        <span class="keyword">await</span> deffer();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'deffer'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//	装饰同步方法</span></span><br><span class="line">    @bindWithArg</span><br><span class="line">    <span class="keyword">async</span> callAsync() &#123;</span><br><span class="line">        <span class="built_in">console</span>.time();</span><br><span class="line">      	<span class="comment">//	内部再调用异步方法</span></span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="keyword">this</span>.asyncFn(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">console</span>.timeEnd();</span><br><span class="line">        <span class="comment">//  后续工作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//	装饰同步方法</span></span><br><span class="line">    @bindWithArg</span><br><span class="line">    syncFn(a, b) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h3&gt;bindWithArguments&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">            		/</span><span class="regexp">/	调用同步方法</span></span><br><span class="line"><span class="regexp">                &lt;p onClick=&#123;this.syncFn('1', &#123;</span></span><br><span class="line"><span class="regexp">                    a: 'xxx',</span></span><br><span class="line"><span class="regexp">                    b: 'yyy'</span></span><br><span class="line"><span class="regexp">                &#125;)&#125;&gt;sync fn&lt;/</span>p&gt;</span><br><span class="line">            		<span class="comment">//	调用异步方法</span></span><br><span class="line">                &lt;p onClick=&#123;<span class="keyword">this</span>.callAsync()&#125;&gt; <span class="keyword">async</span> click fn&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>看上面的例子已经很清楚，但是其实还有一点不太完美的地方，就是我们不需要传入任何参数的时候也是用<code>onClick={ this.xxx() }</code>来调用，对于用惯了<code>autobind</code>的我们可能不太习惯，所以我们继续完善：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> functionMap = &#123;</span><br><span class="line">    <span class="comment">//	异步并且有参数</span></span><br><span class="line">    AsyncWith: <span class="function">(<span class="params">excutor, target, ...argus</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span>  <span class="keyword">async</span> () =&gt; (<span class="keyword">await</span> excutor.apply(target, argus))</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//	异步无参数</span></span><br><span class="line">    AsyncEmpty: <span class="keyword">async</span> (excutor, target) =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">await</span> excutor.call(target));</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//	同步并且有参数</span></span><br><span class="line">    SyncWith: <span class="function">(<span class="params">excutor, target, ...argus</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> excutor.apply(target, argus);;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//	同步无参数</span></span><br><span class="line">    SyncEmpty: <span class="function">(<span class="params">excutor, target</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> excutor.call(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindWithArg</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> excutor = target[name];</span><br><span class="line">    <span class="keyword">const</span> excutorType = &#123;&#125;.toString.call(excutor).slice(<span class="number">8</span>, <span class="number">-1</span>);</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">//	判断是否异步</span></span><br><span class="line">    <span class="keyword">const</span> asyncCall = excutorType === <span class="string">'AsyncFunction'</span> ? <span class="string">'Async'</span> : <span class="string">'Sync'</span>;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">//	判断是否有参数</span></span><br><span class="line">    <span class="keyword">const</span> emptyCall = excutor.length === <span class="number">0</span> ? <span class="string">'Empty'</span> : <span class="string">'With'</span>;</span><br><span class="line">    <span class="keyword">const</span> fnType = <span class="string">`<span class="subst">$&#123;asyncCall&#125;</span><span class="subst">$&#123;emptyCall&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.assign(target, descriptor, &#123;</span><br><span class="line">        value: functionMap[fnType].bind(<span class="literal">null</span>, excutor, target)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，就完成了所有功能，主要是用到闭包和函数形参的一些知识点，本项目已经开源到<a href="https://github.com/rwson/bind-with-arguments.git" target="_blank" rel="noopener">github</a>，需要了解详细的请移步</p>
<p>需要注意的是，此装饰器不支持<code>使用属性初始化器语法绑定this</code>的写法，因为这种写法在定义该函数时，已经做了绑定，所以无需做重复工作</p>
</div></article></div></main><footer><div class="paginator"><a href="/2020/03/26/2020-03-26-read-npx/" class="prev">上一篇</a><a href="/2018/06/06/2018-06-06-read-redux-logic/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2020 <a href="http://yoursite.com">rwson</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>